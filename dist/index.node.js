var __create=Object.create;var __defProp=Object.defineProperty;var __getOwnPropDesc=Object.getOwnPropertyDescriptor;var __getOwnPropNames=Object.getOwnPropertyNames;var __getProtoOf=Object.getPrototypeOf;var __hasOwnProp=Object.prototype.hasOwnProperty;var __commonJS=(cb,mod)=>function __require(){return mod||(0,cb[__getOwnPropNames(cb)[0]])((mod={exports:{}}).exports,mod),mod.exports};var __export=(target,all)=>{for(var name in all)__defProp(target,name,{get:all[name],enumerable:true})};var __copyProps=(to,from,except,desc)=>{if(from&&typeof from==="object"||typeof from==="function"){for(let key of __getOwnPropNames(from))if(!__hasOwnProp.call(to,key)&&key!==except)__defProp(to,key,{get:()=>from[key],enumerable:!(desc=__getOwnPropDesc(from,key))||desc.enumerable})}return to};var __toESM=(mod,isNodeMode,target)=>(target=mod!=null?__create(__getProtoOf(mod)):{},__copyProps(isNodeMode||!mod||!mod.__esModule?__defProp(target,"default",{value:mod,enumerable:true}):target,mod));var __toCommonJS=mod=>__copyProps(__defProp({},"__esModule",{value:true}),mod);var require_build=__commonJS({"node_modules/better-sse/build/index.js"(exports2,module2){!function(e,t2){if("object"==typeof exports2&&"object"==typeof module2)module2.exports=t2();else if("function"==typeof define&&define.amd)define([],t2);else{var s=t2();for(var i in s)("object"==typeof exports2?exports2:e)[i]=s[i]}}(global,()=>(()=>{"use strict";var e={n:t3=>{var s2=t3&&t3.__esModule?()=>t3.default:()=>t3;return e.d(s2,{a:s2}),s2},d:(t3,s2)=>{for(var i2 in s2)e.o(s2,i2)&&!e.o(t3,i2)&&Object.defineProperty(t3,i2,{enumerable:true,get:s2[i2]})},o:(e2,t3)=>Object.prototype.hasOwnProperty.call(e2,t3),r:e2=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e2,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e2,"__esModule",{value:true})}},t2={};e.r(t2),e.d(t2,{Channel:()=>g,EventBuffer:()=>d,Session:()=>m,SseError:()=>v,createChannel:()=>y2,createEventBuffer:()=>w,createSession:()=>b});const s=require("http"),i=e2=>JSON.stringify(e2),r=/(\r\n|\r|\n)/g,n=/\n+$/g,o=e2=>{let t3=e2;return t3=t3.replace(r,"\n"),t3=t3.replace(n,""),t3},h=require("crypto");let a;a=h.randomUUID?()=>(0,h.randomUUID)():()=>(0,h.randomBytes)(4).toString("hex");const c=e2=>async(t3,s2={})=>{const{eventName:i2="stream"}=s2;return await new Promise((s3,r2)=>{t3.on("data",t4=>{let s4;s4=Buffer.isBuffer(t4)?t4.toString():t4,e2(s4,i2)}),t3.once("end",()=>s3(true)),t3.once("close",()=>s3(true)),t3.once("error",e3=>r2(e3))})},l=e2=>async(t3,s2={})=>{const{eventName:i2="iteration"}=s2;for await(const s3 of t3)e2(s3,i2)};class d{constructor(e2={}){var t3,s2;this.buffer="",this.writeField=(e3,t4)=>{const s3=this.sanitize(t4);return this.buffer+=e3+":"+s3+"\n",this},this.data=e3=>{const t4=this.serialize(e3);return this.writeField("data",t4),this},this.id=(e3="")=>(this.writeField("id",e3),this),this.retry=e3=>{const t4=e3.toString();return this.writeField("retry",t4),this},this.comment=(e3="")=>(this.writeField("",e3),this),this.dispatch=()=>(this.buffer+="\n",this),this.push=(e3,t4="message",s3=a())=>(this.event(t4).id(s3).data(e3).dispatch(),this),this.stream=c(this.push),this.iterate=l(this.push),this.clear=()=>(this.buffer="",this),this.read=()=>this.buffer,this.serialize=null!==(t3=e2.serializer)&&void 0!==t3?t3:i,this.sanitize=null!==(s2=e2.sanitizer)&&void 0!==s2?s2:o}event(e2){return this.writeField("event",e2),this}}const u2=require("events");var f=e.n(u2);class p extends f(){addListener(e2,t3){return super.addListener(e2,t3)}prependListener(e2,t3){return super.prependListener(e2,t3)}prependOnceListener(e2,t3){return super.prependOnceListener(e2,t3)}on(e2,t3){return super.on(e2,t3)}once(e2,t3){return super.once(e2,t3)}emit(e2,...t3){return super.emit(e2,...t3)}off(e2,t3){return super.off(e2,t3)}removeListener(e2,t3){return super.removeListener(e2,t3)}}class v extends Error{constructor(e2){super(e2),this.message=`better-sse: ${e2}`}}class m extends p{constructor(e2,t3,r2={}){var n2,h2,u3,f2,p2,m2,b2;super(),this.lastId="",this.isConnected=false,this.state={},this.initialize=()=>{var e3,t4,i2;const r3=`http://${this.req.headers.host}${this.req.url}`,n3=new URL(r3).searchParams;if(this.trustClientEventId){const s2=null!==(i2=null!==(t4=null!==(e3=this.req.headers["last-event-id"])&&void 0!==e3?e3:n3.get("lastEventId"))&&void 0!==t4?t4:n3.get("evs_last_event_id"))&&void 0!==i2?i2:"";this.lastId=s2}const o2={};this.res instanceof s.ServerResponse?(o2["Content-Type"]="text/event-stream",o2["Cache-Control"]="private, no-cache, no-store, no-transform, must-revalidate, max-age=0",o2.Connection="keep-alive",o2.Pragma="no-cache",o2["X-Accel-Buffering"]="no"):(o2["content-type"]="text/event-stream",o2["cache-control"]="private, no-cache, no-store, no-transform, must-revalidate, max-age=0",o2.pragma="no-cache",o2["x-accel-buffering"]="no");for(const[e4,t5]of Object.entries(this.headers))o2[e4]=null!=t5?t5:"";this.res.writeHead(this.statusCode,o2),n3.has("padding")&&this.buffer.comment(" ".repeat(2049)).dispatch(),n3.has("evs_preamble")&&this.buffer.comment(" ".repeat(2056)).dispatch(),null!==this.initialRetry&&this.buffer.retry(this.initialRetry).dispatch(),this.flush(),null!==this.keepAliveInterval&&(this.keepAliveTimer=setInterval(this.keepAlive,this.keepAliveInterval)),this.isConnected=true,this.emit("connected")},this.onDisconnected=()=>{this.req.removeListener("close",this.onDisconnected),this.res.removeListener("close",this.onDisconnected),this.keepAliveTimer&&clearInterval(this.keepAliveTimer),this.isConnected=false,this.emit("disconnected")},this.keepAlive=()=>{this.buffer.comment().dispatch(),this.flush()},this.data=e3=>(this.buffer.data(e3),this),this.id=(e3="")=>(this.buffer.id(e3),this.lastId=e3,this),this.retry=e3=>(this.buffer.retry(e3),this),this.comment=e3=>(this.buffer.comment(e3),this),this.dispatch=()=>(this.buffer.dispatch(),this),this.flush=()=>(this.res.write(this.buffer.read()),this.buffer.clear(),this),this.push=(e3,t4="message",s2=a())=>{if(!this.isConnected)throw new v("Cannot push data to a non-active session.");return this.buffer.push(e3,t4,s2),this.flush(),this.lastId=s2,this.emit("push",e3,t4,s2),this},this.stream=c(this.push),this.iterate=l(this.push),this.batch=async e3=>{if(e3 instanceof d)this.res.write(e3.read());else{const t4=new d({serializer:this.serialize,sanitizer:this.sanitize});await e3(t4),this.res.write(t4.read())}},this.req=e2,this.res=t3;const g2=null!==(n2=r2.serializer)&&void 0!==n2?n2:i,y3=null!==(h2=r2.sanitizer)&&void 0!==h2?h2:o;this.serialize=g2,this.sanitize=y3,this.buffer=new d({serializer:g2,sanitizer:y3}),this.trustClientEventId=null===(u3=r2.trustClientEventId)||void 0===u3||u3,this.initialRetry=null===r2.retry?null:null!==(f2=r2.retry)&&void 0!==f2?f2:2e3,this.keepAliveInterval=null===r2.keepAlive?null:null!==(p2=r2.keepAlive)&&void 0!==p2?p2:1e4,this.statusCode=null!==(m2=r2.statusCode)&&void 0!==m2?m2:200,this.headers=null!==(b2=r2.headers)&&void 0!==b2?b2:{},this.req.once("close",this.onDisconnected),this.res.once("close",this.onDisconnected),setImmediate(this.initialize)}event(e2){return this.buffer.event(e2),this}}const b=(...e2)=>new Promise(t3=>{const s2=new m(...e2);s2.once("connected",()=>{t3(s2)})});class g extends p{constructor(){super(),this.state={},this.sessions=new Set,this.broadcast=(e2,t3="message",s2={})=>{var i2;const r2=null!==(i2=s2.eventId)&&void 0!==i2?i2:a(),n2=s2.filter?this.activeSessions.filter(s2.filter):this.sessions;for(const s3 of n2)s3.push(e2,t3,r2);return this.emit("broadcast",e2,t3,r2),this}}get activeSessions(){return Array.from(this.sessions)}get sessionCount(){return this.sessions.size}register(e2){if(this.sessions.has(e2))return this;if(!e2.isConnected)throw new v("Cannot register a non-active session.");return e2.once("disconnected",()=>{this.emit("session-disconnected",e2),this.deregister(e2)}),this.sessions.add(e2),this.emit("session-registered",e2),this}deregister(e2){return this.sessions.has(e2)?(this.sessions.delete(e2),this.emit("session-deregistered",e2),this):this}}const y2=(...e2)=>new g(...e2),w=(...e2)=>new d(...e2);return t2})())}});var require_stream=__commonJS({"node_modules/ws/lib/stream.js"(exports2,module2){"use strict";var{Duplex}=require("stream");function emitClose(stream){stream.emit("close")}function duplexOnEnd(){if(!this.destroyed&&this._writableState.finished){this.destroy()}}function duplexOnError(err){this.removeListener("error",duplexOnError);this.destroy();if(this.listenerCount("error")===0){this.emit("error",err)}}function createWebSocketStream2(ws,options){let terminateOnDestroy=true;const duplex=new Duplex({...options,autoDestroy:false,emitClose:false,objectMode:false,writableObjectMode:false});ws.on("message",function message(msg,isBinary){const data=!isBinary&&duplex._readableState.objectMode?msg.toString():msg;if(!duplex.push(data))ws.pause()});ws.once("error",function error(err){if(duplex.destroyed)return;terminateOnDestroy=false;duplex.destroy(err)});ws.once("close",function close(){if(duplex.destroyed)return;duplex.push(null)});duplex._destroy=function(err,callback){if(ws.readyState===ws.CLOSED){callback(err);process.nextTick(emitClose,duplex);return}let called=false;ws.once("error",function error(err2){called=true;callback(err2)});ws.once("close",function close(){if(!called)callback(err);process.nextTick(emitClose,duplex)});if(terminateOnDestroy)ws.terminate()};duplex._final=function(callback){if(ws.readyState===ws.CONNECTING){ws.once("open",function open(){duplex._final(callback)});return}if(ws._socket===null)return;if(ws._socket._writableState.finished){callback();if(duplex._readableState.endEmitted)duplex.destroy()}else{ws._socket.once("finish",function finish(){callback()});ws.close()}};duplex._read=function(){if(ws.isPaused)ws.resume()};duplex._write=function(chunk,encoding,callback){if(ws.readyState===ws.CONNECTING){ws.once("open",function open(){duplex._write(chunk,encoding,callback)});return}ws.send(chunk,callback)};duplex.on("end",duplexOnEnd);duplex.on("error",duplexOnError);return duplex}module2.exports=createWebSocketStream2}});var require_constants=__commonJS({"node_modules/ws/lib/constants.js"(exports2,module2){"use strict";module2.exports={BINARY_TYPES:["nodebuffer","arraybuffer","fragments"],EMPTY_BUFFER:Buffer.alloc(0),GUID:"258EAFA5-E914-47DA-95CA-C5AB0DC85B11",kForOnEventAttribute:Symbol("kIsForOnEventAttribute"),kListener:Symbol("kListener"),kStatusCode:Symbol("status-code"),kWebSocket:Symbol("websocket"),NOOP:()=>{}}}});var require_buffer_util=__commonJS({"node_modules/ws/lib/buffer-util.js"(exports2,module2){"use strict";var{EMPTY_BUFFER}=require_constants();var FastBuffer=Buffer[Symbol.species];function concat(list,totalLength){if(list.length===0)return EMPTY_BUFFER;if(list.length===1)return list[0];const target=Buffer.allocUnsafe(totalLength);let offset=0;for(let i=0;i<list.length;i++){const buf=list[i];target.set(buf,offset);offset+=buf.length}if(offset<totalLength){return new FastBuffer(target.buffer,target.byteOffset,offset)}return target}function _mask(source,mask,output,offset,length){for(let i=0;i<length;i++){output[offset+i]=source[i]^mask[i&3]}}function _unmask(buffer,mask){for(let i=0;i<buffer.length;i++){buffer[i]^=mask[i&3]}}function toArrayBuffer(buf){if(buf.length===buf.buffer.byteLength){return buf.buffer}return buf.buffer.slice(buf.byteOffset,buf.byteOffset+buf.length)}function toBuffer(data){toBuffer.readOnly=true;if(Buffer.isBuffer(data))return data;let buf;if(data instanceof ArrayBuffer){buf=new FastBuffer(data)}else if(ArrayBuffer.isView(data)){buf=new FastBuffer(data.buffer,data.byteOffset,data.byteLength)}else{buf=Buffer.from(data);toBuffer.readOnly=false}return buf}module2.exports={concat,mask:_mask,toArrayBuffer,toBuffer,unmask:_unmask};if(!process.env.WS_NO_BUFFER_UTIL){try{const bufferUtil=require("bufferutil");module2.exports.mask=function(source,mask,output,offset,length){if(length<48)_mask(source,mask,output,offset,length);else bufferUtil.mask(source,mask,output,offset,length)};module2.exports.unmask=function(buffer,mask){if(buffer.length<32)_unmask(buffer,mask);else bufferUtil.unmask(buffer,mask)}}catch(e){}}}});var require_limiter=__commonJS({"node_modules/ws/lib/limiter.js"(exports2,module2){"use strict";var kDone=Symbol("kDone");var kRun=Symbol("kRun");var Limiter=class{constructor(concurrency){this[kDone]=()=>{this.pending--;this[kRun]()};this.concurrency=concurrency||Infinity;this.jobs=[];this.pending=0}add(job){this.jobs.push(job);this[kRun]()}[kRun](){if(this.pending===this.concurrency)return;if(this.jobs.length){const job=this.jobs.shift();this.pending++;job(this[kDone])}}};module2.exports=Limiter}});var require_permessage_deflate=__commonJS({"node_modules/ws/lib/permessage-deflate.js"(exports2,module2){"use strict";var zlib=require("zlib");var bufferUtil=require_buffer_util();var Limiter=require_limiter();var{kStatusCode}=require_constants();var FastBuffer=Buffer[Symbol.species];var TRAILER=Buffer.from([0,0,255,255]);var kPerMessageDeflate=Symbol("permessage-deflate");var kTotalLength=Symbol("total-length");var kCallback=Symbol("callback");var kBuffers=Symbol("buffers");var kError=Symbol("error");var zlibLimiter;var PerMessageDeflate=class{constructor(options,isServer,maxPayload){this._maxPayload=maxPayload|0;this._options=options||{};this._threshold=this._options.threshold!==void 0?this._options.threshold:1024;this._isServer=!!isServer;this._deflate=null;this._inflate=null;this.params=null;if(!zlibLimiter){const concurrency=this._options.concurrencyLimit!==void 0?this._options.concurrencyLimit:10;zlibLimiter=new Limiter(concurrency)}}static get extensionName(){return"permessage-deflate"}offer(){const params={};if(this._options.serverNoContextTakeover){params.server_no_context_takeover=true}if(this._options.clientNoContextTakeover){params.client_no_context_takeover=true}if(this._options.serverMaxWindowBits){params.server_max_window_bits=this._options.serverMaxWindowBits}if(this._options.clientMaxWindowBits){params.client_max_window_bits=this._options.clientMaxWindowBits}else if(this._options.clientMaxWindowBits==null){params.client_max_window_bits=true}return params}accept(configurations){configurations=this.normalizeParams(configurations);this.params=this._isServer?this.acceptAsServer(configurations):this.acceptAsClient(configurations);return this.params}cleanup(){if(this._inflate){this._inflate.close();this._inflate=null}if(this._deflate){const callback=this._deflate[kCallback];this._deflate.close();this._deflate=null;if(callback){callback(new Error("The deflate stream was closed while data was being processed"))}}}acceptAsServer(offers){const opts=this._options;const accepted=offers.find(params=>{if(opts.serverNoContextTakeover===false&&params.server_no_context_takeover||params.server_max_window_bits&&(opts.serverMaxWindowBits===false||typeof opts.serverMaxWindowBits==="number"&&opts.serverMaxWindowBits>params.server_max_window_bits)||typeof opts.clientMaxWindowBits==="number"&&!params.client_max_window_bits){return false}return true});if(!accepted){throw new Error("None of the extension offers can be accepted")}if(opts.serverNoContextTakeover){accepted.server_no_context_takeover=true}if(opts.clientNoContextTakeover){accepted.client_no_context_takeover=true}if(typeof opts.serverMaxWindowBits==="number"){accepted.server_max_window_bits=opts.serverMaxWindowBits}if(typeof opts.clientMaxWindowBits==="number"){accepted.client_max_window_bits=opts.clientMaxWindowBits}else if(accepted.client_max_window_bits===true||opts.clientMaxWindowBits===false){delete accepted.client_max_window_bits}return accepted}acceptAsClient(response){const params=response[0];if(this._options.clientNoContextTakeover===false&&params.client_no_context_takeover){throw new Error('Unexpected parameter "client_no_context_takeover"')}if(!params.client_max_window_bits){if(typeof this._options.clientMaxWindowBits==="number"){params.client_max_window_bits=this._options.clientMaxWindowBits}}else if(this._options.clientMaxWindowBits===false||typeof this._options.clientMaxWindowBits==="number"&&params.client_max_window_bits>this._options.clientMaxWindowBits){throw new Error('Unexpected or invalid parameter "client_max_window_bits"')}return params}normalizeParams(configurations){configurations.forEach(params=>{Object.keys(params).forEach(key=>{let value=params[key];if(value.length>1){throw new Error(`Parameter "${key}" must have only a single value`)}value=value[0];if(key==="client_max_window_bits"){if(value!==true){const num=+value;if(!Number.isInteger(num)||num<8||num>15){throw new TypeError(`Invalid value for parameter "${key}": ${value}`)}value=num}else if(!this._isServer){throw new TypeError(`Invalid value for parameter "${key}": ${value}`)}}else if(key==="server_max_window_bits"){const num=+value;if(!Number.isInteger(num)||num<8||num>15){throw new TypeError(`Invalid value for parameter "${key}": ${value}`)}value=num}else if(key==="client_no_context_takeover"||key==="server_no_context_takeover"){if(value!==true){throw new TypeError(`Invalid value for parameter "${key}": ${value}`)}}else{throw new Error(`Unknown parameter "${key}"`)}params[key]=value})});return configurations}decompress(data,fin,callback){zlibLimiter.add(done=>{this._decompress(data,fin,(err,result)=>{done();callback(err,result)})})}compress(data,fin,callback){zlibLimiter.add(done=>{this._compress(data,fin,(err,result)=>{done();callback(err,result)})})}_decompress(data,fin,callback){const endpoint=this._isServer?"client":"server";if(!this._inflate){const key=`${endpoint}_max_window_bits`;const windowBits=typeof this.params[key]!=="number"?zlib.Z_DEFAULT_WINDOWBITS:this.params[key];this._inflate=zlib.createInflateRaw({...this._options.zlibInflateOptions,windowBits});this._inflate[kPerMessageDeflate]=this;this._inflate[kTotalLength]=0;this._inflate[kBuffers]=[];this._inflate.on("error",inflateOnError);this._inflate.on("data",inflateOnData)}this._inflate[kCallback]=callback;this._inflate.write(data);if(fin)this._inflate.write(TRAILER);this._inflate.flush(()=>{const err=this._inflate[kError];if(err){this._inflate.close();this._inflate=null;callback(err);return}const data2=bufferUtil.concat(this._inflate[kBuffers],this._inflate[kTotalLength]);if(this._inflate._readableState.endEmitted){this._inflate.close();this._inflate=null}else{this._inflate[kTotalLength]=0;this._inflate[kBuffers]=[];if(fin&&this.params[`${endpoint}_no_context_takeover`]){this._inflate.reset()}}callback(null,data2)})}_compress(data,fin,callback){const endpoint=this._isServer?"server":"client";if(!this._deflate){const key=`${endpoint}_max_window_bits`;const windowBits=typeof this.params[key]!=="number"?zlib.Z_DEFAULT_WINDOWBITS:this.params[key];this._deflate=zlib.createDeflateRaw({...this._options.zlibDeflateOptions,windowBits});this._deflate[kTotalLength]=0;this._deflate[kBuffers]=[];this._deflate.on("data",deflateOnData)}this._deflate[kCallback]=callback;this._deflate.write(data);this._deflate.flush(zlib.Z_SYNC_FLUSH,()=>{if(!this._deflate){return}let data2=bufferUtil.concat(this._deflate[kBuffers],this._deflate[kTotalLength]);if(fin){data2=new FastBuffer(data2.buffer,data2.byteOffset,data2.length-4)}this._deflate[kCallback]=null;this._deflate[kTotalLength]=0;this._deflate[kBuffers]=[];if(fin&&this.params[`${endpoint}_no_context_takeover`]){this._deflate.reset()}callback(null,data2)})}};module2.exports=PerMessageDeflate;function deflateOnData(chunk){this[kBuffers].push(chunk);this[kTotalLength]+=chunk.length}function inflateOnData(chunk){this[kTotalLength]+=chunk.length;if(this[kPerMessageDeflate]._maxPayload<1||this[kTotalLength]<=this[kPerMessageDeflate]._maxPayload){this[kBuffers].push(chunk);return}this[kError]=new RangeError("Max payload size exceeded");this[kError].code="WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";this[kError][kStatusCode]=1009;this.removeListener("data",inflateOnData);this.reset()}function inflateOnError(err){this[kPerMessageDeflate]._inflate=null;err[kStatusCode]=1007;this[kCallback](err)}}});var require_validation=__commonJS({"node_modules/ws/lib/validation.js"(exports2,module2){"use strict";var{isUtf8}=require("buffer");var tokenChars=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,0];function isValidStatusCode(code){return code>=1e3&&code<=1014&&code!==1004&&code!==1005&&code!==1006||code>=3e3&&code<=4999}function _isValidUTF8(buf){const len=buf.length;let i=0;while(i<len){if((buf[i]&128)===0){i++}else if((buf[i]&224)===192){if(i+1===len||(buf[i+1]&192)!==128||(buf[i]&254)===192){return false}i+=2}else if((buf[i]&240)===224){if(i+2>=len||(buf[i+1]&192)!==128||(buf[i+2]&192)!==128||buf[i]===224&&(buf[i+1]&224)===128||buf[i]===237&&(buf[i+1]&224)===160){return false}i+=3}else if((buf[i]&248)===240){if(i+3>=len||(buf[i+1]&192)!==128||(buf[i+2]&192)!==128||(buf[i+3]&192)!==128||buf[i]===240&&(buf[i+1]&240)===128||buf[i]===244&&buf[i+1]>143||buf[i]>244){return false}i+=4}else{return false}}return true}module2.exports={isValidStatusCode,isValidUTF8:_isValidUTF8,tokenChars};if(isUtf8){module2.exports.isValidUTF8=function(buf){return buf.length<24?_isValidUTF8(buf):isUtf8(buf)}}else if(!process.env.WS_NO_UTF_8_VALIDATE){try{const isValidUTF8=require("utf-8-validate");module2.exports.isValidUTF8=function(buf){return buf.length<32?_isValidUTF8(buf):isValidUTF8(buf)}}catch(e){}}}});var require_receiver=__commonJS({"node_modules/ws/lib/receiver.js"(exports2,module2){"use strict";var{Writable}=require("stream");var PerMessageDeflate=require_permessage_deflate();var{BINARY_TYPES,EMPTY_BUFFER,kStatusCode,kWebSocket}=require_constants();var{concat,toArrayBuffer,unmask}=require_buffer_util();var{isValidStatusCode,isValidUTF8}=require_validation();var FastBuffer=Buffer[Symbol.species];var GET_INFO=0;var GET_PAYLOAD_LENGTH_16=1;var GET_PAYLOAD_LENGTH_64=2;var GET_MASK=3;var GET_DATA=4;var INFLATING=5;var DEFER_EVENT=6;var Receiver2=class extends Writable{constructor(options={}){super();this._allowSynchronousEvents=options.allowSynchronousEvents!==void 0?options.allowSynchronousEvents:true;this._binaryType=options.binaryType||BINARY_TYPES[0];this._extensions=options.extensions||{};this._isServer=!!options.isServer;this._maxPayload=options.maxPayload|0;this._skipUTF8Validation=!!options.skipUTF8Validation;this[kWebSocket]=void 0;this._bufferedBytes=0;this._buffers=[];this._compressed=false;this._payloadLength=0;this._mask=void 0;this._fragmented=0;this._masked=false;this._fin=false;this._opcode=0;this._totalPayloadLength=0;this._messageLength=0;this._fragments=[];this._errored=false;this._loop=false;this._state=GET_INFO}_write(chunk,encoding,cb){if(this._opcode===8&&this._state==GET_INFO)return cb();this._bufferedBytes+=chunk.length;this._buffers.push(chunk);this.startLoop(cb)}consume(n){this._bufferedBytes-=n;if(n===this._buffers[0].length)return this._buffers.shift();if(n<this._buffers[0].length){const buf=this._buffers[0];this._buffers[0]=new FastBuffer(buf.buffer,buf.byteOffset+n,buf.length-n);return new FastBuffer(buf.buffer,buf.byteOffset,n)}const dst=Buffer.allocUnsafe(n);do{const buf=this._buffers[0];const offset=dst.length-n;if(n>=buf.length){dst.set(this._buffers.shift(),offset)}else{dst.set(new Uint8Array(buf.buffer,buf.byteOffset,n),offset);this._buffers[0]=new FastBuffer(buf.buffer,buf.byteOffset+n,buf.length-n)}n-=buf.length}while(n>0);return dst}startLoop(cb){this._loop=true;do{switch(this._state){case GET_INFO:this.getInfo(cb);break;case GET_PAYLOAD_LENGTH_16:this.getPayloadLength16(cb);break;case GET_PAYLOAD_LENGTH_64:this.getPayloadLength64(cb);break;case GET_MASK:this.getMask();break;case GET_DATA:this.getData(cb);break;case INFLATING:case DEFER_EVENT:this._loop=false;return}}while(this._loop);if(!this._errored)cb()}getInfo(cb){if(this._bufferedBytes<2){this._loop=false;return}const buf=this.consume(2);if((buf[0]&48)!==0){const error=this.createError(RangeError,"RSV2 and RSV3 must be clear",true,1002,"WS_ERR_UNEXPECTED_RSV_2_3");cb(error);return}const compressed=(buf[0]&64)===64;if(compressed&&!this._extensions[PerMessageDeflate.extensionName]){const error=this.createError(RangeError,"RSV1 must be clear",true,1002,"WS_ERR_UNEXPECTED_RSV_1");cb(error);return}this._fin=(buf[0]&128)===128;this._opcode=buf[0]&15;this._payloadLength=buf[1]&127;if(this._opcode===0){if(compressed){const error=this.createError(RangeError,"RSV1 must be clear",true,1002,"WS_ERR_UNEXPECTED_RSV_1");cb(error);return}if(!this._fragmented){const error=this.createError(RangeError,"invalid opcode 0",true,1002,"WS_ERR_INVALID_OPCODE");cb(error);return}this._opcode=this._fragmented}else if(this._opcode===1||this._opcode===2){if(this._fragmented){const error=this.createError(RangeError,`invalid opcode ${this._opcode}`,true,1002,"WS_ERR_INVALID_OPCODE");cb(error);return}this._compressed=compressed}else if(this._opcode>7&&this._opcode<11){if(!this._fin){const error=this.createError(RangeError,"FIN must be set",true,1002,"WS_ERR_EXPECTED_FIN");cb(error);return}if(compressed){const error=this.createError(RangeError,"RSV1 must be clear",true,1002,"WS_ERR_UNEXPECTED_RSV_1");cb(error);return}if(this._payloadLength>125||this._opcode===8&&this._payloadLength===1){const error=this.createError(RangeError,`invalid payload length ${this._payloadLength}`,true,1002,"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");cb(error);return}}else{const error=this.createError(RangeError,`invalid opcode ${this._opcode}`,true,1002,"WS_ERR_INVALID_OPCODE");cb(error);return}if(!this._fin&&!this._fragmented)this._fragmented=this._opcode;this._masked=(buf[1]&128)===128;if(this._isServer){if(!this._masked){const error=this.createError(RangeError,"MASK must be set",true,1002,"WS_ERR_EXPECTED_MASK");cb(error);return}}else if(this._masked){const error=this.createError(RangeError,"MASK must be clear",true,1002,"WS_ERR_UNEXPECTED_MASK");cb(error);return}if(this._payloadLength===126)this._state=GET_PAYLOAD_LENGTH_16;else if(this._payloadLength===127)this._state=GET_PAYLOAD_LENGTH_64;else this.haveLength(cb)}getPayloadLength16(cb){if(this._bufferedBytes<2){this._loop=false;return}this._payloadLength=this.consume(2).readUInt16BE(0);this.haveLength(cb)}getPayloadLength64(cb){if(this._bufferedBytes<8){this._loop=false;return}const buf=this.consume(8);const num=buf.readUInt32BE(0);if(num>Math.pow(2,53-32)-1){const error=this.createError(RangeError,"Unsupported WebSocket frame: payload length > 2^53 - 1",false,1009,"WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");cb(error);return}this._payloadLength=num*Math.pow(2,32)+buf.readUInt32BE(4);this.haveLength(cb)}haveLength(cb){if(this._payloadLength&&this._opcode<8){this._totalPayloadLength+=this._payloadLength;if(this._totalPayloadLength>this._maxPayload&&this._maxPayload>0){const error=this.createError(RangeError,"Max payload size exceeded",false,1009,"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");cb(error);return}}if(this._masked)this._state=GET_MASK;else this._state=GET_DATA}getMask(){if(this._bufferedBytes<4){this._loop=false;return}this._mask=this.consume(4);this._state=GET_DATA}getData(cb){let data=EMPTY_BUFFER;if(this._payloadLength){if(this._bufferedBytes<this._payloadLength){this._loop=false;return}data=this.consume(this._payloadLength);if(this._masked&&(this._mask[0]|this._mask[1]|this._mask[2]|this._mask[3])!==0){unmask(data,this._mask)}}if(this._opcode>7){this.controlMessage(data,cb);return}if(this._compressed){this._state=INFLATING;this.decompress(data,cb);return}if(data.length){this._messageLength=this._totalPayloadLength;this._fragments.push(data)}this.dataMessage(cb)}decompress(data,cb){const perMessageDeflate=this._extensions[PerMessageDeflate.extensionName];perMessageDeflate.decompress(data,this._fin,(err,buf)=>{if(err)return cb(err);if(buf.length){this._messageLength+=buf.length;if(this._messageLength>this._maxPayload&&this._maxPayload>0){const error=this.createError(RangeError,"Max payload size exceeded",false,1009,"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");cb(error);return}this._fragments.push(buf)}this.dataMessage(cb);if(this._state===GET_INFO)this.startLoop(cb)})}dataMessage(cb){if(!this._fin){this._state=GET_INFO;return}const messageLength=this._messageLength;const fragments=this._fragments;this._totalPayloadLength=0;this._messageLength=0;this._fragmented=0;this._fragments=[];if(this._opcode===2){let data;if(this._binaryType==="nodebuffer"){data=concat(fragments,messageLength)}else if(this._binaryType==="arraybuffer"){data=toArrayBuffer(concat(fragments,messageLength))}else{data=fragments}if(this._allowSynchronousEvents){this.emit("message",data,true);this._state=GET_INFO}else{this._state=DEFER_EVENT;setImmediate(()=>{this.emit("message",data,true);this._state=GET_INFO;this.startLoop(cb)})}}else{const buf=concat(fragments,messageLength);if(!this._skipUTF8Validation&&!isValidUTF8(buf)){const error=this.createError(Error,"invalid UTF-8 sequence",true,1007,"WS_ERR_INVALID_UTF8");cb(error);return}if(this._state===INFLATING||this._allowSynchronousEvents){this.emit("message",buf,false);this._state=GET_INFO}else{this._state=DEFER_EVENT;setImmediate(()=>{this.emit("message",buf,false);this._state=GET_INFO;this.startLoop(cb)})}}}controlMessage(data,cb){if(this._opcode===8){if(data.length===0){this._loop=false;this.emit("conclude",1005,EMPTY_BUFFER);this.end()}else{const code=data.readUInt16BE(0);if(!isValidStatusCode(code)){const error=this.createError(RangeError,`invalid status code ${code}`,true,1002,"WS_ERR_INVALID_CLOSE_CODE");cb(error);return}const buf=new FastBuffer(data.buffer,data.byteOffset+2,data.length-2);if(!this._skipUTF8Validation&&!isValidUTF8(buf)){const error=this.createError(Error,"invalid UTF-8 sequence",true,1007,"WS_ERR_INVALID_UTF8");cb(error);return}this._loop=false;this.emit("conclude",code,buf);this.end()}this._state=GET_INFO;return}if(this._allowSynchronousEvents){this.emit(this._opcode===9?"ping":"pong",data);this._state=GET_INFO}else{this._state=DEFER_EVENT;setImmediate(()=>{this.emit(this._opcode===9?"ping":"pong",data);this._state=GET_INFO;this.startLoop(cb)})}}createError(ErrorCtor,message,prefix,statusCode,errorCode){this._loop=false;this._errored=true;const err=new ErrorCtor(prefix?`Invalid WebSocket frame: ${message}`:message);Error.captureStackTrace(err,this.createError);err.code=errorCode;err[kStatusCode]=statusCode;return err}};module2.exports=Receiver2}});var require_sender=__commonJS({"node_modules/ws/lib/sender.js"(exports2,module2){"use strict";var{Duplex}=require("stream");var{randomFillSync}=require("crypto");var PerMessageDeflate=require_permessage_deflate();var{EMPTY_BUFFER}=require_constants();var{isValidStatusCode}=require_validation();var{mask:applyMask,toBuffer}=require_buffer_util();var kByteLength=Symbol("kByteLength");var maskBuffer=Buffer.alloc(4);var RANDOM_POOL_SIZE=8*1024;var randomPool;var randomPoolPointer=RANDOM_POOL_SIZE;var Sender2=class _Sender{constructor(socket,extensions,generateMask){this._extensions=extensions||{};if(generateMask){this._generateMask=generateMask;this._maskBuffer=Buffer.alloc(4)}this._socket=socket;this._firstFragment=true;this._compress=false;this._bufferedBytes=0;this._deflating=false;this._queue=[]}static frame(data,options){let mask;let merge=false;let offset=2;let skipMasking=false;if(options.mask){mask=options.maskBuffer||maskBuffer;if(options.generateMask){options.generateMask(mask)}else{if(randomPoolPointer===RANDOM_POOL_SIZE){if(randomPool===void 0){randomPool=Buffer.alloc(RANDOM_POOL_SIZE)}randomFillSync(randomPool,0,RANDOM_POOL_SIZE);randomPoolPointer=0}mask[0]=randomPool[randomPoolPointer++];mask[1]=randomPool[randomPoolPointer++];mask[2]=randomPool[randomPoolPointer++];mask[3]=randomPool[randomPoolPointer++]}skipMasking=(mask[0]|mask[1]|mask[2]|mask[3])===0;offset=6}let dataLength;if(typeof data==="string"){if((!options.mask||skipMasking)&&options[kByteLength]!==void 0){dataLength=options[kByteLength]}else{data=Buffer.from(data);dataLength=data.length}}else{dataLength=data.length;merge=options.mask&&options.readOnly&&!skipMasking}let payloadLength=dataLength;if(dataLength>=65536){offset+=8;payloadLength=127}else if(dataLength>125){offset+=2;payloadLength=126}const target=Buffer.allocUnsafe(merge?dataLength+offset:offset);target[0]=options.fin?options.opcode|128:options.opcode;if(options.rsv1)target[0]|=64;target[1]=payloadLength;if(payloadLength===126){target.writeUInt16BE(dataLength,2)}else if(payloadLength===127){target[2]=target[3]=0;target.writeUIntBE(dataLength,4,6)}if(!options.mask)return[target,data];target[1]|=128;target[offset-4]=mask[0];target[offset-3]=mask[1];target[offset-2]=mask[2];target[offset-1]=mask[3];if(skipMasking)return[target,data];if(merge){applyMask(data,mask,target,offset,dataLength);return[target]}applyMask(data,mask,data,0,dataLength);return[target,data]}close(code,data,mask,cb){let buf;if(code===void 0){buf=EMPTY_BUFFER}else if(typeof code!=="number"||!isValidStatusCode(code)){throw new TypeError("First argument must be a valid error code number")}else if(data===void 0||!data.length){buf=Buffer.allocUnsafe(2);buf.writeUInt16BE(code,0)}else{const length=Buffer.byteLength(data);if(length>123){throw new RangeError("The message must not be greater than 123 bytes")}buf=Buffer.allocUnsafe(2+length);buf.writeUInt16BE(code,0);if(typeof data==="string"){buf.write(data,2)}else{buf.set(data,2)}}const options={[kByteLength]:buf.length,fin:true,generateMask:this._generateMask,mask,maskBuffer:this._maskBuffer,opcode:8,readOnly:false,rsv1:false};if(this._deflating){this.enqueue([this.dispatch,buf,false,options,cb])}else{this.sendFrame(_Sender.frame(buf,options),cb)}}ping(data,mask,cb){let byteLength;let readOnly;if(typeof data==="string"){byteLength=Buffer.byteLength(data);readOnly=false}else{data=toBuffer(data);byteLength=data.length;readOnly=toBuffer.readOnly}if(byteLength>125){throw new RangeError("The data size must not be greater than 125 bytes")}const options={[kByteLength]:byteLength,fin:true,generateMask:this._generateMask,mask,maskBuffer:this._maskBuffer,opcode:9,readOnly,rsv1:false};if(this._deflating){this.enqueue([this.dispatch,data,false,options,cb])}else{this.sendFrame(_Sender.frame(data,options),cb)}}pong(data,mask,cb){let byteLength;let readOnly;if(typeof data==="string"){byteLength=Buffer.byteLength(data);readOnly=false}else{data=toBuffer(data);byteLength=data.length;readOnly=toBuffer.readOnly}if(byteLength>125){throw new RangeError("The data size must not be greater than 125 bytes")}const options={[kByteLength]:byteLength,fin:true,generateMask:this._generateMask,mask,maskBuffer:this._maskBuffer,opcode:10,readOnly,rsv1:false};if(this._deflating){this.enqueue([this.dispatch,data,false,options,cb])}else{this.sendFrame(_Sender.frame(data,options),cb)}}send(data,options,cb){const perMessageDeflate=this._extensions[PerMessageDeflate.extensionName];let opcode=options.binary?2:1;let rsv1=options.compress;let byteLength;let readOnly;if(typeof data==="string"){byteLength=Buffer.byteLength(data);readOnly=false}else{data=toBuffer(data);byteLength=data.length;readOnly=toBuffer.readOnly}if(this._firstFragment){this._firstFragment=false;if(rsv1&&perMessageDeflate&&perMessageDeflate.params[perMessageDeflate._isServer?"server_no_context_takeover":"client_no_context_takeover"]){rsv1=byteLength>=perMessageDeflate._threshold}this._compress=rsv1}else{rsv1=false;opcode=0}if(options.fin)this._firstFragment=true;if(perMessageDeflate){const opts={[kByteLength]:byteLength,fin:options.fin,generateMask:this._generateMask,mask:options.mask,maskBuffer:this._maskBuffer,opcode,readOnly,rsv1};if(this._deflating){this.enqueue([this.dispatch,data,this._compress,opts,cb])}else{this.dispatch(data,this._compress,opts,cb)}}else{this.sendFrame(_Sender.frame(data,{[kByteLength]:byteLength,fin:options.fin,generateMask:this._generateMask,mask:options.mask,maskBuffer:this._maskBuffer,opcode,readOnly,rsv1:false}),cb)}}dispatch(data,compress,options,cb){if(!compress){this.sendFrame(_Sender.frame(data,options),cb);return}const perMessageDeflate=this._extensions[PerMessageDeflate.extensionName];this._bufferedBytes+=options[kByteLength];this._deflating=true;perMessageDeflate.compress(data,options.fin,(_,buf)=>{if(this._socket.destroyed){const err=new Error("The socket was closed while data was being compressed");if(typeof cb==="function")cb(err);for(let i=0;i<this._queue.length;i++){const params=this._queue[i];const callback=params[params.length-1];if(typeof callback==="function")callback(err)}return}this._bufferedBytes-=options[kByteLength];this._deflating=false;options.readOnly=false;this.sendFrame(_Sender.frame(buf,options),cb);this.dequeue()})}dequeue(){while(!this._deflating&&this._queue.length){const params=this._queue.shift();this._bufferedBytes-=params[3][kByteLength];Reflect.apply(params[0],this,params.slice(1))}}enqueue(params){this._bufferedBytes+=params[3][kByteLength];this._queue.push(params)}sendFrame(list,cb){if(list.length===2){this._socket.cork();this._socket.write(list[0]);this._socket.write(list[1],cb);this._socket.uncork()}else{this._socket.write(list[0],cb)}}};module2.exports=Sender2}});var require_event_target=__commonJS({"node_modules/ws/lib/event-target.js"(exports2,module2){"use strict";var{kForOnEventAttribute,kListener}=require_constants();var kCode=Symbol("kCode");var kData=Symbol("kData");var kError=Symbol("kError");var kMessage=Symbol("kMessage");var kReason=Symbol("kReason");var kTarget=Symbol("kTarget");var kType=Symbol("kType");var kWasClean=Symbol("kWasClean");var Event=class{constructor(type){this[kTarget]=null;this[kType]=type}get target(){return this[kTarget]}get type(){return this[kType]}};Object.defineProperty(Event.prototype,"target",{enumerable:true});Object.defineProperty(Event.prototype,"type",{enumerable:true});var CloseEvent=class extends Event{constructor(type,options={}){super(type);this[kCode]=options.code===void 0?0:options.code;this[kReason]=options.reason===void 0?"":options.reason;this[kWasClean]=options.wasClean===void 0?false:options.wasClean}get code(){return this[kCode]}get reason(){return this[kReason]}get wasClean(){return this[kWasClean]}};Object.defineProperty(CloseEvent.prototype,"code",{enumerable:true});Object.defineProperty(CloseEvent.prototype,"reason",{enumerable:true});Object.defineProperty(CloseEvent.prototype,"wasClean",{enumerable:true});var ErrorEvent=class extends Event{constructor(type,options={}){super(type);this[kError]=options.error===void 0?null:options.error;this[kMessage]=options.message===void 0?"":options.message}get error(){return this[kError]}get message(){return this[kMessage]}};Object.defineProperty(ErrorEvent.prototype,"error",{enumerable:true});Object.defineProperty(ErrorEvent.prototype,"message",{enumerable:true});var MessageEvent=class extends Event{constructor(type,options={}){super(type);this[kData]=options.data===void 0?null:options.data}get data(){return this[kData]}};Object.defineProperty(MessageEvent.prototype,"data",{enumerable:true});var EventTarget={addEventListener(type,handler,options={}){for(const listener of this.listeners(type)){if(!options[kForOnEventAttribute]&&listener[kListener]===handler&&!listener[kForOnEventAttribute]){return}}let wrapper;if(type==="message"){wrapper=function onMessage(data,isBinary){const event=new MessageEvent("message",{data:isBinary?data:data.toString()});event[kTarget]=this;callListener(handler,this,event)}}else if(type==="close"){wrapper=function onClose(code,message){const event=new CloseEvent("close",{code,reason:message.toString(),wasClean:this._closeFrameReceived&&this._closeFrameSent});event[kTarget]=this;callListener(handler,this,event)}}else if(type==="error"){wrapper=function onError(error){const event=new ErrorEvent("error",{error,message:error.message});event[kTarget]=this;callListener(handler,this,event)}}else if(type==="open"){wrapper=function onOpen(){const event=new Event("open");event[kTarget]=this;callListener(handler,this,event)}}else{return}wrapper[kForOnEventAttribute]=!!options[kForOnEventAttribute];wrapper[kListener]=handler;if(options.once){this.once(type,wrapper)}else{this.on(type,wrapper)}},removeEventListener(type,handler){for(const listener of this.listeners(type)){if(listener[kListener]===handler&&!listener[kForOnEventAttribute]){this.removeListener(type,listener);break}}}};module2.exports={CloseEvent,ErrorEvent,Event,EventTarget,MessageEvent};function callListener(listener,thisArg,event){if(typeof listener==="object"&&listener.handleEvent){listener.handleEvent.call(listener,event)}else{listener.call(thisArg,event)}}}});var require_extension=__commonJS({"node_modules/ws/lib/extension.js"(exports2,module2){"use strict";var{tokenChars}=require_validation();function push(dest,name,elem){if(dest[name]===void 0)dest[name]=[elem];else dest[name].push(elem)}function parse(header){const offers=Object.create(null);let params=Object.create(null);let mustUnescape=false;let isEscaping=false;let inQuotes=false;let extensionName;let paramName;let start=-1;let code=-1;let end=-1;let i=0;for(;i<header.length;i++){code=header.charCodeAt(i);if(extensionName===void 0){if(end===-1&&tokenChars[code]===1){if(start===-1)start=i}else if(i!==0&&(code===32||code===9)){if(end===-1&&start!==-1)end=i}else if(code===59||code===44){if(start===-1){throw new SyntaxError(`Unexpected character at index ${i}`)}if(end===-1)end=i;const name=header.slice(start,end);if(code===44){push(offers,name,params);params=Object.create(null)}else{extensionName=name}start=end=-1}else{throw new SyntaxError(`Unexpected character at index ${i}`)}}else if(paramName===void 0){if(end===-1&&tokenChars[code]===1){if(start===-1)start=i}else if(code===32||code===9){if(end===-1&&start!==-1)end=i}else if(code===59||code===44){if(start===-1){throw new SyntaxError(`Unexpected character at index ${i}`)}if(end===-1)end=i;push(params,header.slice(start,end),true);if(code===44){push(offers,extensionName,params);params=Object.create(null);extensionName=void 0}start=end=-1}else if(code===61&&start!==-1&&end===-1){paramName=header.slice(start,i);start=end=-1}else{throw new SyntaxError(`Unexpected character at index ${i}`)}}else{if(isEscaping){if(tokenChars[code]!==1){throw new SyntaxError(`Unexpected character at index ${i}`)}if(start===-1)start=i;else if(!mustUnescape)mustUnescape=true;isEscaping=false}else if(inQuotes){if(tokenChars[code]===1){if(start===-1)start=i}else if(code===34&&start!==-1){inQuotes=false;end=i}else if(code===92){isEscaping=true}else{throw new SyntaxError(`Unexpected character at index ${i}`)}}else if(code===34&&header.charCodeAt(i-1)===61){inQuotes=true}else if(end===-1&&tokenChars[code]===1){if(start===-1)start=i}else if(start!==-1&&(code===32||code===9)){if(end===-1)end=i}else if(code===59||code===44){if(start===-1){throw new SyntaxError(`Unexpected character at index ${i}`)}if(end===-1)end=i;let value=header.slice(start,end);if(mustUnescape){value=value.replace(/\\/g,"");mustUnescape=false}push(params,paramName,value);if(code===44){push(offers,extensionName,params);params=Object.create(null);extensionName=void 0}paramName=void 0;start=end=-1}else{throw new SyntaxError(`Unexpected character at index ${i}`)}}}if(start===-1||inQuotes||code===32||code===9){throw new SyntaxError("Unexpected end of input")}if(end===-1)end=i;const token=header.slice(start,end);if(extensionName===void 0){push(offers,token,params)}else{if(paramName===void 0){push(params,token,true)}else if(mustUnescape){push(params,paramName,token.replace(/\\/g,""))}else{push(params,paramName,token)}push(offers,extensionName,params)}return offers}function format(extensions){return Object.keys(extensions).map(extension=>{let configurations=extensions[extension];if(!Array.isArray(configurations))configurations=[configurations];return configurations.map(params=>{return[extension].concat(Object.keys(params).map(k=>{let values=params[k];if(!Array.isArray(values))values=[values];return values.map(v=>v===true?k:`${k}=${v}`).join("; ")})).join("; ")}).join(", ")}).join(", ")}module2.exports={format,parse}}});var require_websocket=__commonJS({"node_modules/ws/lib/websocket.js"(exports2,module2){"use strict";var EventEmitter=require("events");var https2=require("https");var http2=require("http");var net=require("net");var tls=require("tls");var{randomBytes,createHash}=require("crypto");var{Duplex,Readable}=require("stream");var{URL:URL2}=require("url");var PerMessageDeflate=require_permessage_deflate();var Receiver2=require_receiver();var Sender2=require_sender();var{BINARY_TYPES,EMPTY_BUFFER,GUID,kForOnEventAttribute,kListener,kStatusCode,kWebSocket,NOOP}=require_constants();var{EventTarget:{addEventListener:addEventListener2,removeEventListener}}=require_event_target();var{format,parse}=require_extension();var{toBuffer}=require_buffer_util();var closeTimeout=30*1e3;var kAborted=Symbol("kAborted");var protocolVersions=[8,13];var readyStates=["CONNECTING","OPEN","CLOSING","CLOSED"];var subprotocolRegex=/^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;var WebSocket3=class _WebSocket extends EventEmitter{constructor(address,protocols,options){super();this._binaryType=BINARY_TYPES[0];this._closeCode=1006;this._closeFrameReceived=false;this._closeFrameSent=false;this._closeMessage=EMPTY_BUFFER;this._closeTimer=null;this._extensions={};this._paused=false;this._protocol="";this._readyState=_WebSocket.CONNECTING;this._receiver=null;this._sender=null;this._socket=null;if(address!==null){this._bufferedAmount=0;this._isServer=false;this._redirects=0;if(protocols===void 0){protocols=[]}else if(!Array.isArray(protocols)){if(typeof protocols==="object"&&protocols!==null){options=protocols;protocols=[]}else{protocols=[protocols]}}initAsClient(this,address,protocols,options)}else{this._autoPong=options.autoPong;this._isServer=true}}get binaryType(){return this._binaryType}set binaryType(type){if(!BINARY_TYPES.includes(type))return;this._binaryType=type;if(this._receiver)this._receiver._binaryType=type}get bufferedAmount(){if(!this._socket)return this._bufferedAmount;return this._socket._writableState.length+this._sender._bufferedBytes}get extensions(){return Object.keys(this._extensions).join()}get isPaused(){return this._paused}get onclose(){return null}get onerror(){return null}get onopen(){return null}get onmessage(){return null}get protocol(){return this._protocol}get readyState(){return this._readyState}get url(){return this._url}setSocket(socket,head,options){const receiver=new Receiver2({allowSynchronousEvents:options.allowSynchronousEvents,binaryType:this.binaryType,extensions:this._extensions,isServer:this._isServer,maxPayload:options.maxPayload,skipUTF8Validation:options.skipUTF8Validation});this._sender=new Sender2(socket,this._extensions,options.generateMask);this._receiver=receiver;this._socket=socket;receiver[kWebSocket]=this;socket[kWebSocket]=this;receiver.on("conclude",receiverOnConclude);receiver.on("drain",receiverOnDrain);receiver.on("error",receiverOnError);receiver.on("message",receiverOnMessage);receiver.on("ping",receiverOnPing);receiver.on("pong",receiverOnPong);if(socket.setTimeout)socket.setTimeout(0);if(socket.setNoDelay)socket.setNoDelay();if(head.length>0)socket.unshift(head);socket.on("close",socketOnClose);socket.on("data",socketOnData);socket.on("end",socketOnEnd);socket.on("error",socketOnError);this._readyState=_WebSocket.OPEN;this.emit("open")}emitClose(){if(!this._socket){this._readyState=_WebSocket.CLOSED;this.emit("close",this._closeCode,this._closeMessage);return}if(this._extensions[PerMessageDeflate.extensionName]){this._extensions[PerMessageDeflate.extensionName].cleanup()}this._receiver.removeAllListeners();this._readyState=_WebSocket.CLOSED;this.emit("close",this._closeCode,this._closeMessage)}close(code,data){if(this.readyState===_WebSocket.CLOSED)return;if(this.readyState===_WebSocket.CONNECTING){const msg="WebSocket was closed before the connection was established";abortHandshake(this,this._req,msg);return}if(this.readyState===_WebSocket.CLOSING){if(this._closeFrameSent&&(this._closeFrameReceived||this._receiver._writableState.errorEmitted)){this._socket.end()}return}this._readyState=_WebSocket.CLOSING;this._sender.close(code,data,!this._isServer,err=>{if(err)return;this._closeFrameSent=true;if(this._closeFrameReceived||this._receiver._writableState.errorEmitted){this._socket.end()}});this._closeTimer=setTimeout(this._socket.destroy.bind(this._socket),closeTimeout)}pause(){if(this.readyState===_WebSocket.CONNECTING||this.readyState===_WebSocket.CLOSED){return}this._paused=true;this._socket.pause()}ping(data,mask,cb){if(this.readyState===_WebSocket.CONNECTING){throw new Error("WebSocket is not open: readyState 0 (CONNECTING)")}if(typeof data==="function"){cb=data;data=mask=void 0}else if(typeof mask==="function"){cb=mask;mask=void 0}if(typeof data==="number")data=data.toString();if(this.readyState!==_WebSocket.OPEN){sendAfterClose(this,data,cb);return}if(mask===void 0)mask=!this._isServer;this._sender.ping(data||EMPTY_BUFFER,mask,cb)}pong(data,mask,cb){if(this.readyState===_WebSocket.CONNECTING){throw new Error("WebSocket is not open: readyState 0 (CONNECTING)")}if(typeof data==="function"){cb=data;data=mask=void 0}else if(typeof mask==="function"){cb=mask;mask=void 0}if(typeof data==="number")data=data.toString();if(this.readyState!==_WebSocket.OPEN){sendAfterClose(this,data,cb);return}if(mask===void 0)mask=!this._isServer;this._sender.pong(data||EMPTY_BUFFER,mask,cb)}resume(){if(this.readyState===_WebSocket.CONNECTING||this.readyState===_WebSocket.CLOSED){return}this._paused=false;if(!this._receiver._writableState.needDrain)this._socket.resume()}send(data,options,cb){if(this.readyState===_WebSocket.CONNECTING){throw new Error("WebSocket is not open: readyState 0 (CONNECTING)")}if(typeof options==="function"){cb=options;options={}}if(typeof data==="number")data=data.toString();if(this.readyState!==_WebSocket.OPEN){sendAfterClose(this,data,cb);return}const opts={binary:typeof data!=="string",mask:!this._isServer,compress:true,fin:true,...options};if(!this._extensions[PerMessageDeflate.extensionName]){opts.compress=false}this._sender.send(data||EMPTY_BUFFER,opts,cb)}terminate(){if(this.readyState===_WebSocket.CLOSED)return;if(this.readyState===_WebSocket.CONNECTING){const msg="WebSocket was closed before the connection was established";abortHandshake(this,this._req,msg);return}if(this._socket){this._readyState=_WebSocket.CLOSING;this._socket.destroy()}}};Object.defineProperty(WebSocket3,"CONNECTING",{enumerable:true,value:readyStates.indexOf("CONNECTING")});Object.defineProperty(WebSocket3.prototype,"CONNECTING",{enumerable:true,value:readyStates.indexOf("CONNECTING")});Object.defineProperty(WebSocket3,"OPEN",{enumerable:true,value:readyStates.indexOf("OPEN")});Object.defineProperty(WebSocket3.prototype,"OPEN",{enumerable:true,value:readyStates.indexOf("OPEN")});Object.defineProperty(WebSocket3,"CLOSING",{enumerable:true,value:readyStates.indexOf("CLOSING")});Object.defineProperty(WebSocket3.prototype,"CLOSING",{enumerable:true,value:readyStates.indexOf("CLOSING")});Object.defineProperty(WebSocket3,"CLOSED",{enumerable:true,value:readyStates.indexOf("CLOSED")});Object.defineProperty(WebSocket3.prototype,"CLOSED",{enumerable:true,value:readyStates.indexOf("CLOSED")});["binaryType","bufferedAmount","extensions","isPaused","protocol","readyState","url"].forEach(property=>{Object.defineProperty(WebSocket3.prototype,property,{enumerable:true})});["open","error","close","message"].forEach(method=>{Object.defineProperty(WebSocket3.prototype,`on${method}`,{enumerable:true,get(){for(const listener of this.listeners(method)){if(listener[kForOnEventAttribute])return listener[kListener]}return null},set(handler){for(const listener of this.listeners(method)){if(listener[kForOnEventAttribute]){this.removeListener(method,listener);break}}if(typeof handler!=="function")return;this.addEventListener(method,handler,{[kForOnEventAttribute]:true})}})});WebSocket3.prototype.addEventListener=addEventListener2;WebSocket3.prototype.removeEventListener=removeEventListener;module2.exports=WebSocket3;function initAsClient(websocket,address,protocols,options){const opts={allowSynchronousEvents:true,autoPong:true,protocolVersion:protocolVersions[1],maxPayload:100*1024*1024,skipUTF8Validation:false,perMessageDeflate:true,followRedirects:false,maxRedirects:10,...options,socketPath:void 0,hostname:void 0,protocol:void 0,timeout:void 0,method:"GET",host:void 0,path:void 0,port:void 0};websocket._autoPong=opts.autoPong;if(!protocolVersions.includes(opts.protocolVersion)){throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`)}let parsedUrl;if(address instanceof URL2){parsedUrl=address}else{try{parsedUrl=new URL2(address)}catch(e){throw new SyntaxError(`Invalid URL: ${address}`)}}if(parsedUrl.protocol==="http:"){parsedUrl.protocol="ws:"}else if(parsedUrl.protocol==="https:"){parsedUrl.protocol="wss:"}websocket._url=parsedUrl.href;const isSecure=parsedUrl.protocol==="wss:";const isIpcUrl=parsedUrl.protocol==="ws+unix:";let invalidUrlMessage;if(parsedUrl.protocol!=="ws:"&&!isSecure&&!isIpcUrl){invalidUrlMessage=`The URL's protocol must be one of "ws:", "wss:", "http:", "https", or "ws+unix:"`}else if(isIpcUrl&&!parsedUrl.pathname){invalidUrlMessage="The URL's pathname is empty"}else if(parsedUrl.hash){invalidUrlMessage="The URL contains a fragment identifier"}if(invalidUrlMessage){const err=new SyntaxError(invalidUrlMessage);if(websocket._redirects===0){throw err}else{emitErrorAndClose(websocket,err);return}}const defaultPort=isSecure?443:80;const key=randomBytes(16).toString("base64");const request=isSecure?https2.request:http2.request;const protocolSet=new Set;let perMessageDeflate;opts.createConnection=opts.createConnection||(isSecure?tlsConnect:netConnect);opts.defaultPort=opts.defaultPort||defaultPort;opts.port=parsedUrl.port||defaultPort;opts.host=parsedUrl.hostname.startsWith("[")?parsedUrl.hostname.slice(1,-1):parsedUrl.hostname;opts.headers={...opts.headers,"Sec-WebSocket-Version":opts.protocolVersion,"Sec-WebSocket-Key":key,Connection:"Upgrade",Upgrade:"websocket"};opts.path=parsedUrl.pathname+parsedUrl.search;opts.timeout=opts.handshakeTimeout;if(opts.perMessageDeflate){perMessageDeflate=new PerMessageDeflate(opts.perMessageDeflate!==true?opts.perMessageDeflate:{},false,opts.maxPayload);opts.headers["Sec-WebSocket-Extensions"]=format({[PerMessageDeflate.extensionName]:perMessageDeflate.offer()})}if(protocols.length){for(const protocol of protocols){if(typeof protocol!=="string"||!subprotocolRegex.test(protocol)||protocolSet.has(protocol)){throw new SyntaxError("An invalid or duplicated subprotocol was specified")}protocolSet.add(protocol)}opts.headers["Sec-WebSocket-Protocol"]=protocols.join(",")}if(opts.origin){if(opts.protocolVersion<13){opts.headers["Sec-WebSocket-Origin"]=opts.origin}else{opts.headers.Origin=opts.origin}}if(parsedUrl.username||parsedUrl.password){opts.auth=`${parsedUrl.username}:${parsedUrl.password}`}if(isIpcUrl){const parts=opts.path.split(":");opts.socketPath=parts[0];opts.path=parts[1]}let req;if(opts.followRedirects){if(websocket._redirects===0){websocket._originalIpc=isIpcUrl;websocket._originalSecure=isSecure;websocket._originalHostOrSocketPath=isIpcUrl?opts.socketPath:parsedUrl.host;const headers=options&&options.headers;options={...options,headers:{}};if(headers){for(const[key2,value]of Object.entries(headers)){options.headers[key2.toLowerCase()]=value}}}else if(websocket.listenerCount("redirect")===0){const isSameHost=isIpcUrl?websocket._originalIpc?opts.socketPath===websocket._originalHostOrSocketPath:false:websocket._originalIpc?false:parsedUrl.host===websocket._originalHostOrSocketPath;if(!isSameHost||websocket._originalSecure&&!isSecure){delete opts.headers.authorization;delete opts.headers.cookie;if(!isSameHost)delete opts.headers.host;opts.auth=void 0}}if(opts.auth&&!options.headers.authorization){options.headers.authorization="Basic "+Buffer.from(opts.auth).toString("base64")}req=websocket._req=request(opts);if(websocket._redirects){websocket.emit("redirect",websocket.url,req)}}else{req=websocket._req=request(opts)}if(opts.timeout){req.on("timeout",()=>{abortHandshake(websocket,req,"Opening handshake has timed out")})}req.on("error",err=>{if(req===null||req[kAborted])return;req=websocket._req=null;emitErrorAndClose(websocket,err)});req.on("response",res=>{const location2=res.headers.location;const statusCode=res.statusCode;if(location2&&opts.followRedirects&&statusCode>=300&&statusCode<400){if(++websocket._redirects>opts.maxRedirects){abortHandshake(websocket,req,"Maximum redirects exceeded");return}req.abort();let addr;try{addr=new URL2(location2,address)}catch(e){const err=new SyntaxError(`Invalid URL: ${location2}`);emitErrorAndClose(websocket,err);return}initAsClient(websocket,addr,protocols,options)}else if(!websocket.emit("unexpected-response",req,res)){abortHandshake(websocket,req,`Unexpected server response: ${res.statusCode}`)}});req.on("upgrade",(res,socket,head)=>{websocket.emit("upgrade",res);if(websocket.readyState!==WebSocket3.CONNECTING)return;req=websocket._req=null;const upgrade=res.headers.upgrade;if(upgrade===void 0||upgrade.toLowerCase()!=="websocket"){abortHandshake(websocket,socket,"Invalid Upgrade header");return}const digest=createHash("sha1").update(key+GUID).digest("base64");if(res.headers["sec-websocket-accept"]!==digest){abortHandshake(websocket,socket,"Invalid Sec-WebSocket-Accept header");return}const serverProt=res.headers["sec-websocket-protocol"];let protError;if(serverProt!==void 0){if(!protocolSet.size){protError="Server sent a subprotocol but none was requested"}else if(!protocolSet.has(serverProt)){protError="Server sent an invalid subprotocol"}}else if(protocolSet.size){protError="Server sent no subprotocol"}if(protError){abortHandshake(websocket,socket,protError);return}if(serverProt)websocket._protocol=serverProt;const secWebSocketExtensions=res.headers["sec-websocket-extensions"];if(secWebSocketExtensions!==void 0){if(!perMessageDeflate){const message="Server sent a Sec-WebSocket-Extensions header but no extension was requested";abortHandshake(websocket,socket,message);return}let extensions;try{extensions=parse(secWebSocketExtensions)}catch(err){const message="Invalid Sec-WebSocket-Extensions header";abortHandshake(websocket,socket,message);return}const extensionNames=Object.keys(extensions);if(extensionNames.length!==1||extensionNames[0]!==PerMessageDeflate.extensionName){const message="Server indicated an extension that was not requested";abortHandshake(websocket,socket,message);return}try{perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName])}catch(err){const message="Invalid Sec-WebSocket-Extensions header";abortHandshake(websocket,socket,message);return}websocket._extensions[PerMessageDeflate.extensionName]=perMessageDeflate}websocket.setSocket(socket,head,{allowSynchronousEvents:opts.allowSynchronousEvents,generateMask:opts.generateMask,maxPayload:opts.maxPayload,skipUTF8Validation:opts.skipUTF8Validation})});if(opts.finishRequest){opts.finishRequest(req,websocket)}else{req.end()}}function emitErrorAndClose(websocket,err){websocket._readyState=WebSocket3.CLOSING;websocket.emit("error",err);websocket.emitClose()}function netConnect(options){options.path=options.socketPath;return net.connect(options)}function tlsConnect(options){options.path=void 0;if(!options.servername&&options.servername!==""){options.servername=net.isIP(options.host)?"":options.host}return tls.connect(options)}function abortHandshake(websocket,stream,message){websocket._readyState=WebSocket3.CLOSING;const err=new Error(message);Error.captureStackTrace(err,abortHandshake);if(stream.setHeader){stream[kAborted]=true;stream.abort();if(stream.socket&&!stream.socket.destroyed){stream.socket.destroy()}process.nextTick(emitErrorAndClose,websocket,err)}else{stream.destroy(err);stream.once("error",websocket.emit.bind(websocket,"error"));stream.once("close",websocket.emitClose.bind(websocket))}}function sendAfterClose(websocket,data,cb){if(data){const length=toBuffer(data).length;if(websocket._socket)websocket._sender._bufferedBytes+=length;else websocket._bufferedAmount+=length}if(cb){const err=new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);process.nextTick(cb,err)}}function receiverOnConclude(code,reason){const websocket=this[kWebSocket];websocket._closeFrameReceived=true;websocket._closeMessage=reason;websocket._closeCode=code;if(websocket._socket[kWebSocket]===void 0)return;websocket._socket.removeListener("data",socketOnData);process.nextTick(resume,websocket._socket);if(code===1005)websocket.close();else websocket.close(code,reason)}function receiverOnDrain(){const websocket=this[kWebSocket];if(!websocket.isPaused)websocket._socket.resume()}function receiverOnError(err){const websocket=this[kWebSocket];if(websocket._socket[kWebSocket]!==void 0){websocket._socket.removeListener("data",socketOnData);process.nextTick(resume,websocket._socket);websocket.close(err[kStatusCode])}websocket.emit("error",err)}function receiverOnFinish(){this[kWebSocket].emitClose()}function receiverOnMessage(data,isBinary){this[kWebSocket].emit("message",data,isBinary)}function receiverOnPing(data){const websocket=this[kWebSocket];if(websocket._autoPong)websocket.pong(data,!this._isServer,NOOP);websocket.emit("ping",data)}function receiverOnPong(data){this[kWebSocket].emit("pong",data)}function resume(stream){stream.resume()}function socketOnClose(){const websocket=this[kWebSocket];this.removeListener("close",socketOnClose);this.removeListener("data",socketOnData);this.removeListener("end",socketOnEnd);websocket._readyState=WebSocket3.CLOSING;let chunk;if(!this._readableState.endEmitted&&!websocket._closeFrameReceived&&!websocket._receiver._writableState.errorEmitted&&(chunk=websocket._socket.read())!==null){websocket._receiver.write(chunk)}websocket._receiver.end();this[kWebSocket]=void 0;clearTimeout(websocket._closeTimer);if(websocket._receiver._writableState.finished||websocket._receiver._writableState.errorEmitted){websocket.emitClose()}else{websocket._receiver.on("error",receiverOnFinish);websocket._receiver.on("finish",receiverOnFinish)}}function socketOnData(chunk){if(!this[kWebSocket]._receiver.write(chunk)){this.pause()}}function socketOnEnd(){const websocket=this[kWebSocket];websocket._readyState=WebSocket3.CLOSING;websocket._receiver.end();this.end()}function socketOnError(){const websocket=this[kWebSocket];this.removeListener("error",socketOnError);this.on("error",NOOP);if(websocket){websocket._readyState=WebSocket3.CLOSING;this.destroy()}}}});var require_subprotocol=__commonJS({"node_modules/ws/lib/subprotocol.js"(exports2,module2){"use strict";var{tokenChars}=require_validation();function parse(header){const protocols=new Set;let start=-1;let end=-1;let i=0;for(i;i<header.length;i++){const code=header.charCodeAt(i);if(end===-1&&tokenChars[code]===1){if(start===-1)start=i}else if(i!==0&&(code===32||code===9)){if(end===-1&&start!==-1)end=i}else if(code===44){if(start===-1){throw new SyntaxError(`Unexpected character at index ${i}`)}if(end===-1)end=i;const protocol2=header.slice(start,end);if(protocols.has(protocol2)){throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`)}protocols.add(protocol2);start=end=-1}else{throw new SyntaxError(`Unexpected character at index ${i}`)}}if(start===-1||end!==-1){throw new SyntaxError("Unexpected end of input")}const protocol=header.slice(start,i);if(protocols.has(protocol)){throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`)}protocols.add(protocol);return protocols}module2.exports={parse}}});var require_websocket_server=__commonJS({"node_modules/ws/lib/websocket-server.js"(exports2,module2){"use strict";var EventEmitter=require("events");var http2=require("http");var{Duplex}=require("stream");var{createHash}=require("crypto");var extension=require_extension();var PerMessageDeflate=require_permessage_deflate();var subprotocol=require_subprotocol();var WebSocket3=require_websocket();var{GUID,kWebSocket}=require_constants();var keyRegex=/^[+/0-9A-Za-z]{22}==$/;var RUNNING=0;var CLOSING=1;var CLOSED=2;var WebSocketServer2=class extends EventEmitter{constructor(options,callback){super();options={allowSynchronousEvents:true,autoPong:true,maxPayload:100*1024*1024,skipUTF8Validation:false,perMessageDeflate:false,handleProtocols:null,clientTracking:true,verifyClient:null,noServer:false,backlog:null,server:null,host:null,path:null,port:null,WebSocket:WebSocket3,...options};if(options.port==null&&!options.server&&!options.noServer||options.port!=null&&(options.server||options.noServer)||options.server&&options.noServer){throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified')}if(options.port!=null){this._server=http2.createServer((req,res)=>{const body=http2.STATUS_CODES[426];res.writeHead(426,{"Content-Length":body.length,"Content-Type":"text/plain"});res.end(body)});this._server.listen(options.port,options.host,options.backlog,callback)}else if(options.server){this._server=options.server}if(this._server){const emitConnection=this.emit.bind(this,"connection");this._removeListeners=addListeners(this._server,{listening:this.emit.bind(this,"listening"),error:this.emit.bind(this,"error"),upgrade:(req,socket,head)=>{this.handleUpgrade(req,socket,head,emitConnection)}})}if(options.perMessageDeflate===true)options.perMessageDeflate={};if(options.clientTracking){this.clients=new Set;this._shouldEmitClose=false}this.options=options;this._state=RUNNING}address(){if(this.options.noServer){throw new Error('The server is operating in "noServer" mode')}if(!this._server)return null;return this._server.address()}close(cb){if(this._state===CLOSED){if(cb){this.once("close",()=>{cb(new Error("The server is not running"))})}process.nextTick(emitClose,this);return}if(cb)this.once("close",cb);if(this._state===CLOSING)return;this._state=CLOSING;if(this.options.noServer||this.options.server){if(this._server){this._removeListeners();this._removeListeners=this._server=null}if(this.clients){if(!this.clients.size){process.nextTick(emitClose,this)}else{this._shouldEmitClose=true}}else{process.nextTick(emitClose,this)}}else{const server=this._server;this._removeListeners();this._removeListeners=this._server=null;server.close(()=>{emitClose(this)})}}shouldHandle(req){if(this.options.path){const index=req.url.indexOf("?");const pathname=index!==-1?req.url.slice(0,index):req.url;if(pathname!==this.options.path)return false}return true}handleUpgrade(req,socket,head,cb){socket.on("error",socketOnError);const key=req.headers["sec-websocket-key"];const upgrade=req.headers.upgrade;const version=+req.headers["sec-websocket-version"];if(req.method!=="GET"){const message="Invalid HTTP method";abortHandshakeOrEmitwsClientError(this,req,socket,405,message);return}if(upgrade===void 0||upgrade.toLowerCase()!=="websocket"){const message="Invalid Upgrade header";abortHandshakeOrEmitwsClientError(this,req,socket,400,message);return}if(key===void 0||!keyRegex.test(key)){const message="Missing or invalid Sec-WebSocket-Key header";abortHandshakeOrEmitwsClientError(this,req,socket,400,message);return}if(version!==8&&version!==13){const message="Missing or invalid Sec-WebSocket-Version header";abortHandshakeOrEmitwsClientError(this,req,socket,400,message);return}if(!this.shouldHandle(req)){abortHandshake(socket,400);return}const secWebSocketProtocol=req.headers["sec-websocket-protocol"];let protocols=new Set;if(secWebSocketProtocol!==void 0){try{protocols=subprotocol.parse(secWebSocketProtocol)}catch(err){const message="Invalid Sec-WebSocket-Protocol header";abortHandshakeOrEmitwsClientError(this,req,socket,400,message);return}}const secWebSocketExtensions=req.headers["sec-websocket-extensions"];const extensions={};if(this.options.perMessageDeflate&&secWebSocketExtensions!==void 0){const perMessageDeflate=new PerMessageDeflate(this.options.perMessageDeflate,true,this.options.maxPayload);try{const offers=extension.parse(secWebSocketExtensions);if(offers[PerMessageDeflate.extensionName]){perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);extensions[PerMessageDeflate.extensionName]=perMessageDeflate}}catch(err){const message="Invalid or unacceptable Sec-WebSocket-Extensions header";abortHandshakeOrEmitwsClientError(this,req,socket,400,message);return}}if(this.options.verifyClient){const info={origin:req.headers[`${version===8?"sec-websocket-origin":"origin"}`],secure:!!(req.socket.authorized||req.socket.encrypted),req};if(this.options.verifyClient.length===2){this.options.verifyClient(info,(verified,code,message,headers)=>{if(!verified){return abortHandshake(socket,code||401,message,headers)}this.completeUpgrade(extensions,key,protocols,req,socket,head,cb)});return}if(!this.options.verifyClient(info))return abortHandshake(socket,401)}this.completeUpgrade(extensions,key,protocols,req,socket,head,cb)}completeUpgrade(extensions,key,protocols,req,socket,head,cb){if(!socket.readable||!socket.writable)return socket.destroy();if(socket[kWebSocket]){throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration")}if(this._state>RUNNING)return abortHandshake(socket,503);const digest=createHash("sha1").update(key+GUID).digest("base64");const headers=["HTTP/1.1 101 Switching Protocols","Upgrade: websocket","Connection: Upgrade",`Sec-WebSocket-Accept: ${digest}`];const ws=new this.options.WebSocket(null,void 0,this.options);if(protocols.size){const protocol=this.options.handleProtocols?this.options.handleProtocols(protocols,req):protocols.values().next().value;if(protocol){headers.push(`Sec-WebSocket-Protocol: ${protocol}`);ws._protocol=protocol}}if(extensions[PerMessageDeflate.extensionName]){const params=extensions[PerMessageDeflate.extensionName].params;const value=extension.format({[PerMessageDeflate.extensionName]:[params]});headers.push(`Sec-WebSocket-Extensions: ${value}`);ws._extensions=extensions}this.emit("headers",headers,req);socket.write(headers.concat("\r\n").join("\r\n"));socket.removeListener("error",socketOnError);ws.setSocket(socket,head,{allowSynchronousEvents:this.options.allowSynchronousEvents,maxPayload:this.options.maxPayload,skipUTF8Validation:this.options.skipUTF8Validation});if(this.clients){this.clients.add(ws);ws.on("close",()=>{this.clients.delete(ws);if(this._shouldEmitClose&&!this.clients.size){process.nextTick(emitClose,this)}})}cb(ws,req)}};module2.exports=WebSocketServer2;function addListeners(server,map){for(const event of Object.keys(map))server.on(event,map[event]);return function removeListeners(){for(const event of Object.keys(map)){server.removeListener(event,map[event])}}}function emitClose(server){server._state=CLOSED;server.emit("close")}function socketOnError(){this.destroy()}function abortHandshake(socket,code,message,headers){message=message||http2.STATUS_CODES[code];headers={Connection:"close","Content-Type":"text/html","Content-Length":Buffer.byteLength(message),...headers};socket.once("finish",socket.destroy);socket.end(`HTTP/1.1 ${code} ${http2.STATUS_CODES[code]}\r
`+Object.keys(headers).map(h=>`${h}: ${headers[h]}`).join("\r\n")+"\r\n\r\n"+message)}function abortHandshakeOrEmitwsClientError(server,req,socket,code,message){if(server.listenerCount("wsClientError")){const err=new Error(message);Error.captureStackTrace(err,abortHandshakeOrEmitwsClientError);server.emit("wsClientError",err,socket,req)}else{abortHandshake(socket,code,message)}}}});var require_bson=__commonJS({"src/graphscript-database/datastructures/bson.cjs"(exports2){"use strict";var BSON_MAJOR_VERSION=5;var BSON_INT32_MAX=2147483647;var BSON_INT32_MIN=-2147483648;var BSON_INT64_MAX=Math.pow(2,63)-1;var BSON_INT64_MIN=-Math.pow(2,63);var JS_INT_MAX=Math.pow(2,53);var JS_INT_MIN=-Math.pow(2,53);var BSON_DATA_NUMBER=1;var BSON_DATA_STRING=2;var BSON_DATA_OBJECT=3;var BSON_DATA_ARRAY=4;var BSON_DATA_BINARY=5;var BSON_DATA_UNDEFINED=6;var BSON_DATA_OID=7;var BSON_DATA_BOOLEAN=8;var BSON_DATA_DATE=9;var BSON_DATA_NULL=10;var BSON_DATA_REGEXP=11;var BSON_DATA_DBPOINTER=12;var BSON_DATA_CODE=13;var BSON_DATA_SYMBOL=14;var BSON_DATA_CODE_W_SCOPE=15;var BSON_DATA_INT=16;var BSON_DATA_TIMESTAMP=17;var BSON_DATA_LONG=18;var BSON_DATA_DECIMAL128=19;var BSON_DATA_MIN_KEY=255;var BSON_DATA_MAX_KEY=127;var BSON_BINARY_SUBTYPE_DEFAULT=0;var BSON_BINARY_SUBTYPE_UUID_NEW=4;var BSONType=Object.freeze({double:1,string:2,object:3,array:4,binData:5,undefined:6,objectId:7,bool:8,date:9,null:10,regex:11,dbPointer:12,javascript:13,symbol:14,javascriptWithScope:15,int:16,timestamp:17,long:18,decimal:19,minKey:-1,maxKey:127});var BSONError=class extends Error{get bsonError(){return true}get name(){return"BSONError"}constructor(message){super(message)}static isBSONError(value){return value!=null&&typeof value==="object"&&"bsonError"in value&&value.bsonError===true&&"name"in value&&"message"in value&&"stack"in value}};var BSONVersionError=class extends BSONError{get name(){return"BSONVersionError"}constructor(){super(`Unsupported BSON version, bson types must be from bson ${BSON_MAJOR_VERSION}.0 or later`)}};var BSONRuntimeError=class extends BSONError{get name(){return"BSONRuntimeError"}constructor(message){super(message)}};function nodejsMathRandomBytes(byteLength){return nodeJsByteUtils.fromNumberArray(Array.from({length:byteLength},()=>Math.floor(Math.random()*256)))}var nodejsRandomBytes=(()=>{try{return require("crypto").randomBytes}catch{return nodejsMathRandomBytes}})();var nodeJsByteUtils={toLocalBufferType(potentialBuffer){if(Buffer.isBuffer(potentialBuffer)){return potentialBuffer}if(ArrayBuffer.isView(potentialBuffer)){return Buffer.from(potentialBuffer.buffer,potentialBuffer.byteOffset,potentialBuffer.byteLength)}const stringTag=potentialBuffer?.[Symbol.toStringTag]??Object.prototype.toString.call(potentialBuffer);if(stringTag==="ArrayBuffer"||stringTag==="SharedArrayBuffer"||stringTag==="[object ArrayBuffer]"||stringTag==="[object SharedArrayBuffer]"){return Buffer.from(potentialBuffer)}throw new BSONError(`Cannot create Buffer from ${String(potentialBuffer)}`)},allocate(size){return Buffer.alloc(size)},equals(a,b){return nodeJsByteUtils.toLocalBufferType(a).equals(b)},fromNumberArray(array){return Buffer.from(array)},fromBase64(base64){return Buffer.from(base64,"base64")},toBase64(buffer2){return nodeJsByteUtils.toLocalBufferType(buffer2).toString("base64")},fromISO88591(codePoints){return Buffer.from(codePoints,"binary")},toISO88591(buffer2){return nodeJsByteUtils.toLocalBufferType(buffer2).toString("binary")},fromHex(hex){return Buffer.from(hex,"hex")},toHex(buffer2){return nodeJsByteUtils.toLocalBufferType(buffer2).toString("hex")},fromUTF8(text){return Buffer.from(text,"utf8")},toUTF8(buffer2){return nodeJsByteUtils.toLocalBufferType(buffer2).toString("utf8")},utf8ByteLength(input){return Buffer.byteLength(input,"utf8")},encodeUTF8Into(buffer2,source,byteOffset){return nodeJsByteUtils.toLocalBufferType(buffer2).write(source,byteOffset,void 0,"utf8")},randomBytes:nodejsRandomBytes};function isReactNative(){const{navigator:navigator2}=globalThis;return typeof navigator2==="object"&&navigator2.product==="ReactNative"}function webMathRandomBytes(byteLength){if(byteLength<0){throw new RangeError(`The argument 'byteLength' is invalid. Received ${byteLength}`)}return webByteUtils.fromNumberArray(Array.from({length:byteLength},()=>Math.floor(Math.random()*256)))}var webRandomBytes=(()=>{const{crypto}=globalThis;if(crypto!=null&&typeof crypto.getRandomValues==="function"){return byteLength=>{return crypto.getRandomValues(webByteUtils.allocate(byteLength))}}else{if(isReactNative()){const{console:console2}=globalThis;console2?.warn?.("BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.")}return webMathRandomBytes}})();var HEX_DIGIT=/(\d|[a-f])/i;var webByteUtils={toLocalBufferType(potentialUint8array){const stringTag=potentialUint8array?.[Symbol.toStringTag]??Object.prototype.toString.call(potentialUint8array);if(stringTag==="Uint8Array"){return potentialUint8array}if(ArrayBuffer.isView(potentialUint8array)){return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset,potentialUint8array.byteOffset+potentialUint8array.byteLength))}if(stringTag==="ArrayBuffer"||stringTag==="SharedArrayBuffer"||stringTag==="[object ArrayBuffer]"||stringTag==="[object SharedArrayBuffer]"){return new Uint8Array(potentialUint8array)}throw new BSONError(`Cannot make a Uint8Array from ${String(potentialUint8array)}`)},allocate(size){if(typeof size!=="number"){throw new TypeError(`The "size" argument must be of type number. Received ${String(size)}`)}return new Uint8Array(size)},equals(a,b){if(a.byteLength!==b.byteLength){return false}for(let i=0;i<a.byteLength;i++){if(a[i]!==b[i]){return false}}return true},fromNumberArray(array){return Uint8Array.from(array)},fromBase64(base64){return Uint8Array.from(atob(base64),c=>c.charCodeAt(0))},toBase64(uint8array){return btoa(webByteUtils.toISO88591(uint8array))},fromISO88591(codePoints){return Uint8Array.from(codePoints,c=>c.charCodeAt(0)&255)},toISO88591(uint8array){return Array.from(Uint16Array.from(uint8array),b=>String.fromCharCode(b)).join("")},fromHex(hex){const evenLengthHex=hex.length%2===0?hex:hex.slice(0,hex.length-1);const buffer2=[];for(let i=0;i<evenLengthHex.length;i+=2){const firstDigit=evenLengthHex[i];const secondDigit=evenLengthHex[i+1];if(!HEX_DIGIT.test(firstDigit)){break}if(!HEX_DIGIT.test(secondDigit)){break}const hexDigit=Number.parseInt(`${firstDigit}${secondDigit}`,16);buffer2.push(hexDigit)}return Uint8Array.from(buffer2)},toHex(uint8array){return Array.from(uint8array,byte=>byte.toString(16).padStart(2,"0")).join("")},fromUTF8(text){return new TextEncoder().encode(text)},toUTF8(uint8array){return new TextDecoder("utf8",{fatal:false}).decode(uint8array)},utf8ByteLength(input){return webByteUtils.fromUTF8(input).byteLength},encodeUTF8Into(buffer2,source,byteOffset){const bytes=webByteUtils.fromUTF8(source);buffer2.set(bytes,byteOffset);return bytes.byteLength},randomBytes:webRandomBytes};var hasGlobalBuffer=typeof Buffer==="function"&&Buffer.prototype?._isBuffer!==true;var ByteUtils=hasGlobalBuffer?nodeJsByteUtils:webByteUtils;var BSONDataView=class extends DataView{static fromUint8Array(input){return new DataView(input.buffer,input.byteOffset,input.byteLength)}};var VALIDATION_REGEX=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|[0-9a-f]{12}4[0-9a-f]{3}[89ab][0-9a-f]{15})$/i;var uuidValidateString=str=>typeof str==="string"&&VALIDATION_REGEX.test(str);var uuidHexStringToBuffer=hexString=>{if(!uuidValidateString(hexString)){throw new BSONError('UUID string representations must be a 32 or 36 character hex string (dashes excluded/included). Format: "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" or "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".')}const sanitizedHexString=hexString.replace(/-/g,"");return ByteUtils.fromHex(sanitizedHexString)};function bufferToUuidHexString(buffer2,includeDashes=true){if(includeDashes){return[ByteUtils.toHex(buffer2.subarray(0,4)),ByteUtils.toHex(buffer2.subarray(4,6)),ByteUtils.toHex(buffer2.subarray(6,8)),ByteUtils.toHex(buffer2.subarray(8,10)),ByteUtils.toHex(buffer2.subarray(10,16))].join("-")}return ByteUtils.toHex(buffer2)}function isAnyArrayBuffer(value){return["[object ArrayBuffer]","[object SharedArrayBuffer]"].includes(Object.prototype.toString.call(value))}function isUint8Array(value){return Object.prototype.toString.call(value)==="[object Uint8Array]"}function isRegExp(d){return Object.prototype.toString.call(d)==="[object RegExp]"}function isMap(d){return Object.prototype.toString.call(d)==="[object Map]"}function isDate(d){return Object.prototype.toString.call(d)==="[object Date]"}var BSONValue=class{get[Symbol.for("@@mdb.bson.version")](){return BSON_MAJOR_VERSION}};var Binary=class _Binary extends BSONValue{get _bsontype(){return"Binary"}constructor(buffer2,subType){super();if(!(buffer2==null)&&!(typeof buffer2==="string")&&!ArrayBuffer.isView(buffer2)&&!(buffer2 instanceof ArrayBuffer)&&!Array.isArray(buffer2)){throw new BSONError("Binary can only be constructed from string, Buffer, TypedArray, or Array<number>")}this.sub_type=subType??_Binary.BSON_BINARY_SUBTYPE_DEFAULT;if(buffer2==null){this.buffer=ByteUtils.allocate(_Binary.BUFFER_SIZE);this.position=0}else{if(typeof buffer2==="string"){this.buffer=ByteUtils.fromISO88591(buffer2)}else if(Array.isArray(buffer2)){this.buffer=ByteUtils.fromNumberArray(buffer2)}else{this.buffer=ByteUtils.toLocalBufferType(buffer2)}this.position=this.buffer.byteLength}}put(byteValue){if(typeof byteValue==="string"&&byteValue.length!==1){throw new BSONError("only accepts single character String")}else if(typeof byteValue!=="number"&&byteValue.length!==1)throw new BSONError("only accepts single character Uint8Array or Array");let decodedByte;if(typeof byteValue==="string"){decodedByte=byteValue.charCodeAt(0)}else if(typeof byteValue==="number"){decodedByte=byteValue}else{decodedByte=byteValue[0]}if(decodedByte<0||decodedByte>255){throw new BSONError("only accepts number in a valid unsigned byte range 0-255")}if(this.buffer.byteLength>this.position){this.buffer[this.position++]=decodedByte}else{const newSpace=ByteUtils.allocate(_Binary.BUFFER_SIZE+this.buffer.length);newSpace.set(this.buffer,0);this.buffer=newSpace;this.buffer[this.position++]=decodedByte}}write(sequence,offset){offset=typeof offset==="number"?offset:this.position;if(this.buffer.byteLength<offset+sequence.length){const newSpace=ByteUtils.allocate(this.buffer.byteLength+sequence.length);newSpace.set(this.buffer,0);this.buffer=newSpace}if(ArrayBuffer.isView(sequence)){this.buffer.set(ByteUtils.toLocalBufferType(sequence),offset);this.position=offset+sequence.byteLength>this.position?offset+sequence.length:this.position}else if(typeof sequence==="string"){const bytes=ByteUtils.fromISO88591(sequence);this.buffer.set(bytes,offset);this.position=offset+sequence.length>this.position?offset+sequence.length:this.position}}read(position,length){length=length&&length>0?length:this.position;return this.buffer.slice(position,position+length)}value(asRaw){asRaw=!!asRaw;if(asRaw&&this.buffer.length===this.position){return this.buffer}if(asRaw){return this.buffer.slice(0,this.position)}return ByteUtils.toISO88591(this.buffer.subarray(0,this.position))}length(){return this.position}toJSON(){return ByteUtils.toBase64(this.buffer)}toString(encoding){if(encoding==="hex")return ByteUtils.toHex(this.buffer);if(encoding==="base64")return ByteUtils.toBase64(this.buffer);if(encoding==="utf8"||encoding==="utf-8")return ByteUtils.toUTF8(this.buffer);return ByteUtils.toUTF8(this.buffer)}toExtendedJSON(options){options=options||{};const base64String=ByteUtils.toBase64(this.buffer);const subType=Number(this.sub_type).toString(16);if(options.legacy){return{$binary:base64String,$type:subType.length===1?"0"+subType:subType}}return{$binary:{base64:base64String,subType:subType.length===1?"0"+subType:subType}}}toUUID(){if(this.sub_type===_Binary.SUBTYPE_UUID){return new UUID(this.buffer.slice(0,this.position))}throw new BSONError(`Binary sub_type "${this.sub_type}" is not supported for converting to UUID. Only "${_Binary.SUBTYPE_UUID}" is currently supported.`)}static fromExtendedJSON(doc,options){options=options||{};let data;let type;if("$binary"in doc){if(options.legacy&&typeof doc.$binary==="string"&&"$type"in doc){type=doc.$type?parseInt(doc.$type,16):0;data=ByteUtils.fromBase64(doc.$binary)}else{if(typeof doc.$binary!=="string"){type=doc.$binary.subType?parseInt(doc.$binary.subType,16):0;data=ByteUtils.fromBase64(doc.$binary.base64)}}}else if("$uuid"in doc){type=4;data=uuidHexStringToBuffer(doc.$uuid)}if(!data){throw new BSONError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`)}return type===BSON_BINARY_SUBTYPE_UUID_NEW?new UUID(data):new _Binary(data,type)}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){return`new Binary(Buffer.from("${ByteUtils.toHex(this.buffer)}", "hex"), ${this.sub_type})`}};Binary.BSON_BINARY_SUBTYPE_DEFAULT=0;Binary.BUFFER_SIZE=256;Binary.SUBTYPE_DEFAULT=0;Binary.SUBTYPE_FUNCTION=1;Binary.SUBTYPE_BYTE_ARRAY=2;Binary.SUBTYPE_UUID_OLD=3;Binary.SUBTYPE_UUID=4;Binary.SUBTYPE_MD5=5;Binary.SUBTYPE_ENCRYPTED=6;Binary.SUBTYPE_COLUMN=7;Binary.SUBTYPE_USER_DEFINED=128;var UUID_BYTE_LENGTH=16;var UUID=class _UUID extends Binary{constructor(input){let bytes;let hexStr;if(input==null){bytes=_UUID.generate()}else if(input instanceof _UUID){bytes=ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));hexStr=input.__id}else if(ArrayBuffer.isView(input)&&input.byteLength===UUID_BYTE_LENGTH){bytes=ByteUtils.toLocalBufferType(input)}else if(typeof input==="string"){bytes=uuidHexStringToBuffer(input)}else{throw new BSONError("Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).")}super(bytes,BSON_BINARY_SUBTYPE_UUID_NEW);this.__id=hexStr}get id(){return this.buffer}set id(value){this.buffer=value;if(_UUID.cacheHexString){this.__id=bufferToUuidHexString(value)}}toHexString(includeDashes=true){if(_UUID.cacheHexString&&this.__id){return this.__id}const uuidHexString=bufferToUuidHexString(this.id,includeDashes);if(_UUID.cacheHexString){this.__id=uuidHexString}return uuidHexString}toString(encoding){if(encoding==="hex")return ByteUtils.toHex(this.id);if(encoding==="base64")return ByteUtils.toBase64(this.id);return this.toHexString()}toJSON(){return this.toHexString()}equals(otherId){if(!otherId){return false}if(otherId instanceof _UUID){return ByteUtils.equals(otherId.id,this.id)}try{return ByteUtils.equals(new _UUID(otherId).id,this.id)}catch{return false}}toBinary(){return new Binary(this.id,Binary.SUBTYPE_UUID)}static generate(){const bytes=ByteUtils.randomBytes(UUID_BYTE_LENGTH);bytes[6]=bytes[6]&15|64;bytes[8]=bytes[8]&63|128;return bytes}static isValid(input){if(!input){return false}if(input instanceof _UUID){return true}if(typeof input==="string"){return uuidValidateString(input)}if(isUint8Array(input)){if(input.byteLength!==UUID_BYTE_LENGTH){return false}return(input[6]&240)===64&&(input[8]&128)===128}return false}static createFromHexString(hexString){const buffer2=uuidHexStringToBuffer(hexString);return new _UUID(buffer2)}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){return`new UUID("${this.toHexString()}")`}};var Code=class _Code extends BSONValue{get _bsontype(){return"Code"}constructor(code,scope){super();this.code=code.toString();this.scope=scope??null}toJSON(){if(this.scope!=null){return{code:this.code,scope:this.scope}}return{code:this.code}}toExtendedJSON(){if(this.scope){return{$code:this.code,$scope:this.scope}}return{$code:this.code}}static fromExtendedJSON(doc){return new _Code(doc.$code,doc.$scope)}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){const codeJson=this.toJSON();return`new Code("${String(codeJson.code)}"${codeJson.scope!=null?`, ${JSON.stringify(codeJson.scope)}`:""})`}};function isDBRefLike(value){return value!=null&&typeof value==="object"&&"$id"in value&&value.$id!=null&&"$ref"in value&&typeof value.$ref==="string"&&(!("$db"in value)||"$db"in value&&typeof value.$db==="string")}var DBRef=class _DBRef extends BSONValue{get _bsontype(){return"DBRef"}constructor(collection,oid,db,fields){super();const parts=collection.split(".");if(parts.length===2){db=parts.shift();collection=parts.shift()}this.collection=collection;this.oid=oid;this.db=db;this.fields=fields||{}}get namespace(){return this.collection}set namespace(value){this.collection=value}toJSON(){const o=Object.assign({$ref:this.collection,$id:this.oid},this.fields);if(this.db!=null)o.$db=this.db;return o}toExtendedJSON(options){options=options||{};let o={$ref:this.collection,$id:this.oid};if(options.legacy){return o}if(this.db)o.$db=this.db;o=Object.assign(o,this.fields);return o}static fromExtendedJSON(doc){const copy=Object.assign({},doc);delete copy.$ref;delete copy.$id;delete copy.$db;return new _DBRef(doc.$ref,doc.$id,doc.$db,copy)}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){const oid=this.oid===void 0||this.oid.toString===void 0?this.oid:this.oid.toString();return`new DBRef("${this.namespace}", new ObjectId("${String(oid)}")${this.db?`, "${this.db}"`:""})`}};var wasm=void 0;try{wasm=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}var TWO_PWR_16_DBL=1<<16;var TWO_PWR_24_DBL=1<<24;var TWO_PWR_32_DBL=TWO_PWR_16_DBL*TWO_PWR_16_DBL;var TWO_PWR_64_DBL=TWO_PWR_32_DBL*TWO_PWR_32_DBL;var TWO_PWR_63_DBL=TWO_PWR_64_DBL/2;var INT_CACHE={};var UINT_CACHE={};var MAX_INT64_STRING_LENGTH=20;var DECIMAL_REG_EX=/^(\+?0|(\+|-)?[1-9][0-9]*)$/;var Long=class _Long extends BSONValue{get _bsontype(){return"Long"}get __isLong__(){return true}constructor(low=0,high,unsigned){super();if(typeof low==="bigint"){Object.assign(this,_Long.fromBigInt(low,!!high))}else if(typeof low==="string"){Object.assign(this,_Long.fromString(low,!!high))}else{this.low=low|0;this.high=high|0;this.unsigned=!!unsigned}}static fromBits(lowBits,highBits,unsigned){return new _Long(lowBits,highBits,unsigned)}static fromInt(value,unsigned){let obj,cachedObj,cache;if(unsigned){value>>>=0;if(cache=0<=value&&value<256){cachedObj=UINT_CACHE[value];if(cachedObj)return cachedObj}obj=_Long.fromBits(value,(value|0)<0?-1:0,true);if(cache)UINT_CACHE[value]=obj;return obj}else{value|=0;if(cache=-128<=value&&value<128){cachedObj=INT_CACHE[value];if(cachedObj)return cachedObj}obj=_Long.fromBits(value,value<0?-1:0,false);if(cache)INT_CACHE[value]=obj;return obj}}static fromNumber(value,unsigned){if(isNaN(value))return unsigned?_Long.UZERO:_Long.ZERO;if(unsigned){if(value<0)return _Long.UZERO;if(value>=TWO_PWR_64_DBL)return _Long.MAX_UNSIGNED_VALUE}else{if(value<=-TWO_PWR_63_DBL)return _Long.MIN_VALUE;if(value+1>=TWO_PWR_63_DBL)return _Long.MAX_VALUE}if(value<0)return _Long.fromNumber(-value,unsigned).neg();return _Long.fromBits(value%TWO_PWR_32_DBL|0,value/TWO_PWR_32_DBL|0,unsigned)}static fromBigInt(value,unsigned){return _Long.fromString(value.toString(),unsigned)}static fromString(str,unsigned,radix){if(str.length===0)throw new BSONError("empty string");if(str==="NaN"||str==="Infinity"||str==="+Infinity"||str==="-Infinity")return _Long.ZERO;if(typeof unsigned==="number"){radix=unsigned,unsigned=false}else{unsigned=!!unsigned}radix=radix||10;if(radix<2||36<radix)throw new BSONError("radix");let p;if((p=str.indexOf("-"))>0)throw new BSONError("interior hyphen");else if(p===0){return _Long.fromString(str.substring(1),unsigned,radix).neg()}const radixToPower=_Long.fromNumber(Math.pow(radix,8));let result=_Long.ZERO;for(let i=0;i<str.length;i+=8){const size=Math.min(8,str.length-i),value=parseInt(str.substring(i,i+size),radix);if(size<8){const power=_Long.fromNumber(Math.pow(radix,size));result=result.mul(power).add(_Long.fromNumber(value))}else{result=result.mul(radixToPower);result=result.add(_Long.fromNumber(value))}}result.unsigned=unsigned;return result}static fromBytes(bytes,unsigned,le){return le?_Long.fromBytesLE(bytes,unsigned):_Long.fromBytesBE(bytes,unsigned)}static fromBytesLE(bytes,unsigned){return new _Long(bytes[0]|bytes[1]<<8|bytes[2]<<16|bytes[3]<<24,bytes[4]|bytes[5]<<8|bytes[6]<<16|bytes[7]<<24,unsigned)}static fromBytesBE(bytes,unsigned){return new _Long(bytes[4]<<24|bytes[5]<<16|bytes[6]<<8|bytes[7],bytes[0]<<24|bytes[1]<<16|bytes[2]<<8|bytes[3],unsigned)}static isLong(value){return value!=null&&typeof value==="object"&&"__isLong__"in value&&value.__isLong__===true}static fromValue(val,unsigned){if(typeof val==="number")return _Long.fromNumber(val,unsigned);if(typeof val==="string")return _Long.fromString(val,unsigned);return _Long.fromBits(val.low,val.high,typeof unsigned==="boolean"?unsigned:val.unsigned)}add(addend){if(!_Long.isLong(addend))addend=_Long.fromValue(addend);const a48=this.high>>>16;const a32=this.high&65535;const a16=this.low>>>16;const a00=this.low&65535;const b48=addend.high>>>16;const b32=addend.high&65535;const b16=addend.low>>>16;const b00=addend.low&65535;let c48=0,c32=0,c16=0,c00=0;c00+=a00+b00;c16+=c00>>>16;c00&=65535;c16+=a16+b16;c32+=c16>>>16;c16&=65535;c32+=a32+b32;c48+=c32>>>16;c32&=65535;c48+=a48+b48;c48&=65535;return _Long.fromBits(c16<<16|c00,c48<<16|c32,this.unsigned)}and(other){if(!_Long.isLong(other))other=_Long.fromValue(other);return _Long.fromBits(this.low&other.low,this.high&other.high,this.unsigned)}compare(other){if(!_Long.isLong(other))other=_Long.fromValue(other);if(this.eq(other))return 0;const thisNeg=this.isNegative(),otherNeg=other.isNegative();if(thisNeg&&!otherNeg)return-1;if(!thisNeg&&otherNeg)return 1;if(!this.unsigned)return this.sub(other).isNegative()?-1:1;return other.high>>>0>this.high>>>0||other.high===this.high&&other.low>>>0>this.low>>>0?-1:1}comp(other){return this.compare(other)}divide(divisor){if(!_Long.isLong(divisor))divisor=_Long.fromValue(divisor);if(divisor.isZero())throw new BSONError("division by zero");if(wasm){if(!this.unsigned&&this.high===-2147483648&&divisor.low===-1&&divisor.high===-1){return this}const low=(this.unsigned?wasm.div_u:wasm.div_s)(this.low,this.high,divisor.low,divisor.high);return _Long.fromBits(low,wasm.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?_Long.UZERO:_Long.ZERO;let approx,rem,res;if(!this.unsigned){if(this.eq(_Long.MIN_VALUE)){if(divisor.eq(_Long.ONE)||divisor.eq(_Long.NEG_ONE))return _Long.MIN_VALUE;else if(divisor.eq(_Long.MIN_VALUE))return _Long.ONE;else{const halfThis=this.shr(1);approx=halfThis.div(divisor).shl(1);if(approx.eq(_Long.ZERO)){return divisor.isNegative()?_Long.ONE:_Long.NEG_ONE}else{rem=this.sub(divisor.mul(approx));res=approx.add(rem.div(divisor));return res}}}else if(divisor.eq(_Long.MIN_VALUE))return this.unsigned?_Long.UZERO:_Long.ZERO;if(this.isNegative()){if(divisor.isNegative())return this.neg().div(divisor.neg());return this.neg().div(divisor).neg()}else if(divisor.isNegative())return this.div(divisor.neg()).neg();res=_Long.ZERO}else{if(!divisor.unsigned)divisor=divisor.toUnsigned();if(divisor.gt(this))return _Long.UZERO;if(divisor.gt(this.shru(1)))return _Long.UONE;res=_Long.UZERO}rem=this;while(rem.gte(divisor)){approx=Math.max(1,Math.floor(rem.toNumber()/divisor.toNumber()));const log2=Math.ceil(Math.log(approx)/Math.LN2);const delta=log2<=48?1:Math.pow(2,log2-48);let approxRes=_Long.fromNumber(approx);let approxRem=approxRes.mul(divisor);while(approxRem.isNegative()||approxRem.gt(rem)){approx-=delta;approxRes=_Long.fromNumber(approx,this.unsigned);approxRem=approxRes.mul(divisor)}if(approxRes.isZero())approxRes=_Long.ONE;res=res.add(approxRes);rem=rem.sub(approxRem)}return res}div(divisor){return this.divide(divisor)}equals(other){if(!_Long.isLong(other))other=_Long.fromValue(other);if(this.unsigned!==other.unsigned&&this.high>>>31===1&&other.high>>>31===1)return false;return this.high===other.high&&this.low===other.low}eq(other){return this.equals(other)}getHighBits(){return this.high}getHighBitsUnsigned(){return this.high>>>0}getLowBits(){return this.low}getLowBitsUnsigned(){return this.low>>>0}getNumBitsAbs(){if(this.isNegative()){return this.eq(_Long.MIN_VALUE)?64:this.neg().getNumBitsAbs()}const val=this.high!==0?this.high:this.low;let bit;for(bit=31;bit>0;bit--)if((val&1<<bit)!==0)break;return this.high!==0?bit+33:bit+1}greaterThan(other){return this.comp(other)>0}gt(other){return this.greaterThan(other)}greaterThanOrEqual(other){return this.comp(other)>=0}gte(other){return this.greaterThanOrEqual(other)}ge(other){return this.greaterThanOrEqual(other)}isEven(){return(this.low&1)===0}isNegative(){return!this.unsigned&&this.high<0}isOdd(){return(this.low&1)===1}isPositive(){return this.unsigned||this.high>=0}isZero(){return this.high===0&&this.low===0}lessThan(other){return this.comp(other)<0}lt(other){return this.lessThan(other)}lessThanOrEqual(other){return this.comp(other)<=0}lte(other){return this.lessThanOrEqual(other)}modulo(divisor){if(!_Long.isLong(divisor))divisor=_Long.fromValue(divisor);if(wasm){const low=(this.unsigned?wasm.rem_u:wasm.rem_s)(this.low,this.high,divisor.low,divisor.high);return _Long.fromBits(low,wasm.get_high(),this.unsigned)}return this.sub(this.div(divisor).mul(divisor))}mod(divisor){return this.modulo(divisor)}rem(divisor){return this.modulo(divisor)}multiply(multiplier){if(this.isZero())return _Long.ZERO;if(!_Long.isLong(multiplier))multiplier=_Long.fromValue(multiplier);if(wasm){const low=wasm.mul(this.low,this.high,multiplier.low,multiplier.high);return _Long.fromBits(low,wasm.get_high(),this.unsigned)}if(multiplier.isZero())return _Long.ZERO;if(this.eq(_Long.MIN_VALUE))return multiplier.isOdd()?_Long.MIN_VALUE:_Long.ZERO;if(multiplier.eq(_Long.MIN_VALUE))return this.isOdd()?_Long.MIN_VALUE:_Long.ZERO;if(this.isNegative()){if(multiplier.isNegative())return this.neg().mul(multiplier.neg());else return this.neg().mul(multiplier).neg()}else if(multiplier.isNegative())return this.mul(multiplier.neg()).neg();if(this.lt(_Long.TWO_PWR_24)&&multiplier.lt(_Long.TWO_PWR_24))return _Long.fromNumber(this.toNumber()*multiplier.toNumber(),this.unsigned);const a48=this.high>>>16;const a32=this.high&65535;const a16=this.low>>>16;const a00=this.low&65535;const b48=multiplier.high>>>16;const b32=multiplier.high&65535;const b16=multiplier.low>>>16;const b00=multiplier.low&65535;let c48=0,c32=0,c16=0,c00=0;c00+=a00*b00;c16+=c00>>>16;c00&=65535;c16+=a16*b00;c32+=c16>>>16;c16&=65535;c16+=a00*b16;c32+=c16>>>16;c16&=65535;c32+=a32*b00;c48+=c32>>>16;c32&=65535;c32+=a16*b16;c48+=c32>>>16;c32&=65535;c32+=a00*b32;c48+=c32>>>16;c32&=65535;c48+=a48*b00+a32*b16+a16*b32+a00*b48;c48&=65535;return _Long.fromBits(c16<<16|c00,c48<<16|c32,this.unsigned)}mul(multiplier){return this.multiply(multiplier)}negate(){if(!this.unsigned&&this.eq(_Long.MIN_VALUE))return _Long.MIN_VALUE;return this.not().add(_Long.ONE)}neg(){return this.negate()}not(){return _Long.fromBits(~this.low,~this.high,this.unsigned)}notEquals(other){return!this.equals(other)}neq(other){return this.notEquals(other)}ne(other){return this.notEquals(other)}or(other){if(!_Long.isLong(other))other=_Long.fromValue(other);return _Long.fromBits(this.low|other.low,this.high|other.high,this.unsigned)}shiftLeft(numBits){if(_Long.isLong(numBits))numBits=numBits.toInt();if((numBits&=63)===0)return this;else if(numBits<32)return _Long.fromBits(this.low<<numBits,this.high<<numBits|this.low>>>32-numBits,this.unsigned);else return _Long.fromBits(0,this.low<<numBits-32,this.unsigned)}shl(numBits){return this.shiftLeft(numBits)}shiftRight(numBits){if(_Long.isLong(numBits))numBits=numBits.toInt();if((numBits&=63)===0)return this;else if(numBits<32)return _Long.fromBits(this.low>>>numBits|this.high<<32-numBits,this.high>>numBits,this.unsigned);else return _Long.fromBits(this.high>>numBits-32,this.high>=0?0:-1,this.unsigned)}shr(numBits){return this.shiftRight(numBits)}shiftRightUnsigned(numBits){if(_Long.isLong(numBits))numBits=numBits.toInt();numBits&=63;if(numBits===0)return this;else{const high=this.high;if(numBits<32){const low=this.low;return _Long.fromBits(low>>>numBits|high<<32-numBits,high>>>numBits,this.unsigned)}else if(numBits===32)return _Long.fromBits(high,0,this.unsigned);else return _Long.fromBits(high>>>numBits-32,0,this.unsigned)}}shr_u(numBits){return this.shiftRightUnsigned(numBits)}shru(numBits){return this.shiftRightUnsigned(numBits)}subtract(subtrahend){if(!_Long.isLong(subtrahend))subtrahend=_Long.fromValue(subtrahend);return this.add(subtrahend.neg())}sub(subtrahend){return this.subtract(subtrahend)}toInt(){return this.unsigned?this.low>>>0:this.low}toNumber(){if(this.unsigned)return(this.high>>>0)*TWO_PWR_32_DBL+(this.low>>>0);return this.high*TWO_PWR_32_DBL+(this.low>>>0)}toBigInt(){return BigInt(this.toString())}toBytes(le){return le?this.toBytesLE():this.toBytesBE()}toBytesLE(){const hi=this.high,lo=this.low;return[lo&255,lo>>>8&255,lo>>>16&255,lo>>>24,hi&255,hi>>>8&255,hi>>>16&255,hi>>>24]}toBytesBE(){const hi=this.high,lo=this.low;return[hi>>>24,hi>>>16&255,hi>>>8&255,hi&255,lo>>>24,lo>>>16&255,lo>>>8&255,lo&255]}toSigned(){if(!this.unsigned)return this;return _Long.fromBits(this.low,this.high,false)}toString(radix){radix=radix||10;if(radix<2||36<radix)throw new BSONError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(_Long.MIN_VALUE)){const radixLong=_Long.fromNumber(radix),div=this.div(radixLong),rem1=div.mul(radixLong).sub(this);return div.toString(radix)+rem1.toInt().toString(radix)}else return"-"+this.neg().toString(radix)}const radixToPower=_Long.fromNumber(Math.pow(radix,6),this.unsigned);let rem=this;let result="";while(true){const remDiv=rem.div(radixToPower);const intval=rem.sub(remDiv.mul(radixToPower)).toInt()>>>0;let digits=intval.toString(radix);rem=remDiv;if(rem.isZero()){return digits+result}else{while(digits.length<6)digits="0"+digits;result=""+digits+result}}}toUnsigned(){if(this.unsigned)return this;return _Long.fromBits(this.low,this.high,true)}xor(other){if(!_Long.isLong(other))other=_Long.fromValue(other);return _Long.fromBits(this.low^other.low,this.high^other.high,this.unsigned)}eqz(){return this.isZero()}le(other){return this.lessThanOrEqual(other)}toExtendedJSON(options){if(options&&options.relaxed)return this.toNumber();return{$numberLong:this.toString()}}static fromExtendedJSON(doc,options){const{useBigInt64=false,relaxed=true}={...options};if(doc.$numberLong.length>MAX_INT64_STRING_LENGTH){throw new BSONError("$numberLong string is too long")}if(!DECIMAL_REG_EX.test(doc.$numberLong)){throw new BSONError(`$numberLong string "${doc.$numberLong}" is in an invalid format`)}if(useBigInt64){const bigIntResult=BigInt(doc.$numberLong);return BigInt.asIntN(64,bigIntResult)}const longResult=_Long.fromString(doc.$numberLong);if(relaxed){return longResult.toNumber()}return longResult}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){return`new Long("${this.toString()}"${this.unsigned?", true":""})`}};Long.TWO_PWR_24=Long.fromInt(TWO_PWR_24_DBL);Long.MAX_UNSIGNED_VALUE=Long.fromBits(4294967295|0,4294967295|0,true);Long.ZERO=Long.fromInt(0);Long.UZERO=Long.fromInt(0,true);Long.ONE=Long.fromInt(1);Long.UONE=Long.fromInt(1,true);Long.NEG_ONE=Long.fromInt(-1);Long.MAX_VALUE=Long.fromBits(4294967295|0,2147483647|0,false);Long.MIN_VALUE=Long.fromBits(0,2147483648|0,false);var PARSE_STRING_REGEXP=/^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/;var PARSE_INF_REGEXP=/^(\+|-)?(Infinity|inf)$/i;var PARSE_NAN_REGEXP=/^(\+|-)?NaN$/i;var EXPONENT_MAX=6111;var EXPONENT_MIN=-6176;var EXPONENT_BIAS=6176;var MAX_DIGITS=34;var NAN_BUFFER=ByteUtils.fromNumberArray([124,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0].reverse());var INF_NEGATIVE_BUFFER=ByteUtils.fromNumberArray([248,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0].reverse());var INF_POSITIVE_BUFFER=ByteUtils.fromNumberArray([120,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0].reverse());var EXPONENT_REGEX=/^([-+])?(\d+)?$/;var COMBINATION_MASK=31;var EXPONENT_MASK=16383;var COMBINATION_INFINITY=30;var COMBINATION_NAN=31;function isDigit(value){return!isNaN(parseInt(value,10))}function divideu128(value){const DIVISOR=Long.fromNumber(1e3*1e3*1e3);let _rem=Long.fromNumber(0);if(!value.parts[0]&&!value.parts[1]&&!value.parts[2]&&!value.parts[3]){return{quotient:value,rem:_rem}}for(let i=0;i<=3;i++){_rem=_rem.shiftLeft(32);_rem=_rem.add(new Long(value.parts[i],0));value.parts[i]=_rem.div(DIVISOR).low;_rem=_rem.modulo(DIVISOR)}return{quotient:value,rem:_rem}}function multiply64x2(left,right){if(!left&&!right){return{high:Long.fromNumber(0),low:Long.fromNumber(0)}}const leftHigh=left.shiftRightUnsigned(32);const leftLow=new Long(left.getLowBits(),0);const rightHigh=right.shiftRightUnsigned(32);const rightLow=new Long(right.getLowBits(),0);let productHigh=leftHigh.multiply(rightHigh);let productMid=leftHigh.multiply(rightLow);const productMid2=leftLow.multiply(rightHigh);let productLow=leftLow.multiply(rightLow);productHigh=productHigh.add(productMid.shiftRightUnsigned(32));productMid=new Long(productMid.getLowBits(),0).add(productMid2).add(productLow.shiftRightUnsigned(32));productHigh=productHigh.add(productMid.shiftRightUnsigned(32));productLow=productMid.shiftLeft(32).add(new Long(productLow.getLowBits(),0));return{high:productHigh,low:productLow}}function lessThan(left,right){const uhleft=left.high>>>0;const uhright=right.high>>>0;if(uhleft<uhright){return true}else if(uhleft===uhright){const ulleft=left.low>>>0;const ulright=right.low>>>0;if(ulleft<ulright)return true}return false}function invalidErr(string,message){throw new BSONError(`"${string}" is not a valid Decimal128 string - ${message}`)}var Decimal128=class _Decimal128 extends BSONValue{get _bsontype(){return"Decimal128"}constructor(bytes){super();if(typeof bytes==="string"){this.bytes=_Decimal128.fromString(bytes).bytes}else if(isUint8Array(bytes)){if(bytes.byteLength!==16){throw new BSONError("Decimal128 must take a Buffer of 16 bytes")}this.bytes=bytes}else{throw new BSONError("Decimal128 must take a Buffer or string")}}static fromString(representation){let isNegative=false;let sawRadix=false;let foundNonZero=false;let significantDigits=0;let nDigitsRead=0;let nDigits=0;let radixPosition=0;let firstNonZero=0;const digits=[0];let nDigitsStored=0;let digitsInsert=0;let firstDigit=0;let lastDigit=0;let exponent=0;let i=0;let significandHigh=new Long(0,0);let significandLow=new Long(0,0);let biasedExponent=0;let index=0;if(representation.length>=7e3){throw new BSONError(""+representation+" not a valid Decimal128 string")}const stringMatch=representation.match(PARSE_STRING_REGEXP);const infMatch=representation.match(PARSE_INF_REGEXP);const nanMatch=representation.match(PARSE_NAN_REGEXP);if(!stringMatch&&!infMatch&&!nanMatch||representation.length===0){throw new BSONError(""+representation+" not a valid Decimal128 string")}if(stringMatch){const unsignedNumber=stringMatch[2];const e=stringMatch[4];const expSign=stringMatch[5];const expNumber=stringMatch[6];if(e&&expNumber===void 0)invalidErr(representation,"missing exponent power");if(e&&unsignedNumber===void 0)invalidErr(representation,"missing exponent base");if(e===void 0&&(expSign||expNumber)){invalidErr(representation,"missing e before exponent")}}if(representation[index]==="+"||representation[index]==="-"){isNegative=representation[index++]==="-"}if(!isDigit(representation[index])&&representation[index]!=="."){if(representation[index]==="i"||representation[index]==="I"){return new _Decimal128(isNegative?INF_NEGATIVE_BUFFER:INF_POSITIVE_BUFFER)}else if(representation[index]==="N"){return new _Decimal128(NAN_BUFFER)}}while(isDigit(representation[index])||representation[index]==="."){if(representation[index]==="."){if(sawRadix)invalidErr(representation,"contains multiple periods");sawRadix=true;index=index+1;continue}if(nDigitsStored<34){if(representation[index]!=="0"||foundNonZero){if(!foundNonZero){firstNonZero=nDigitsRead}foundNonZero=true;digits[digitsInsert++]=parseInt(representation[index],10);nDigitsStored=nDigitsStored+1}}if(foundNonZero)nDigits=nDigits+1;if(sawRadix)radixPosition=radixPosition+1;nDigitsRead=nDigitsRead+1;index=index+1}if(sawRadix&&!nDigitsRead)throw new BSONError(""+representation+" not a valid Decimal128 string");if(representation[index]==="e"||representation[index]==="E"){const match=representation.substr(++index).match(EXPONENT_REGEX);if(!match||!match[2])return new _Decimal128(NAN_BUFFER);exponent=parseInt(match[0],10);index=index+match[0].length}if(representation[index])return new _Decimal128(NAN_BUFFER);firstDigit=0;if(!nDigitsStored){firstDigit=0;lastDigit=0;digits[0]=0;nDigits=1;nDigitsStored=1;significantDigits=0}else{lastDigit=nDigitsStored-1;significantDigits=nDigits;if(significantDigits!==1){while(digits[firstNonZero+significantDigits-1]===0){significantDigits=significantDigits-1}}}if(exponent<=radixPosition&&radixPosition-exponent>1<<14){exponent=EXPONENT_MIN}else{exponent=exponent-radixPosition}while(exponent>EXPONENT_MAX){lastDigit=lastDigit+1;if(lastDigit-firstDigit>MAX_DIGITS){const digitsString=digits.join("");if(digitsString.match(/^0+$/)){exponent=EXPONENT_MAX;break}invalidErr(representation,"overflow")}exponent=exponent-1}while(exponent<EXPONENT_MIN||nDigitsStored<nDigits){if(lastDigit===0&&significantDigits<nDigitsStored){exponent=EXPONENT_MIN;significantDigits=0;break}if(nDigitsStored<nDigits){nDigits=nDigits-1}else{lastDigit=lastDigit-1}if(exponent<EXPONENT_MAX){exponent=exponent+1}else{const digitsString=digits.join("");if(digitsString.match(/^0+$/)){exponent=EXPONENT_MAX;break}invalidErr(representation,"overflow")}}if(lastDigit-firstDigit+1<significantDigits){let endOfString=nDigitsRead;if(sawRadix){firstNonZero=firstNonZero+1;endOfString=endOfString+1}if(isNegative){firstNonZero=firstNonZero+1;endOfString=endOfString+1}const roundDigit=parseInt(representation[firstNonZero+lastDigit+1],10);let roundBit=0;if(roundDigit>=5){roundBit=1;if(roundDigit===5){roundBit=digits[lastDigit]%2===1?1:0;for(i=firstNonZero+lastDigit+2;i<endOfString;i++){if(parseInt(representation[i],10)){roundBit=1;break}}}}if(roundBit){let dIdx=lastDigit;for(;dIdx>=0;dIdx--){if(++digits[dIdx]>9){digits[dIdx]=0;if(dIdx===0){if(exponent<EXPONENT_MAX){exponent=exponent+1;digits[dIdx]=1}else{return new _Decimal128(isNegative?INF_NEGATIVE_BUFFER:INF_POSITIVE_BUFFER)}}}}}}significandHigh=Long.fromNumber(0);significandLow=Long.fromNumber(0);if(significantDigits===0){significandHigh=Long.fromNumber(0);significandLow=Long.fromNumber(0)}else if(lastDigit-firstDigit<17){let dIdx=firstDigit;significandLow=Long.fromNumber(digits[dIdx++]);significandHigh=new Long(0,0);for(;dIdx<=lastDigit;dIdx++){significandLow=significandLow.multiply(Long.fromNumber(10));significandLow=significandLow.add(Long.fromNumber(digits[dIdx]))}}else{let dIdx=firstDigit;significandHigh=Long.fromNumber(digits[dIdx++]);for(;dIdx<=lastDigit-17;dIdx++){significandHigh=significandHigh.multiply(Long.fromNumber(10));significandHigh=significandHigh.add(Long.fromNumber(digits[dIdx]))}significandLow=Long.fromNumber(digits[dIdx++]);for(;dIdx<=lastDigit;dIdx++){significandLow=significandLow.multiply(Long.fromNumber(10));significandLow=significandLow.add(Long.fromNumber(digits[dIdx]))}}const significand=multiply64x2(significandHigh,Long.fromString("100000000000000000"));significand.low=significand.low.add(significandLow);if(lessThan(significand.low,significandLow)){significand.high=significand.high.add(Long.fromNumber(1))}biasedExponent=exponent+EXPONENT_BIAS;const dec={low:Long.fromNumber(0),high:Long.fromNumber(0)};if(significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))){dec.high=dec.high.or(Long.fromNumber(3).shiftLeft(61));dec.high=dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(16383).shiftLeft(47)));dec.high=dec.high.or(significand.high.and(Long.fromNumber(0x7fffffffffff)))}else{dec.high=dec.high.or(Long.fromNumber(biasedExponent&16383).shiftLeft(49));dec.high=dec.high.or(significand.high.and(Long.fromNumber(562949953421311)))}dec.low=significand.low;if(isNegative){dec.high=dec.high.or(Long.fromString("9223372036854775808"))}const buffer2=ByteUtils.allocate(16);index=0;buffer2[index++]=dec.low.low&255;buffer2[index++]=dec.low.low>>8&255;buffer2[index++]=dec.low.low>>16&255;buffer2[index++]=dec.low.low>>24&255;buffer2[index++]=dec.low.high&255;buffer2[index++]=dec.low.high>>8&255;buffer2[index++]=dec.low.high>>16&255;buffer2[index++]=dec.low.high>>24&255;buffer2[index++]=dec.high.low&255;buffer2[index++]=dec.high.low>>8&255;buffer2[index++]=dec.high.low>>16&255;buffer2[index++]=dec.high.low>>24&255;buffer2[index++]=dec.high.high&255;buffer2[index++]=dec.high.high>>8&255;buffer2[index++]=dec.high.high>>16&255;buffer2[index++]=dec.high.high>>24&255;return new _Decimal128(buffer2)}toString(){let biased_exponent;let significand_digits=0;const significand=new Array(36);for(let i=0;i<significand.length;i++)significand[i]=0;let index=0;let is_zero=false;let significand_msb;let significand128={parts:[0,0,0,0]};let j,k;const string=[];index=0;const buffer2=this.bytes;const low=buffer2[index++]|buffer2[index++]<<8|buffer2[index++]<<16|buffer2[index++]<<24;const midl=buffer2[index++]|buffer2[index++]<<8|buffer2[index++]<<16|buffer2[index++]<<24;const midh=buffer2[index++]|buffer2[index++]<<8|buffer2[index++]<<16|buffer2[index++]<<24;const high=buffer2[index++]|buffer2[index++]<<8|buffer2[index++]<<16|buffer2[index++]<<24;index=0;const dec={low:new Long(low,midl),high:new Long(midh,high)};if(dec.high.lessThan(Long.ZERO)){string.push("-")}const combination=high>>26&COMBINATION_MASK;if(combination>>3===3){if(combination===COMBINATION_INFINITY){return string.join("")+"Infinity"}else if(combination===COMBINATION_NAN){return"NaN"}else{biased_exponent=high>>15&EXPONENT_MASK;significand_msb=8+(high>>14&1)}}else{significand_msb=high>>14&7;biased_exponent=high>>17&EXPONENT_MASK}const exponent=biased_exponent-EXPONENT_BIAS;significand128.parts[0]=(high&16383)+((significand_msb&15)<<14);significand128.parts[1]=midh;significand128.parts[2]=midl;significand128.parts[3]=low;if(significand128.parts[0]===0&&significand128.parts[1]===0&&significand128.parts[2]===0&&significand128.parts[3]===0){is_zero=true}else{for(k=3;k>=0;k--){let least_digits=0;const result=divideu128(significand128);significand128=result.quotient;least_digits=result.rem.low;if(!least_digits)continue;for(j=8;j>=0;j--){significand[k*9+j]=least_digits%10;least_digits=Math.floor(least_digits/10)}}}if(is_zero){significand_digits=1;significand[index]=0}else{significand_digits=36;while(!significand[index]){significand_digits=significand_digits-1;index=index+1}}const scientific_exponent=significand_digits-1+exponent;if(scientific_exponent>=34||scientific_exponent<=-7||exponent>0){if(significand_digits>34){string.push(`${0}`);if(exponent>0)string.push(`E+${exponent}`);else if(exponent<0)string.push(`E${exponent}`);return string.join("")}string.push(`${significand[index++]}`);significand_digits=significand_digits-1;if(significand_digits){string.push(".")}for(let i=0;i<significand_digits;i++){string.push(`${significand[index++]}`)}string.push("E");if(scientific_exponent>0){string.push(`+${scientific_exponent}`)}else{string.push(`${scientific_exponent}`)}}else{if(exponent>=0){for(let i=0;i<significand_digits;i++){string.push(`${significand[index++]}`)}}else{let radix_position=significand_digits+exponent;if(radix_position>0){for(let i=0;i<radix_position;i++){string.push(`${significand[index++]}`)}}else{string.push("0")}string.push(".");while(radix_position++<0){string.push("0")}for(let i=0;i<significand_digits-Math.max(radix_position-1,0);i++){string.push(`${significand[index++]}`)}}}return string.join("")}toJSON(){return{$numberDecimal:this.toString()}}toExtendedJSON(){return{$numberDecimal:this.toString()}}static fromExtendedJSON(doc){return _Decimal128.fromString(doc.$numberDecimal)}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){return`new Decimal128("${this.toString()}")`}};var Double=class _Double extends BSONValue{get _bsontype(){return"Double"}constructor(value){super();if(value instanceof Number){value=value.valueOf()}this.value=+value}valueOf(){return this.value}toJSON(){return this.value}toString(radix){return this.value.toString(radix)}toExtendedJSON(options){if(options&&(options.legacy||options.relaxed&&isFinite(this.value))){return this.value}if(Object.is(Math.sign(this.value),-0)){return{$numberDouble:"-0.0"}}return{$numberDouble:Number.isInteger(this.value)?this.value.toFixed(1):this.value.toString()}}static fromExtendedJSON(doc,options){const doubleValue=parseFloat(doc.$numberDouble);return options&&options.relaxed?doubleValue:new _Double(doubleValue)}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){const eJSON=this.toExtendedJSON();return`new Double(${eJSON.$numberDouble})`}};var Int32=class _Int32 extends BSONValue{get _bsontype(){return"Int32"}constructor(value){super();if(value instanceof Number){value=value.valueOf()}this.value=+value|0}valueOf(){return this.value}toString(radix){return this.value.toString(radix)}toJSON(){return this.value}toExtendedJSON(options){if(options&&(options.relaxed||options.legacy))return this.value;return{$numberInt:this.value.toString()}}static fromExtendedJSON(doc,options){return options&&options.relaxed?parseInt(doc.$numberInt,10):new _Int32(doc.$numberInt)}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){return`new Int32(${this.valueOf()})`}};var MaxKey=class _MaxKey extends BSONValue{get _bsontype(){return"MaxKey"}toExtendedJSON(){return{$maxKey:1}}static fromExtendedJSON(){return new _MaxKey}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){return"new MaxKey()"}};var MinKey=class _MinKey extends BSONValue{get _bsontype(){return"MinKey"}toExtendedJSON(){return{$minKey:1}}static fromExtendedJSON(){return new _MinKey}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){return"new MinKey()"}};var checkForHexRegExp=new RegExp("^[0-9a-fA-F]{24}$");var PROCESS_UNIQUE=null;var kId=Symbol("id");var ObjectId2=class _ObjectId extends BSONValue{get _bsontype(){return"ObjectId"}constructor(inputId){super();let workingId;if(typeof inputId==="object"&&inputId&&"id"in inputId){if(typeof inputId.id!=="string"&&!ArrayBuffer.isView(inputId.id)){throw new BSONError("Argument passed in must have an id that is of type string or Buffer")}if("toHexString"in inputId&&typeof inputId.toHexString==="function"){workingId=ByteUtils.fromHex(inputId.toHexString())}else{workingId=inputId.id}}else{workingId=inputId}if(workingId==null||typeof workingId==="number"){this[kId]=_ObjectId.generate(typeof workingId==="number"?workingId:void 0)}else if(ArrayBuffer.isView(workingId)&&workingId.byteLength===12){this[kId]=ByteUtils.toLocalBufferType(workingId)}else if(typeof workingId==="string"){if(workingId.length===12){const bytes=ByteUtils.fromUTF8(workingId);if(bytes.byteLength===12){this[kId]=bytes}else{throw new BSONError("Argument passed in must be a string of 12 bytes")}}else if(workingId.length===24&&checkForHexRegExp.test(workingId)){this[kId]=ByteUtils.fromHex(workingId)}else{throw new BSONError("Argument passed in must be a string of 12 bytes or a string of 24 hex characters or an integer")}}else{throw new BSONError("Argument passed in does not match the accepted types")}if(_ObjectId.cacheHexString){this.__id=ByteUtils.toHex(this.id)}}get id(){return this[kId]}set id(value){this[kId]=value;if(_ObjectId.cacheHexString){this.__id=ByteUtils.toHex(value)}}toHexString(){if(_ObjectId.cacheHexString&&this.__id){return this.__id}const hexString=ByteUtils.toHex(this.id);if(_ObjectId.cacheHexString&&!this.__id){this.__id=hexString}return hexString}static getInc(){return _ObjectId.index=(_ObjectId.index+1)%16777215}static generate(time){if("number"!==typeof time){time=Math.floor(Date.now()/1e3)}const inc=_ObjectId.getInc();const buffer2=ByteUtils.allocate(12);BSONDataView.fromUint8Array(buffer2).setUint32(0,time,false);if(PROCESS_UNIQUE===null){PROCESS_UNIQUE=ByteUtils.randomBytes(5)}buffer2[4]=PROCESS_UNIQUE[0];buffer2[5]=PROCESS_UNIQUE[1];buffer2[6]=PROCESS_UNIQUE[2];buffer2[7]=PROCESS_UNIQUE[3];buffer2[8]=PROCESS_UNIQUE[4];buffer2[11]=inc&255;buffer2[10]=inc>>8&255;buffer2[9]=inc>>16&255;return buffer2}toString(encoding){if(encoding==="base64")return ByteUtils.toBase64(this.id);if(encoding==="hex")return this.toHexString();return this.toHexString()}toJSON(){return this.toHexString()}equals(otherId){if(otherId===void 0||otherId===null){return false}if(otherId instanceof _ObjectId){return this[kId][11]===otherId[kId][11]&&ByteUtils.equals(this[kId],otherId[kId])}if(typeof otherId==="string"&&_ObjectId.isValid(otherId)&&otherId.length===12&&isUint8Array(this.id)){return ByteUtils.equals(this.id,ByteUtils.fromISO88591(otherId))}if(typeof otherId==="string"&&_ObjectId.isValid(otherId)&&otherId.length===24){return otherId.toLowerCase()===this.toHexString()}if(typeof otherId==="string"&&_ObjectId.isValid(otherId)&&otherId.length===12){return ByteUtils.equals(ByteUtils.fromUTF8(otherId),this.id)}if(typeof otherId==="object"&&"toHexString"in otherId&&typeof otherId.toHexString==="function"){const otherIdString=otherId.toHexString();const thisIdString=this.toHexString().toLowerCase();return typeof otherIdString==="string"&&otherIdString.toLowerCase()===thisIdString}return false}getTimestamp(){const timestamp=new Date;const time=BSONDataView.fromUint8Array(this.id).getUint32(0,false);timestamp.setTime(Math.floor(time)*1e3);return timestamp}static createPk(){return new _ObjectId}static createFromTime(time){const buffer2=ByteUtils.fromNumberArray([0,0,0,0,0,0,0,0,0,0,0,0]);BSONDataView.fromUint8Array(buffer2).setUint32(0,time,false);return new _ObjectId(buffer2)}static createFromHexString(hexString){if(typeof hexString==="undefined"||hexString!=null&&hexString.length!==24){throw new BSONError("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters")}return new _ObjectId(ByteUtils.fromHex(hexString))}static isValid(id){if(id==null)return false;try{new _ObjectId(id);return true}catch{return false}}toExtendedJSON(){if(this.toHexString)return{$oid:this.toHexString()};return{$oid:this.toString("hex")}}static fromExtendedJSON(doc){return new _ObjectId(doc.$oid)}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){return`new ObjectId("${this.toHexString()}")`}};ObjectId2.index=Math.floor(Math.random()*16777215);function internalCalculateObjectSize(object,serializeFunctions,ignoreUndefined){let totalLength=4+1;if(Array.isArray(object)){for(let i=0;i<object.length;i++){totalLength+=calculateElement(i.toString(),object[i],serializeFunctions,true,ignoreUndefined)}}else{if(typeof object?.toBSON==="function"){object=object.toBSON()}for(const key of Object.keys(object)){totalLength+=calculateElement(key,object[key],serializeFunctions,false,ignoreUndefined)}}return totalLength}function calculateElement(name,value,serializeFunctions=false,isArray=false,ignoreUndefined=false){if(typeof value?.toBSON==="function"){value=value.toBSON()}switch(typeof value){case"string":return 1+ByteUtils.utf8ByteLength(name)+1+4+ByteUtils.utf8ByteLength(value)+1;case"number":if(Math.floor(value)===value&&value>=JS_INT_MIN&&value<=JS_INT_MAX){if(value>=BSON_INT32_MIN&&value<=BSON_INT32_MAX){return(name!=null?ByteUtils.utf8ByteLength(name)+1:0)+(4+1)}else{return(name!=null?ByteUtils.utf8ByteLength(name)+1:0)+(8+1)}}else{return(name!=null?ByteUtils.utf8ByteLength(name)+1:0)+(8+1)}case"undefined":if(isArray||!ignoreUndefined)return(name!=null?ByteUtils.utf8ByteLength(name)+1:0)+1;return 0;case"boolean":return(name!=null?ByteUtils.utf8ByteLength(name)+1:0)+(1+1);case"object":if(value!=null&&typeof value._bsontype==="string"&&value[Symbol.for("@@mdb.bson.version")]!==BSON_MAJOR_VERSION){throw new BSONVersionError}else if(value==null||value._bsontype==="MinKey"||value._bsontype==="MaxKey"){return(name!=null?ByteUtils.utf8ByteLength(name)+1:0)+1}else if(value._bsontype==="ObjectId"){return(name!=null?ByteUtils.utf8ByteLength(name)+1:0)+(12+1)}else if(value instanceof Date||isDate(value)){return(name!=null?ByteUtils.utf8ByteLength(name)+1:0)+(8+1)}else if(ArrayBuffer.isView(value)||value instanceof ArrayBuffer||isAnyArrayBuffer(value)){return(name!=null?ByteUtils.utf8ByteLength(name)+1:0)+(1+4+1)+value.byteLength}else if(value._bsontype==="Long"||value._bsontype==="Double"||value._bsontype==="Timestamp"){return(name!=null?ByteUtils.utf8ByteLength(name)+1:0)+(8+1)}else if(value._bsontype==="Decimal128"){return(name!=null?ByteUtils.utf8ByteLength(name)+1:0)+(16+1)}else if(value._bsontype==="Code"){if(value.scope!=null&&Object.keys(value.scope).length>0){return(name!=null?ByteUtils.utf8ByteLength(name)+1:0)+1+4+4+ByteUtils.utf8ByteLength(value.code.toString())+1+internalCalculateObjectSize(value.scope,serializeFunctions,ignoreUndefined)}else{return(name!=null?ByteUtils.utf8ByteLength(name)+1:0)+1+4+ByteUtils.utf8ByteLength(value.code.toString())+1}}else if(value._bsontype==="Binary"){const binary=value;if(binary.sub_type===Binary.SUBTYPE_BYTE_ARRAY){return(name!=null?ByteUtils.utf8ByteLength(name)+1:0)+(binary.position+1+4+1+4)}else{return(name!=null?ByteUtils.utf8ByteLength(name)+1:0)+(binary.position+1+4+1)}}else if(value._bsontype==="Symbol"){return(name!=null?ByteUtils.utf8ByteLength(name)+1:0)+ByteUtils.utf8ByteLength(value.value)+4+1+1}else if(value._bsontype==="DBRef"){const ordered_values=Object.assign({$ref:value.collection,$id:value.oid},value.fields);if(value.db!=null){ordered_values["$db"]=value.db}return(name!=null?ByteUtils.utf8ByteLength(name)+1:0)+1+internalCalculateObjectSize(ordered_values,serializeFunctions,ignoreUndefined)}else if(value instanceof RegExp||isRegExp(value)){return(name!=null?ByteUtils.utf8ByteLength(name)+1:0)+1+ByteUtils.utf8ByteLength(value.source)+1+(value.global?1:0)+(value.ignoreCase?1:0)+(value.multiline?1:0)+1}else if(value._bsontype==="BSONRegExp"){return(name!=null?ByteUtils.utf8ByteLength(name)+1:0)+1+ByteUtils.utf8ByteLength(value.pattern)+1+ByteUtils.utf8ByteLength(value.options)+1}else{return(name!=null?ByteUtils.utf8ByteLength(name)+1:0)+internalCalculateObjectSize(value,serializeFunctions,ignoreUndefined)+1}case"function":if(serializeFunctions){return(name!=null?ByteUtils.utf8ByteLength(name)+1:0)+1+4+ByteUtils.utf8ByteLength(value.toString())+1}}return 0}function alphabetize(str){return str.split("").sort().join("")}var BSONRegExp=class _BSONRegExp extends BSONValue{get _bsontype(){return"BSONRegExp"}constructor(pattern,options){super();this.pattern=pattern;this.options=alphabetize(options??"");if(this.pattern.indexOf("\0")!==-1){throw new BSONError(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`)}if(this.options.indexOf("\0")!==-1){throw new BSONError(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`)}for(let i=0;i<this.options.length;i++){if(!(this.options[i]==="i"||this.options[i]==="m"||this.options[i]==="x"||this.options[i]==="l"||this.options[i]==="s"||this.options[i]==="u")){throw new BSONError(`The regular expression option [${this.options[i]}] is not supported`)}}}static parseOptions(options){return options?options.split("").sort().join(""):""}toExtendedJSON(options){options=options||{};if(options.legacy){return{$regex:this.pattern,$options:this.options}}return{$regularExpression:{pattern:this.pattern,options:this.options}}}static fromExtendedJSON(doc){if("$regex"in doc){if(typeof doc.$regex!=="string"){if(doc.$regex._bsontype==="BSONRegExp"){return doc}}else{return new _BSONRegExp(doc.$regex,_BSONRegExp.parseOptions(doc.$options))}}if("$regularExpression"in doc){return new _BSONRegExp(doc.$regularExpression.pattern,_BSONRegExp.parseOptions(doc.$regularExpression.options))}throw new BSONError(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(doc)}`)}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){return`new BSONRegExp(${JSON.stringify(this.pattern)}, ${JSON.stringify(this.options)})`}};var BSONSymbol=class _BSONSymbol extends BSONValue{get _bsontype(){return"BSONSymbol"}constructor(value){super();this.value=value}valueOf(){return this.value}toString(){return this.value}inspect(){return`new BSONSymbol("${this.value}")`}toJSON(){return this.value}toExtendedJSON(){return{$symbol:this.value}}static fromExtendedJSON(doc){return new _BSONSymbol(doc.$symbol)}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}};var LongWithoutOverridesClass=Long;var Timestamp=class _Timestamp extends LongWithoutOverridesClass{get _bsontype(){return"Timestamp"}constructor(low){if(low==null){super(0,0,true)}else if(typeof low==="bigint"){super(low,true)}else if(Long.isLong(low)){super(low.low,low.high,true)}else if(typeof low==="object"&&"t"in low&&"i"in low){if(typeof low.t!=="number"&&(typeof low.t!=="object"||low.t._bsontype!=="Int32")){throw new BSONError("Timestamp constructed from { t, i } must provide t as a number")}if(typeof low.i!=="number"&&(typeof low.i!=="object"||low.i._bsontype!=="Int32")){throw new BSONError("Timestamp constructed from { t, i } must provide i as a number")}if(low.t<0){throw new BSONError("Timestamp constructed from { t, i } must provide a positive t")}if(low.i<0){throw new BSONError("Timestamp constructed from { t, i } must provide a positive i")}if(low.t>4294967295){throw new BSONError("Timestamp constructed from { t, i } must provide t equal or less than uint32 max")}if(low.i>4294967295){throw new BSONError("Timestamp constructed from { t, i } must provide i equal or less than uint32 max")}super(low.i.valueOf(),low.t.valueOf(),true)}else{throw new BSONError("A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }")}}toJSON(){return{$timestamp:this.toString()}}static fromInt(value){return new _Timestamp(Long.fromInt(value,true))}static fromNumber(value){return new _Timestamp(Long.fromNumber(value,true))}static fromBits(lowBits,highBits){return new _Timestamp({i:lowBits,t:highBits})}static fromString(str,optRadix){return new _Timestamp(Long.fromString(str,true,optRadix))}toExtendedJSON(){return{$timestamp:{t:this.high>>>0,i:this.low>>>0}}}static fromExtendedJSON(doc){const i=Long.isLong(doc.$timestamp.i)?doc.$timestamp.i.getLowBitsUnsigned():doc.$timestamp.i;const t2=Long.isLong(doc.$timestamp.t)?doc.$timestamp.t.getLowBitsUnsigned():doc.$timestamp.t;return new _Timestamp({t:t2,i})}[Symbol.for("nodejs.util.inspect.custom")](){return this.inspect()}inspect(){return`new Timestamp({ t: ${this.getHighBits()}, i: ${this.getLowBits()} })`}};Timestamp.MAX_VALUE=Long.MAX_UNSIGNED_VALUE;var FIRST_BIT=128;var FIRST_TWO_BITS=192;var FIRST_THREE_BITS=224;var FIRST_FOUR_BITS=240;var FIRST_FIVE_BITS=248;var TWO_BIT_CHAR=192;var THREE_BIT_CHAR=224;var FOUR_BIT_CHAR=240;var CONTINUING_CHAR=128;function validateUtf8(bytes,start,end){let continuation=0;for(let i=start;i<end;i+=1){const byte=bytes[i];if(continuation){if((byte&FIRST_TWO_BITS)!==CONTINUING_CHAR){return false}continuation-=1}else if(byte&FIRST_BIT){if((byte&FIRST_THREE_BITS)===TWO_BIT_CHAR){continuation=1}else if((byte&FIRST_FOUR_BITS)===THREE_BIT_CHAR){continuation=2}else if((byte&FIRST_FIVE_BITS)===FOUR_BIT_CHAR){continuation=3}else{return false}}}return!continuation}var JS_INT_MAX_LONG=Long.fromNumber(JS_INT_MAX);var JS_INT_MIN_LONG=Long.fromNumber(JS_INT_MIN);function internalDeserialize(buffer2,options,isArray){options=options==null?{}:options;const index=options&&options.index?options.index:0;const size=buffer2[index]|buffer2[index+1]<<8|buffer2[index+2]<<16|buffer2[index+3]<<24;if(size<5){throw new BSONError(`bson size must be >= 5, is ${size}`)}if(options.allowObjectSmallerThanBufferSize&&buffer2.length<size){throw new BSONError(`buffer length ${buffer2.length} must be >= bson size ${size}`)}if(!options.allowObjectSmallerThanBufferSize&&buffer2.length!==size){throw new BSONError(`buffer length ${buffer2.length} must === bson size ${size}`)}if(size+index>buffer2.byteLength){throw new BSONError(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer2.byteLength})`)}if(buffer2[index+size-1]!==0){throw new BSONError("One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00")}return deserializeObject(buffer2,index,options,isArray)}var allowedDBRefKeys=/^\$ref$|^\$id$|^\$db$/;function deserializeObject(buffer2,index,options,isArray=false){const fieldsAsRaw=options["fieldsAsRaw"]==null?null:options["fieldsAsRaw"];const raw=options["raw"]==null?false:options["raw"];const bsonRegExp=typeof options["bsonRegExp"]==="boolean"?options["bsonRegExp"]:false;const promoteBuffers=options.promoteBuffers??false;const promoteLongs=options.promoteLongs??true;const promoteValues=options.promoteValues??true;const useBigInt64=options.useBigInt64??false;if(useBigInt64&&!promoteValues){throw new BSONError("Must either request bigint or Long for int64 deserialization")}if(useBigInt64&&!promoteLongs){throw new BSONError("Must either request bigint or Long for int64 deserialization")}const validation=options.validation==null?{utf8:true}:options.validation;let globalUTFValidation=true;let validationSetting;const utf8KeysSet=new Set;const utf8ValidatedKeys=validation.utf8;if(typeof utf8ValidatedKeys==="boolean"){validationSetting=utf8ValidatedKeys}else{globalUTFValidation=false;const utf8ValidationValues=Object.keys(utf8ValidatedKeys).map(function(key){return utf8ValidatedKeys[key]});if(utf8ValidationValues.length===0){throw new BSONError("UTF-8 validation setting cannot be empty")}if(typeof utf8ValidationValues[0]!=="boolean"){throw new BSONError("Invalid UTF-8 validation option, must specify boolean values")}validationSetting=utf8ValidationValues[0];if(!utf8ValidationValues.every(item=>item===validationSetting)){throw new BSONError("Invalid UTF-8 validation option - keys must be all true or all false")}}if(!globalUTFValidation){for(const key of Object.keys(utf8ValidatedKeys)){utf8KeysSet.add(key)}}const startIndex=index;if(buffer2.length<5)throw new BSONError("corrupt bson message < 5 bytes long");const size=buffer2[index++]|buffer2[index++]<<8|buffer2[index++]<<16|buffer2[index++]<<24;if(size<5||size>buffer2.length)throw new BSONError("corrupt bson message");const object=isArray?[]:{};let arrayIndex=0;const done=false;let isPossibleDBRef=isArray?false:null;const dataview=new DataView(buffer2.buffer,buffer2.byteOffset,buffer2.byteLength);while(!done){const elementType=buffer2[index++];if(elementType===0)break;let i=index;while(buffer2[i]!==0&&i<buffer2.length){i++}if(i>=buffer2.byteLength)throw new BSONError("Bad BSON Document: illegal CString");const name=isArray?arrayIndex++:ByteUtils.toUTF8(buffer2.subarray(index,i));let shouldValidateKey=true;if(globalUTFValidation||utf8KeysSet.has(name)){shouldValidateKey=validationSetting}else{shouldValidateKey=!validationSetting}if(isPossibleDBRef!==false&&name[0]==="$"){isPossibleDBRef=allowedDBRefKeys.test(name)}let value;index=i+1;if(elementType===BSON_DATA_STRING){const stringSize=buffer2[index++]|buffer2[index++]<<8|buffer2[index++]<<16|buffer2[index++]<<24;if(stringSize<=0||stringSize>buffer2.length-index||buffer2[index+stringSize-1]!==0){throw new BSONError("bad string length in bson")}value=getValidatedString(buffer2,index,index+stringSize-1,shouldValidateKey);index=index+stringSize}else if(elementType===BSON_DATA_OID){const oid=ByteUtils.allocate(12);oid.set(buffer2.subarray(index,index+12));value=new ObjectId2(oid);index=index+12}else if(elementType===BSON_DATA_INT&&promoteValues===false){value=new Int32(buffer2[index++]|buffer2[index++]<<8|buffer2[index++]<<16|buffer2[index++]<<24)}else if(elementType===BSON_DATA_INT){value=buffer2[index++]|buffer2[index++]<<8|buffer2[index++]<<16|buffer2[index++]<<24}else if(elementType===BSON_DATA_NUMBER&&promoteValues===false){value=new Double(dataview.getFloat64(index,true));index=index+8}else if(elementType===BSON_DATA_NUMBER){value=dataview.getFloat64(index,true);index=index+8}else if(elementType===BSON_DATA_DATE){const lowBits=buffer2[index++]|buffer2[index++]<<8|buffer2[index++]<<16|buffer2[index++]<<24;const highBits=buffer2[index++]|buffer2[index++]<<8|buffer2[index++]<<16|buffer2[index++]<<24;value=new Date(new Long(lowBits,highBits).toNumber())}else if(elementType===BSON_DATA_BOOLEAN){if(buffer2[index]!==0&&buffer2[index]!==1)throw new BSONError("illegal boolean type value");value=buffer2[index++]===1}else if(elementType===BSON_DATA_OBJECT){const _index=index;const objectSize=buffer2[index]|buffer2[index+1]<<8|buffer2[index+2]<<16|buffer2[index+3]<<24;if(objectSize<=0||objectSize>buffer2.length-index)throw new BSONError("bad embedded document length in bson");if(raw){value=buffer2.slice(index,index+objectSize)}else{let objectOptions=options;if(!globalUTFValidation){objectOptions={...options,validation:{utf8:shouldValidateKey}}}value=deserializeObject(buffer2,_index,objectOptions,false)}index=index+objectSize}else if(elementType===BSON_DATA_ARRAY){const _index=index;const objectSize=buffer2[index]|buffer2[index+1]<<8|buffer2[index+2]<<16|buffer2[index+3]<<24;let arrayOptions=options;const stopIndex=index+objectSize;if(fieldsAsRaw&&fieldsAsRaw[name]){arrayOptions={...options,raw:true}}if(!globalUTFValidation){arrayOptions={...arrayOptions,validation:{utf8:shouldValidateKey}}}value=deserializeObject(buffer2,_index,arrayOptions,true);index=index+objectSize;if(buffer2[index-1]!==0)throw new BSONError("invalid array terminator byte");if(index!==stopIndex)throw new BSONError("corrupted array bson")}else if(elementType===BSON_DATA_UNDEFINED){value=void 0}else if(elementType===BSON_DATA_NULL){value=null}else if(elementType===BSON_DATA_LONG){const dataview2=BSONDataView.fromUint8Array(buffer2.subarray(index,index+8));const lowBits=buffer2[index++]|buffer2[index++]<<8|buffer2[index++]<<16|buffer2[index++]<<24;const highBits=buffer2[index++]|buffer2[index++]<<8|buffer2[index++]<<16|buffer2[index++]<<24;const long=new Long(lowBits,highBits);if(useBigInt64){value=dataview2.getBigInt64(0,true)}else if(promoteLongs&&promoteValues===true){value=long.lessThanOrEqual(JS_INT_MAX_LONG)&&long.greaterThanOrEqual(JS_INT_MIN_LONG)?long.toNumber():long}else{value=long}}else if(elementType===BSON_DATA_DECIMAL128){const bytes=ByteUtils.allocate(16);bytes.set(buffer2.subarray(index,index+16),0);index=index+16;value=new Decimal128(bytes)}else if(elementType===BSON_DATA_BINARY){let binarySize=buffer2[index++]|buffer2[index++]<<8|buffer2[index++]<<16|buffer2[index++]<<24;const totalBinarySize=binarySize;const subType=buffer2[index++];if(binarySize<0)throw new BSONError("Negative binary type element size found");if(binarySize>buffer2.byteLength)throw new BSONError("Binary type size larger than document size");if(buffer2["slice"]!=null){if(subType===Binary.SUBTYPE_BYTE_ARRAY){binarySize=buffer2[index++]|buffer2[index++]<<8|buffer2[index++]<<16|buffer2[index++]<<24;if(binarySize<0)throw new BSONError("Negative binary type element size found for subtype 0x02");if(binarySize>totalBinarySize-4)throw new BSONError("Binary type with subtype 0x02 contains too long binary size");if(binarySize<totalBinarySize-4)throw new BSONError("Binary type with subtype 0x02 contains too short binary size")}if(promoteBuffers&&promoteValues){value=ByteUtils.toLocalBufferType(buffer2.slice(index,index+binarySize))}else{value=new Binary(buffer2.slice(index,index+binarySize),subType);if(subType===BSON_BINARY_SUBTYPE_UUID_NEW){value=value.toUUID()}}}else{const _buffer=ByteUtils.allocate(binarySize);if(subType===Binary.SUBTYPE_BYTE_ARRAY){binarySize=buffer2[index++]|buffer2[index++]<<8|buffer2[index++]<<16|buffer2[index++]<<24;if(binarySize<0)throw new BSONError("Negative binary type element size found for subtype 0x02");if(binarySize>totalBinarySize-4)throw new BSONError("Binary type with subtype 0x02 contains too long binary size");if(binarySize<totalBinarySize-4)throw new BSONError("Binary type with subtype 0x02 contains too short binary size")}for(i=0;i<binarySize;i++){_buffer[i]=buffer2[index+i]}if(promoteBuffers&&promoteValues){value=_buffer}else if(subType===BSON_BINARY_SUBTYPE_UUID_NEW){value=new Binary(buffer2.slice(index,index+binarySize),subType).toUUID()}else{value=new Binary(buffer2.slice(index,index+binarySize),subType)}}index=index+binarySize}else if(elementType===BSON_DATA_REGEXP&&bsonRegExp===false){i=index;while(buffer2[i]!==0&&i<buffer2.length){i++}if(i>=buffer2.length)throw new BSONError("Bad BSON Document: illegal CString");const source=ByteUtils.toUTF8(buffer2.subarray(index,i));index=i+1;i=index;while(buffer2[i]!==0&&i<buffer2.length){i++}if(i>=buffer2.length)throw new BSONError("Bad BSON Document: illegal CString");const regExpOptions=ByteUtils.toUTF8(buffer2.subarray(index,i));index=i+1;const optionsArray=new Array(regExpOptions.length);for(i=0;i<regExpOptions.length;i++){switch(regExpOptions[i]){case"m":optionsArray[i]="m";break;case"s":optionsArray[i]="g";break;case"i":optionsArray[i]="i";break}}value=new RegExp(source,optionsArray.join(""))}else if(elementType===BSON_DATA_REGEXP&&bsonRegExp===true){i=index;while(buffer2[i]!==0&&i<buffer2.length){i++}if(i>=buffer2.length)throw new BSONError("Bad BSON Document: illegal CString");const source=ByteUtils.toUTF8(buffer2.subarray(index,i));index=i+1;i=index;while(buffer2[i]!==0&&i<buffer2.length){i++}if(i>=buffer2.length)throw new BSONError("Bad BSON Document: illegal CString");const regExpOptions=ByteUtils.toUTF8(buffer2.subarray(index,i));index=i+1;value=new BSONRegExp(source,regExpOptions)}else if(elementType===BSON_DATA_SYMBOL){const stringSize=buffer2[index++]|buffer2[index++]<<8|buffer2[index++]<<16|buffer2[index++]<<24;if(stringSize<=0||stringSize>buffer2.length-index||buffer2[index+stringSize-1]!==0){throw new BSONError("bad string length in bson")}const symbol=getValidatedString(buffer2,index,index+stringSize-1,shouldValidateKey);value=promoteValues?symbol:new BSONSymbol(symbol);index=index+stringSize}else if(elementType===BSON_DATA_TIMESTAMP){const i2=buffer2[index++]+buffer2[index++]*(1<<8)+buffer2[index++]*(1<<16)+buffer2[index++]*(1<<24);const t2=buffer2[index++]+buffer2[index++]*(1<<8)+buffer2[index++]*(1<<16)+buffer2[index++]*(1<<24);value=new Timestamp({i:i2,t:t2})}else if(elementType===BSON_DATA_MIN_KEY){value=new MinKey}else if(elementType===BSON_DATA_MAX_KEY){value=new MaxKey}else if(elementType===BSON_DATA_CODE){const stringSize=buffer2[index++]|buffer2[index++]<<8|buffer2[index++]<<16|buffer2[index++]<<24;if(stringSize<=0||stringSize>buffer2.length-index||buffer2[index+stringSize-1]!==0){throw new BSONError("bad string length in bson")}const functionString=getValidatedString(buffer2,index,index+stringSize-1,shouldValidateKey);value=new Code(functionString);index=index+stringSize}else if(elementType===BSON_DATA_CODE_W_SCOPE){const totalSize=buffer2[index++]|buffer2[index++]<<8|buffer2[index++]<<16|buffer2[index++]<<24;if(totalSize<4+4+4+1){throw new BSONError("code_w_scope total size shorter minimum expected length")}const stringSize=buffer2[index++]|buffer2[index++]<<8|buffer2[index++]<<16|buffer2[index++]<<24;if(stringSize<=0||stringSize>buffer2.length-index||buffer2[index+stringSize-1]!==0){throw new BSONError("bad string length in bson")}const functionString=getValidatedString(buffer2,index,index+stringSize-1,shouldValidateKey);index=index+stringSize;const _index=index;const objectSize=buffer2[index]|buffer2[index+1]<<8|buffer2[index+2]<<16|buffer2[index+3]<<24;const scopeObject=deserializeObject(buffer2,_index,options,false);index=index+objectSize;if(totalSize<4+4+objectSize+stringSize){throw new BSONError("code_w_scope total size is too short, truncating scope")}if(totalSize>4+4+objectSize+stringSize){throw new BSONError("code_w_scope total size is too long, clips outer document")}value=new Code(functionString,scopeObject)}else if(elementType===BSON_DATA_DBPOINTER){const stringSize=buffer2[index++]|buffer2[index++]<<8|buffer2[index++]<<16|buffer2[index++]<<24;if(stringSize<=0||stringSize>buffer2.length-index||buffer2[index+stringSize-1]!==0)throw new BSONError("bad string length in bson");if(validation!=null&&validation.utf8){if(!validateUtf8(buffer2,index,index+stringSize-1)){throw new BSONError("Invalid UTF-8 string in BSON document")}}const namespace=ByteUtils.toUTF8(buffer2.subarray(index,index+stringSize-1));index=index+stringSize;const oidBuffer=ByteUtils.allocate(12);oidBuffer.set(buffer2.subarray(index,index+12),0);const oid=new ObjectId2(oidBuffer);index=index+12;value=new DBRef(namespace,oid)}else{throw new BSONError(`Detected unknown BSON type ${elementType.toString(16)} for fieldname "${name}"`)}if(name==="__proto__"){Object.defineProperty(object,name,{value,writable:true,enumerable:true,configurable:true})}else{object[name]=value}}if(size!==index-startIndex){if(isArray)throw new BSONError("corrupt array bson");throw new BSONError("corrupt object bson")}if(!isPossibleDBRef)return object;if(isDBRefLike(object)){const copy=Object.assign({},object);delete copy.$ref;delete copy.$id;delete copy.$db;return new DBRef(object.$ref,object.$id,object.$db,copy)}return object}function getValidatedString(buffer2,start,end,shouldValidateUtf8){const value=ByteUtils.toUTF8(buffer2.subarray(start,end));if(shouldValidateUtf8){for(let i=0;i<value.length;i++){if(value.charCodeAt(i)===65533){if(!validateUtf8(buffer2,start,end)){throw new BSONError("Invalid UTF-8 string in BSON document")}break}}}return value}var regexp=/\x00/;var ignoreKeys=new Set(["$db","$ref","$id","$clusterTime"]);function serializeString(buffer2,key,value,index){buffer2[index++]=BSON_DATA_STRING;const numberOfWrittenBytes=ByteUtils.encodeUTF8Into(buffer2,key,index);index=index+numberOfWrittenBytes+1;buffer2[index-1]=0;const size=ByteUtils.encodeUTF8Into(buffer2,value,index+4);buffer2[index+3]=size+1>>24&255;buffer2[index+2]=size+1>>16&255;buffer2[index+1]=size+1>>8&255;buffer2[index]=size+1&255;index=index+4+size;buffer2[index++]=0;return index}var NUMBER_SPACE=new DataView(new ArrayBuffer(8),0,8);var FOUR_BYTE_VIEW_ON_NUMBER=new Uint8Array(NUMBER_SPACE.buffer,0,4);var EIGHT_BYTE_VIEW_ON_NUMBER=new Uint8Array(NUMBER_SPACE.buffer,0,8);function serializeNumber(buffer2,key,value,index){const isNegativeZero=Object.is(value,-0);const type=!isNegativeZero&&Number.isSafeInteger(value)&&value<=BSON_INT32_MAX&&value>=BSON_INT32_MIN?BSON_DATA_INT:BSON_DATA_NUMBER;if(type===BSON_DATA_INT){NUMBER_SPACE.setInt32(0,value,true)}else{NUMBER_SPACE.setFloat64(0,value,true)}const bytes=type===BSON_DATA_INT?FOUR_BYTE_VIEW_ON_NUMBER:EIGHT_BYTE_VIEW_ON_NUMBER;buffer2[index++]=type;const numberOfWrittenBytes=ByteUtils.encodeUTF8Into(buffer2,key,index);index=index+numberOfWrittenBytes;buffer2[index++]=0;buffer2.set(bytes,index);index+=bytes.byteLength;return index}function serializeBigInt(buffer2,key,value,index){buffer2[index++]=BSON_DATA_LONG;const numberOfWrittenBytes=ByteUtils.encodeUTF8Into(buffer2,key,index);index+=numberOfWrittenBytes;buffer2[index++]=0;NUMBER_SPACE.setBigInt64(0,value,true);buffer2.set(EIGHT_BYTE_VIEW_ON_NUMBER,index);index+=EIGHT_BYTE_VIEW_ON_NUMBER.byteLength;return index}function serializeNull(buffer2,key,_,index){buffer2[index++]=BSON_DATA_NULL;const numberOfWrittenBytes=ByteUtils.encodeUTF8Into(buffer2,key,index);index=index+numberOfWrittenBytes;buffer2[index++]=0;return index}function serializeBoolean(buffer2,key,value,index){buffer2[index++]=BSON_DATA_BOOLEAN;const numberOfWrittenBytes=ByteUtils.encodeUTF8Into(buffer2,key,index);index=index+numberOfWrittenBytes;buffer2[index++]=0;buffer2[index++]=value?1:0;return index}function serializeDate(buffer2,key,value,index){buffer2[index++]=BSON_DATA_DATE;const numberOfWrittenBytes=ByteUtils.encodeUTF8Into(buffer2,key,index);index=index+numberOfWrittenBytes;buffer2[index++]=0;const dateInMilis=Long.fromNumber(value.getTime());const lowBits=dateInMilis.getLowBits();const highBits=dateInMilis.getHighBits();buffer2[index++]=lowBits&255;buffer2[index++]=lowBits>>8&255;buffer2[index++]=lowBits>>16&255;buffer2[index++]=lowBits>>24&255;buffer2[index++]=highBits&255;buffer2[index++]=highBits>>8&255;buffer2[index++]=highBits>>16&255;buffer2[index++]=highBits>>24&255;return index}function serializeRegExp(buffer2,key,value,index){buffer2[index++]=BSON_DATA_REGEXP;const numberOfWrittenBytes=ByteUtils.encodeUTF8Into(buffer2,key,index);index=index+numberOfWrittenBytes;buffer2[index++]=0;if(value.source&&value.source.match(regexp)!=null){throw new BSONError("value "+value.source+" must not contain null bytes")}index=index+ByteUtils.encodeUTF8Into(buffer2,value.source,index);buffer2[index++]=0;if(value.ignoreCase)buffer2[index++]=105;if(value.global)buffer2[index++]=115;if(value.multiline)buffer2[index++]=109;buffer2[index++]=0;return index}function serializeBSONRegExp(buffer2,key,value,index){buffer2[index++]=BSON_DATA_REGEXP;const numberOfWrittenBytes=ByteUtils.encodeUTF8Into(buffer2,key,index);index=index+numberOfWrittenBytes;buffer2[index++]=0;if(value.pattern.match(regexp)!=null){throw new BSONError("pattern "+value.pattern+" must not contain null bytes")}index=index+ByteUtils.encodeUTF8Into(buffer2,value.pattern,index);buffer2[index++]=0;const sortedOptions=value.options.split("").sort().join("");index=index+ByteUtils.encodeUTF8Into(buffer2,sortedOptions,index);buffer2[index++]=0;return index}function serializeMinMax(buffer2,key,value,index){if(value===null){buffer2[index++]=BSON_DATA_NULL}else if(value._bsontype==="MinKey"){buffer2[index++]=BSON_DATA_MIN_KEY}else{buffer2[index++]=BSON_DATA_MAX_KEY}const numberOfWrittenBytes=ByteUtils.encodeUTF8Into(buffer2,key,index);index=index+numberOfWrittenBytes;buffer2[index++]=0;return index}function serializeObjectId(buffer2,key,value,index){buffer2[index++]=BSON_DATA_OID;const numberOfWrittenBytes=ByteUtils.encodeUTF8Into(buffer2,key,index);index=index+numberOfWrittenBytes;buffer2[index++]=0;if(isUint8Array(value.id)){buffer2.set(value.id.subarray(0,12),index)}else{throw new BSONError("object ["+JSON.stringify(value)+"] is not a valid ObjectId")}return index+12}function serializeBuffer(buffer2,key,value,index){buffer2[index++]=BSON_DATA_BINARY;const numberOfWrittenBytes=ByteUtils.encodeUTF8Into(buffer2,key,index);index=index+numberOfWrittenBytes;buffer2[index++]=0;const size=value.length;buffer2[index++]=size&255;buffer2[index++]=size>>8&255;buffer2[index++]=size>>16&255;buffer2[index++]=size>>24&255;buffer2[index++]=BSON_BINARY_SUBTYPE_DEFAULT;buffer2.set(value,index);index=index+size;return index}function serializeObject(buffer2,key,value,index,checkKeys,depth,serializeFunctions,ignoreUndefined,path3){if(path3.has(value)){throw new BSONError("Cannot convert circular structure to BSON")}path3.add(value);buffer2[index++]=Array.isArray(value)?BSON_DATA_ARRAY:BSON_DATA_OBJECT;const numberOfWrittenBytes=ByteUtils.encodeUTF8Into(buffer2,key,index);index=index+numberOfWrittenBytes;buffer2[index++]=0;const endIndex=serializeInto(buffer2,value,checkKeys,index,depth+1,serializeFunctions,ignoreUndefined,path3);path3.delete(value);return endIndex}function serializeDecimal128(buffer2,key,value,index){buffer2[index++]=BSON_DATA_DECIMAL128;const numberOfWrittenBytes=ByteUtils.encodeUTF8Into(buffer2,key,index);index=index+numberOfWrittenBytes;buffer2[index++]=0;buffer2.set(value.bytes.subarray(0,16),index);return index+16}function serializeLong(buffer2,key,value,index){buffer2[index++]=value._bsontype==="Long"?BSON_DATA_LONG:BSON_DATA_TIMESTAMP;const numberOfWrittenBytes=ByteUtils.encodeUTF8Into(buffer2,key,index);index=index+numberOfWrittenBytes;buffer2[index++]=0;const lowBits=value.getLowBits();const highBits=value.getHighBits();buffer2[index++]=lowBits&255;buffer2[index++]=lowBits>>8&255;buffer2[index++]=lowBits>>16&255;buffer2[index++]=lowBits>>24&255;buffer2[index++]=highBits&255;buffer2[index++]=highBits>>8&255;buffer2[index++]=highBits>>16&255;buffer2[index++]=highBits>>24&255;return index}function serializeInt32(buffer2,key,value,index){value=value.valueOf();buffer2[index++]=BSON_DATA_INT;const numberOfWrittenBytes=ByteUtils.encodeUTF8Into(buffer2,key,index);index=index+numberOfWrittenBytes;buffer2[index++]=0;buffer2[index++]=value&255;buffer2[index++]=value>>8&255;buffer2[index++]=value>>16&255;buffer2[index++]=value>>24&255;return index}function serializeDouble(buffer2,key,value,index){buffer2[index++]=BSON_DATA_NUMBER;const numberOfWrittenBytes=ByteUtils.encodeUTF8Into(buffer2,key,index);index=index+numberOfWrittenBytes;buffer2[index++]=0;NUMBER_SPACE.setFloat64(0,value.value,true);buffer2.set(EIGHT_BYTE_VIEW_ON_NUMBER,index);index=index+8;return index}function serializeFunction(buffer2,key,value,index){buffer2[index++]=BSON_DATA_CODE;const numberOfWrittenBytes=ByteUtils.encodeUTF8Into(buffer2,key,index);index=index+numberOfWrittenBytes;buffer2[index++]=0;const functionString=value.toString();const size=ByteUtils.encodeUTF8Into(buffer2,functionString,index+4)+1;buffer2[index]=size&255;buffer2[index+1]=size>>8&255;buffer2[index+2]=size>>16&255;buffer2[index+3]=size>>24&255;index=index+4+size-1;buffer2[index++]=0;return index}function serializeCode(buffer2,key,value,index,checkKeys=false,depth=0,serializeFunctions=false,ignoreUndefined=true,path3){if(value.scope&&typeof value.scope==="object"){buffer2[index++]=BSON_DATA_CODE_W_SCOPE;const numberOfWrittenBytes=ByteUtils.encodeUTF8Into(buffer2,key,index);index=index+numberOfWrittenBytes;buffer2[index++]=0;let startIndex=index;const functionString=value.code;index=index+4;const codeSize=ByteUtils.encodeUTF8Into(buffer2,functionString,index+4)+1;buffer2[index]=codeSize&255;buffer2[index+1]=codeSize>>8&255;buffer2[index+2]=codeSize>>16&255;buffer2[index+3]=codeSize>>24&255;buffer2[index+4+codeSize-1]=0;index=index+codeSize+4;const endIndex=serializeInto(buffer2,value.scope,checkKeys,index,depth+1,serializeFunctions,ignoreUndefined,path3);index=endIndex-1;const totalSize=endIndex-startIndex;buffer2[startIndex++]=totalSize&255;buffer2[startIndex++]=totalSize>>8&255;buffer2[startIndex++]=totalSize>>16&255;buffer2[startIndex++]=totalSize>>24&255;buffer2[index++]=0}else{buffer2[index++]=BSON_DATA_CODE;const numberOfWrittenBytes=ByteUtils.encodeUTF8Into(buffer2,key,index);index=index+numberOfWrittenBytes;buffer2[index++]=0;const functionString=value.code.toString();const size=ByteUtils.encodeUTF8Into(buffer2,functionString,index+4)+1;buffer2[index]=size&255;buffer2[index+1]=size>>8&255;buffer2[index+2]=size>>16&255;buffer2[index+3]=size>>24&255;index=index+4+size-1;buffer2[index++]=0}return index}function serializeBinary(buffer2,key,value,index){buffer2[index++]=BSON_DATA_BINARY;const numberOfWrittenBytes=ByteUtils.encodeUTF8Into(buffer2,key,index);index=index+numberOfWrittenBytes;buffer2[index++]=0;const data=value.buffer;let size=value.position;if(value.sub_type===Binary.SUBTYPE_BYTE_ARRAY)size=size+4;buffer2[index++]=size&255;buffer2[index++]=size>>8&255;buffer2[index++]=size>>16&255;buffer2[index++]=size>>24&255;buffer2[index++]=value.sub_type;if(value.sub_type===Binary.SUBTYPE_BYTE_ARRAY){size=size-4;buffer2[index++]=size&255;buffer2[index++]=size>>8&255;buffer2[index++]=size>>16&255;buffer2[index++]=size>>24&255}buffer2.set(data,index);index=index+value.position;return index}function serializeSymbol(buffer2,key,value,index){buffer2[index++]=BSON_DATA_SYMBOL;const numberOfWrittenBytes=ByteUtils.encodeUTF8Into(buffer2,key,index);index=index+numberOfWrittenBytes;buffer2[index++]=0;const size=ByteUtils.encodeUTF8Into(buffer2,value.value,index+4)+1;buffer2[index]=size&255;buffer2[index+1]=size>>8&255;buffer2[index+2]=size>>16&255;buffer2[index+3]=size>>24&255;index=index+4+size-1;buffer2[index++]=0;return index}function serializeDBRef(buffer2,key,value,index,depth,serializeFunctions,path3){buffer2[index++]=BSON_DATA_OBJECT;const numberOfWrittenBytes=ByteUtils.encodeUTF8Into(buffer2,key,index);index=index+numberOfWrittenBytes;buffer2[index++]=0;let startIndex=index;let output={$ref:value.collection||value.namespace,$id:value.oid};if(value.db!=null){output.$db=value.db}output=Object.assign(output,value.fields);const endIndex=serializeInto(buffer2,output,false,index,depth+1,serializeFunctions,true,path3);const size=endIndex-startIndex;buffer2[startIndex++]=size&255;buffer2[startIndex++]=size>>8&255;buffer2[startIndex++]=size>>16&255;buffer2[startIndex++]=size>>24&255;return endIndex}function serializeInto(buffer2,object,checkKeys,startingIndex,depth,serializeFunctions,ignoreUndefined,path3){if(path3==null){if(object==null){buffer2[0]=5;buffer2[1]=0;buffer2[2]=0;buffer2[3]=0;buffer2[4]=0;return 5}if(Array.isArray(object)){throw new BSONError("serialize does not support an array as the root input")}if(typeof object!=="object"){throw new BSONError("serialize does not support non-object as the root input")}else if("_bsontype"in object&&typeof object._bsontype==="string"){throw new BSONError(`BSON types cannot be serialized as a document`)}else if(isDate(object)||isRegExp(object)||isUint8Array(object)||isAnyArrayBuffer(object)){throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`)}path3=new Set}path3.add(object);let index=startingIndex+4;if(Array.isArray(object)){for(let i=0;i<object.length;i++){const key=`${i}`;let value=object[i];if(typeof value?.toBSON==="function"){value=value.toBSON()}if(typeof value==="string"){index=serializeString(buffer2,key,value,index)}else if(typeof value==="number"){index=serializeNumber(buffer2,key,value,index)}else if(typeof value==="bigint"){index=serializeBigInt(buffer2,key,value,index)}else if(typeof value==="boolean"){index=serializeBoolean(buffer2,key,value,index)}else if(value instanceof Date||isDate(value)){index=serializeDate(buffer2,key,value,index)}else if(value===void 0){index=serializeNull(buffer2,key,value,index)}else if(value===null){index=serializeNull(buffer2,key,value,index)}else if(isUint8Array(value)){index=serializeBuffer(buffer2,key,value,index)}else if(value instanceof RegExp||isRegExp(value)){index=serializeRegExp(buffer2,key,value,index)}else if(typeof value==="object"&&value._bsontype==null){index=serializeObject(buffer2,key,value,index,checkKeys,depth,serializeFunctions,ignoreUndefined,path3)}else if(typeof value==="object"&&value[Symbol.for("@@mdb.bson.version")]!==BSON_MAJOR_VERSION){throw new BSONVersionError}else if(value._bsontype==="ObjectId"){index=serializeObjectId(buffer2,key,value,index)}else if(value._bsontype==="Decimal128"){index=serializeDecimal128(buffer2,key,value,index)}else if(value._bsontype==="Long"||value._bsontype==="Timestamp"){index=serializeLong(buffer2,key,value,index)}else if(value._bsontype==="Double"){index=serializeDouble(buffer2,key,value,index)}else if(typeof value==="function"&&serializeFunctions){index=serializeFunction(buffer2,key,value,index)}else if(value._bsontype==="Code"){index=serializeCode(buffer2,key,value,index,checkKeys,depth,serializeFunctions,ignoreUndefined,path3)}else if(value._bsontype==="Binary"){index=serializeBinary(buffer2,key,value,index)}else if(value._bsontype==="BSONSymbol"){index=serializeSymbol(buffer2,key,value,index)}else if(value._bsontype==="DBRef"){index=serializeDBRef(buffer2,key,value,index,depth,serializeFunctions,path3)}else if(value._bsontype==="BSONRegExp"){index=serializeBSONRegExp(buffer2,key,value,index)}else if(value._bsontype==="Int32"){index=serializeInt32(buffer2,key,value,index)}else if(value._bsontype==="MinKey"||value._bsontype==="MaxKey"){index=serializeMinMax(buffer2,key,value,index)}else if(typeof value._bsontype!=="undefined"){throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`)}}}else if(object instanceof Map||isMap(object)){const iterator=object.entries();let done=false;while(!done){const entry=iterator.next();done=!!entry.done;if(done)continue;const key=entry.value[0];let value=entry.value[1];if(typeof value?.toBSON==="function"){value=value.toBSON()}const type=typeof value;if(typeof key==="string"&&!ignoreKeys.has(key)){if(key.match(regexp)!=null){throw new BSONError("key "+key+" must not contain null bytes")}if(checkKeys){if("$"===key[0]){throw new BSONError("key "+key+" must not start with '$'")}else if(~key.indexOf(".")){throw new BSONError("key "+key+" must not contain '.'")}}}if(type==="string"){index=serializeString(buffer2,key,value,index)}else if(type==="number"){index=serializeNumber(buffer2,key,value,index)}else if(type==="bigint"){index=serializeBigInt(buffer2,key,value,index)}else if(type==="boolean"){index=serializeBoolean(buffer2,key,value,index)}else if(value instanceof Date||isDate(value)){index=serializeDate(buffer2,key,value,index)}else if(value===null||value===void 0&&ignoreUndefined===false){index=serializeNull(buffer2,key,value,index)}else if(isUint8Array(value)){index=serializeBuffer(buffer2,key,value,index)}else if(value instanceof RegExp||isRegExp(value)){index=serializeRegExp(buffer2,key,value,index)}else if(type==="object"&&value._bsontype==null){index=serializeObject(buffer2,key,value,index,checkKeys,depth,serializeFunctions,ignoreUndefined,path3)}else if(typeof value==="object"&&value[Symbol.for("@@mdb.bson.version")]!==BSON_MAJOR_VERSION){throw new BSONVersionError}else if(value._bsontype==="ObjectId"){index=serializeObjectId(buffer2,key,value,index)}else if(type==="object"&&value._bsontype==="Decimal128"){index=serializeDecimal128(buffer2,key,value,index)}else if(value._bsontype==="Long"||value._bsontype==="Timestamp"){index=serializeLong(buffer2,key,value,index)}else if(value._bsontype==="Double"){index=serializeDouble(buffer2,key,value,index)}else if(value._bsontype==="Code"){index=serializeCode(buffer2,key,value,index,checkKeys,depth,serializeFunctions,ignoreUndefined,path3)}else if(typeof value==="function"&&serializeFunctions){index=serializeFunction(buffer2,key,value,index)}else if(value._bsontype==="Binary"){index=serializeBinary(buffer2,key,value,index)}else if(value._bsontype==="BSONSymbol"){index=serializeSymbol(buffer2,key,value,index)}else if(value._bsontype==="DBRef"){index=serializeDBRef(buffer2,key,value,index,depth,serializeFunctions,path3)}else if(value._bsontype==="BSONRegExp"){index=serializeBSONRegExp(buffer2,key,value,index)}else if(value._bsontype==="Int32"){index=serializeInt32(buffer2,key,value,index)}else if(value._bsontype==="MinKey"||value._bsontype==="MaxKey"){index=serializeMinMax(buffer2,key,value,index)}else if(typeof value._bsontype!=="undefined"){throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`)}}}else{if(typeof object?.toBSON==="function"){object=object.toBSON();if(object!=null&&typeof object!=="object"){throw new BSONError("toBSON function did not return an object")}}for(const key of Object.keys(object)){let value=object[key];if(typeof value?.toBSON==="function"){value=value.toBSON()}const type=typeof value;if(typeof key==="string"&&!ignoreKeys.has(key)){if(key.match(regexp)!=null){throw new BSONError("key "+key+" must not contain null bytes")}if(checkKeys){if("$"===key[0]){throw new BSONError("key "+key+" must not start with '$'")}else if(~key.indexOf(".")){throw new BSONError("key "+key+" must not contain '.'")}}}if(type==="string"){index=serializeString(buffer2,key,value,index)}else if(type==="number"){index=serializeNumber(buffer2,key,value,index)}else if(type==="bigint"){index=serializeBigInt(buffer2,key,value,index)}else if(type==="boolean"){index=serializeBoolean(buffer2,key,value,index)}else if(value instanceof Date||isDate(value)){index=serializeDate(buffer2,key,value,index)}else if(value===void 0){if(ignoreUndefined===false)index=serializeNull(buffer2,key,value,index)}else if(value===null){index=serializeNull(buffer2,key,value,index)}else if(isUint8Array(value)){index=serializeBuffer(buffer2,key,value,index)}else if(value instanceof RegExp||isRegExp(value)){index=serializeRegExp(buffer2,key,value,index)}else if(type==="object"&&value._bsontype==null){index=serializeObject(buffer2,key,value,index,checkKeys,depth,serializeFunctions,ignoreUndefined,path3)}else if(typeof value==="object"&&value[Symbol.for("@@mdb.bson.version")]!==BSON_MAJOR_VERSION){throw new BSONVersionError}else if(value._bsontype==="ObjectId"){index=serializeObjectId(buffer2,key,value,index)}else if(type==="object"&&value._bsontype==="Decimal128"){index=serializeDecimal128(buffer2,key,value,index)}else if(value._bsontype==="Long"||value._bsontype==="Timestamp"){index=serializeLong(buffer2,key,value,index)}else if(value._bsontype==="Double"){index=serializeDouble(buffer2,key,value,index)}else if(value._bsontype==="Code"){index=serializeCode(buffer2,key,value,index,checkKeys,depth,serializeFunctions,ignoreUndefined,path3)}else if(typeof value==="function"&&serializeFunctions){index=serializeFunction(buffer2,key,value,index)}else if(value._bsontype==="Binary"){index=serializeBinary(buffer2,key,value,index)}else if(value._bsontype==="BSONSymbol"){index=serializeSymbol(buffer2,key,value,index)}else if(value._bsontype==="DBRef"){index=serializeDBRef(buffer2,key,value,index,depth,serializeFunctions,path3)}else if(value._bsontype==="BSONRegExp"){index=serializeBSONRegExp(buffer2,key,value,index)}else if(value._bsontype==="Int32"){index=serializeInt32(buffer2,key,value,index)}else if(value._bsontype==="MinKey"||value._bsontype==="MaxKey"){index=serializeMinMax(buffer2,key,value,index)}else if(typeof value._bsontype!=="undefined"){throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`)}}}path3.delete(object);buffer2[index++]=0;const size=index-startingIndex;buffer2[startingIndex++]=size&255;buffer2[startingIndex++]=size>>8&255;buffer2[startingIndex++]=size>>16&255;buffer2[startingIndex++]=size>>24&255;return index}function isBSONType(value){return value!=null&&typeof value==="object"&&"_bsontype"in value&&typeof value._bsontype==="string"}var keysToCodecs={$oid:ObjectId2,$binary:Binary,$uuid:Binary,$symbol:BSONSymbol,$numberInt:Int32,$numberDecimal:Decimal128,$numberDouble:Double,$numberLong:Long,$minKey:MinKey,$maxKey:MaxKey,$regex:BSONRegExp,$regularExpression:BSONRegExp,$timestamp:Timestamp};function deserializeValue(value,options={}){if(typeof value==="number"){const in32BitRange=value<=BSON_INT32_MAX&&value>=BSON_INT32_MIN;const in64BitRange=value<=BSON_INT64_MAX&&value>=BSON_INT64_MIN;if(options.relaxed||options.legacy){return value}if(Number.isInteger(value)&&!Object.is(value,-0)){if(in32BitRange){return new Int32(value)}if(in64BitRange){if(options.useBigInt64){return BigInt(value)}return Long.fromNumber(value)}}return new Double(value)}if(value==null||typeof value!=="object")return value;if(value.$undefined)return null;const keys=Object.keys(value).filter(k=>k.startsWith("$")&&value[k]!=null);for(let i=0;i<keys.length;i++){const c=keysToCodecs[keys[i]];if(c)return c.fromExtendedJSON(value,options)}if(value.$date!=null){const d=value.$date;const date=new Date;if(options.legacy){if(typeof d==="number")date.setTime(d);else if(typeof d==="string")date.setTime(Date.parse(d));else if(typeof d==="bigint")date.setTime(Number(d));else throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`)}else{if(typeof d==="string")date.setTime(Date.parse(d));else if(Long.isLong(d))date.setTime(d.toNumber());else if(typeof d==="number"&&options.relaxed)date.setTime(d);else if(typeof d==="bigint")date.setTime(Number(d));else throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`)}return date}if(value.$code!=null){const copy=Object.assign({},value);if(value.$scope){copy.$scope=deserializeValue(value.$scope)}return Code.fromExtendedJSON(value)}if(isDBRefLike(value)||value.$dbPointer){const v=value.$ref?value:value.$dbPointer;if(v instanceof DBRef)return v;const dollarKeys=Object.keys(v).filter(k=>k.startsWith("$"));let valid=true;dollarKeys.forEach(k=>{if(["$ref","$id","$db"].indexOf(k)===-1)valid=false});if(valid)return DBRef.fromExtendedJSON(v)}return value}function serializeArray(array,options){return array.map((v,index)=>{options.seenObjects.push({propertyName:`index ${index}`,obj:null});try{return serializeValue(v,options)}finally{options.seenObjects.pop()}})}function getISOString(date){const isoStr=date.toISOString();return date.getUTCMilliseconds()!==0?isoStr:isoStr.slice(0,-5)+"Z"}function serializeValue(value,options){if(value instanceof Map||isMap(value)){const obj=Object.create(null);for(const[k,v]of value){if(typeof k!=="string"){throw new BSONError("Can only serialize maps with string keys")}obj[k]=v}return serializeValue(obj,options)}if((typeof value==="object"||typeof value==="function")&&value!==null){const index=options.seenObjects.findIndex(entry=>entry.obj===value);if(index!==-1){const props=options.seenObjects.map(entry=>entry.propertyName);const leadingPart=props.slice(0,index).map(prop=>`${prop} -> `).join("");const alreadySeen=props[index];const circularPart=" -> "+props.slice(index+1,props.length-1).map(prop=>`${prop} -> `).join("");const current=props[props.length-1];const leadingSpace=" ".repeat(leadingPart.length+alreadySeen.length/2);const dashes="-".repeat(circularPart.length+(alreadySeen.length+current.length)/2-1);throw new BSONError(`Converting circular structure to EJSON:
    ${leadingPart}${alreadySeen}${circularPart}${current}
    ${leadingSpace}\\${dashes}/`)}options.seenObjects[options.seenObjects.length-1].obj=value}if(Array.isArray(value))return serializeArray(value,options);if(value===void 0)return null;if(value instanceof Date||isDate(value)){const dateNum=value.getTime(),inRange=dateNum>-1&&dateNum<2534023188e5;if(options.legacy){return options.relaxed&&inRange?{$date:value.getTime()}:{$date:getISOString(value)}}return options.relaxed&&inRange?{$date:getISOString(value)}:{$date:{$numberLong:value.getTime().toString()}}}if(typeof value==="number"&&(!options.relaxed||!isFinite(value))){if(Number.isInteger(value)&&!Object.is(value,-0)){if(value>=BSON_INT32_MIN&&value<=BSON_INT32_MAX){return{$numberInt:value.toString()}}if(value>=BSON_INT64_MIN&&value<=BSON_INT64_MAX){return{$numberLong:value.toString()}}}return{$numberDouble:Object.is(value,-0)?"-0.0":value.toString()}}if(typeof value==="bigint"){if(!options.relaxed){return{$numberLong:BigInt.asIntN(64,value).toString()}}return Number(BigInt.asIntN(64,value))}if(value instanceof RegExp||isRegExp(value)){let flags=value.flags;if(flags===void 0){const match=value.toString().match(/[gimuy]*$/);if(match){flags=match[0]}}const rx=new BSONRegExp(value.source,flags);return rx.toExtendedJSON(options)}if(value!=null&&typeof value==="object")return serializeDocument(value,options);return value}var BSON_TYPE_MAPPINGS={Binary:o=>new Binary(o.value(),o.sub_type),Code:o=>new Code(o.code,o.scope),DBRef:o=>new DBRef(o.collection||o.namespace,o.oid,o.db,o.fields),Decimal128:o=>new Decimal128(o.bytes),Double:o=>new Double(o.value),Int32:o=>new Int32(o.value),Long:o=>Long.fromBits(o.low!=null?o.low:o.low_,o.low!=null?o.high:o.high_,o.low!=null?o.unsigned:o.unsigned_),MaxKey:()=>new MaxKey,MinKey:()=>new MinKey,ObjectId:o=>new ObjectId2(o),BSONRegExp:o=>new BSONRegExp(o.pattern,o.options),BSONSymbol:o=>new BSONSymbol(o.value),Timestamp:o=>Timestamp.fromBits(o.low,o.high)};function serializeDocument(doc,options){if(doc==null||typeof doc!=="object")throw new BSONError("not an object instance");const bsontype=doc._bsontype;if(typeof bsontype==="undefined"){const _doc={};for(const name of Object.keys(doc)){options.seenObjects.push({propertyName:name,obj:null});try{const value=serializeValue(doc[name],options);if(name==="__proto__"){Object.defineProperty(_doc,name,{value,writable:true,enumerable:true,configurable:true})}else{_doc[name]=value}}finally{options.seenObjects.pop()}}return _doc}else if(doc!=null&&typeof doc==="object"&&typeof doc._bsontype==="string"&&doc[Symbol.for("@@mdb.bson.version")]!==BSON_MAJOR_VERSION){throw new BSONVersionError}else if(isBSONType(doc)){let outDoc=doc;if(typeof outDoc.toExtendedJSON!=="function"){const mapper=BSON_TYPE_MAPPINGS[doc._bsontype];if(!mapper){throw new BSONError("Unrecognized or invalid _bsontype: "+doc._bsontype)}outDoc=mapper(outDoc)}if(bsontype==="Code"&&outDoc.scope){outDoc=new Code(outDoc.code,serializeValue(outDoc.scope,options))}else if(bsontype==="DBRef"&&outDoc.oid){outDoc=new DBRef(serializeValue(outDoc.collection,options),serializeValue(outDoc.oid,options),serializeValue(outDoc.db,options),serializeValue(outDoc.fields,options))}return outDoc.toExtendedJSON(options)}else{throw new BSONError("_bsontype must be a string, but was: "+typeof bsontype)}}function parse(text,options){const ejsonOptions={useBigInt64:options?.useBigInt64??false,relaxed:options?.relaxed??true,legacy:options?.legacy??false};return JSON.parse(text,(key,value)=>{if(key.indexOf("\0")!==-1){throw new BSONError(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`)}return deserializeValue(value,ejsonOptions)})}function stringify(value,replacer,space,options){if(space!=null&&typeof space==="object"){options=space;space=0}if(replacer!=null&&typeof replacer==="object"&&!Array.isArray(replacer)){options=replacer;replacer=void 0;space=0}const serializeOptions=Object.assign({relaxed:true,legacy:false},options,{seenObjects:[{propertyName:"(root)",obj:null}]});const doc=serializeValue(value,serializeOptions);return JSON.stringify(doc,replacer,space)}function EJSONserialize(value,options){options=options||{};return JSON.parse(stringify(value,options))}function EJSONdeserialize(ejson,options){options=options||{};return parse(JSON.stringify(ejson),options)}var EJSON=Object.create(null);EJSON.parse=parse;EJSON.stringify=stringify;EJSON.serialize=EJSONserialize;EJSON.deserialize=EJSONdeserialize;Object.freeze(EJSON);var MAXSIZE=1024*1024*17;var buffer=ByteUtils.allocate(MAXSIZE);function setInternalBufferSize(size){if(buffer.length<size){buffer=ByteUtils.allocate(size)}}function serialize(object,options={}){const checkKeys=typeof options.checkKeys==="boolean"?options.checkKeys:false;const serializeFunctions=typeof options.serializeFunctions==="boolean"?options.serializeFunctions:false;const ignoreUndefined=typeof options.ignoreUndefined==="boolean"?options.ignoreUndefined:true;const minInternalBufferSize=typeof options.minInternalBufferSize==="number"?options.minInternalBufferSize:MAXSIZE;if(buffer.length<minInternalBufferSize){buffer=ByteUtils.allocate(minInternalBufferSize)}const serializationIndex=serializeInto(buffer,object,checkKeys,0,0,serializeFunctions,ignoreUndefined,null);const finishedBuffer=ByteUtils.allocate(serializationIndex);finishedBuffer.set(buffer.subarray(0,serializationIndex),0);return finishedBuffer}function serializeWithBufferAndIndex(object,finalBuffer,options={}){const checkKeys=typeof options.checkKeys==="boolean"?options.checkKeys:false;const serializeFunctions=typeof options.serializeFunctions==="boolean"?options.serializeFunctions:false;const ignoreUndefined=typeof options.ignoreUndefined==="boolean"?options.ignoreUndefined:true;const startIndex=typeof options.index==="number"?options.index:0;const serializationIndex=serializeInto(buffer,object,checkKeys,0,0,serializeFunctions,ignoreUndefined,null);finalBuffer.set(buffer.subarray(0,serializationIndex),startIndex);return startIndex+serializationIndex-1}function deserialize(buffer2,options={}){return internalDeserialize(ByteUtils.toLocalBufferType(buffer2),options)}function calculateObjectSize(object,options={}){options=options||{};const serializeFunctions=typeof options.serializeFunctions==="boolean"?options.serializeFunctions:false;const ignoreUndefined=typeof options.ignoreUndefined==="boolean"?options.ignoreUndefined:true;return internalCalculateObjectSize(object,serializeFunctions,ignoreUndefined)}function deserializeStream(data,startIndex,numberOfDocuments,documents,docStartIndex,options){const internalOptions=Object.assign({allowObjectSmallerThanBufferSize:true,index:0},options);const bufferData=ByteUtils.toLocalBufferType(data);let index=startIndex;for(let i=0;i<numberOfDocuments;i++){const size=bufferData[index]|bufferData[index+1]<<8|bufferData[index+2]<<16|bufferData[index+3]<<24;internalOptions.index=index;documents[docStartIndex+i]=internalDeserialize(bufferData,internalOptions);index=index+size}return index}var bson=Object.freeze({__proto__:null,Code,BSONSymbol,DBRef,Binary,ObjectId:ObjectId2,UUID,Long,Timestamp,Double,Int32,MinKey,MaxKey,BSONRegExp,Decimal128,setInternalBufferSize,serialize,serializeWithBufferAndIndex,deserialize,calculateObjectSize,deserializeStream,BSONValue,BSONError,BSONVersionError,BSONRuntimeError,BSONType,EJSON});exports2.BSON=bson;exports2.BSONError=BSONError;exports2.BSONRegExp=BSONRegExp;exports2.BSONRuntimeError=BSONRuntimeError;exports2.BSONSymbol=BSONSymbol;exports2.BSONType=BSONType;exports2.BSONValue=BSONValue;exports2.BSONVersionError=BSONVersionError;exports2.Binary=Binary;exports2.Code=Code;exports2.DBRef=DBRef;exports2.Decimal128=Decimal128;exports2.Double=Double;exports2.EJSON=EJSON;exports2.Int32=Int32;exports2.Long=Long;exports2.MaxKey=MaxKey;exports2.MinKey=MinKey;exports2.ObjectId=ObjectId2;exports2.Timestamp=Timestamp;exports2.UUID=UUID;exports2.calculateObjectSize=calculateObjectSize;exports2.deserialize=deserialize;exports2.deserializeStream=deserializeStream;exports2.serialize=serialize;exports2.serializeWithBufferAndIndex=serializeWithBufferAndIndex;exports2.setInternalBufferSize=setInternalBufferSize}});var graphscript_node_exports={};__export(graphscript_node_exports,{AuthorizationStruct:()=>AuthorizationStruct,CMDService:()=>CMDService,Callable:()=>Callable,ChatroomStruct:()=>ChatroomStruct,CoherenceMap:()=>CoherenceMap,CoherenceStruct:()=>CoherenceStruct,CommentStruct:()=>CommentStruct,DS:()=>DataStructures_exports,Data:()=>Data,DataStruct:()=>DataStruct,DataTablet:()=>DataTablet,DateStruct:()=>DateStruct,E2EEService:()=>E2EEService,ECGStruct:()=>ECGStruct,EDAStruct:()=>EDAStruct,EEGCoordinates:()=>EEGCoordinates,EEGStruct:()=>EEGStruct,EMGStruct:()=>EMGStruct,EventHandler:()=>EventHandler,EventStruct:()=>EventStruct,EyeTrackerStruct:()=>EyeTrackerStruct,FNIRSStruct:()=>FNIRSStruct,FrequencyBandsStruct:()=>FrequencyBandsStruct,Graph:()=>Graph,GraphNode:()=>GraphNode,GroupStruct:()=>GroupStruct,HRVStruct:()=>HRVStruct,HTTPbackend:()=>HTTPbackend,IMUStruct:()=>IMUStruct,NotificationStruct:()=>NotificationStruct,PPGStruct:()=>PPGStruct,ProfileStruct:()=>ProfileStruct,Router:()=>Router,SSEbackend:()=>SSEbackend,ScheduleStruct:()=>ScheduleStruct,Service:()=>Service,SessionsService:()=>SessionsService,Struct:()=>Struct,StructBackend:()=>StructBackend,StructFrontend:()=>StructFrontend,WSSbackend:()=>WSSbackend,animate:()=>animate,backprop:()=>backprop,bindListener:()=>bindListener,branching:()=>branching,connectionHasId:()=>connectionHasId,defaultCollections:()=>defaultCollections,defaultManifest:()=>defaultManifest,defaultServiceWorker:()=>defaultServiceWorker,defaultSpecifiers:()=>defaultSpecifiers,eegCoordinates:()=>eegCoordinates,genTimeSpecifiers:()=>genTimeSpecifiers,genTimestampFromString:()=>genTimestampFromString,getAllProperties:()=>getAllProperties,getCallbackFromString:()=>getCallbackFromString,getFnParamNames:()=>getFnParamNames,getFunctionHead:()=>getFunctionHead,getStringId:()=>getStringId,htmlBodyBoilerPlate:()=>htmlBodyBoilerPlate,instanceObject:()=>instanceObject,isFunction:()=>isFunction,isNativeClass:()=>isNativeClass,isTypedArray:()=>isTypedArray,loaders:()=>loaders,loop:()=>loop,methodstrings:()=>methodstrings,parseFunctionFromText:()=>parseFunctionFromText,pseudoObjectId:()=>pseudoObjectId,randomId:()=>randomId,reconstructObject:()=>reconstructObject,recursivelyAssign:()=>recursivelyAssign2,recursivelyStringifyFunctions:()=>recursivelyStringifyFunctions,scriptBoilerPlate:()=>scriptBoilerPlate,setCoordinate:()=>setCoordinate,spliceTypedArray:()=>spliceTypedArray,state:()=>state,stringifyFast:()=>stringifyFast,stringifyWithCircularRefs:()=>stringifyWithCircularRefs,stringifyWithFunctionsAndCircularRefs:()=>stringifyWithFunctionsAndCircularRefs,structRegistry:()=>structRegistry,substitute__operator:()=>substitute__operator,toObjectId:()=>toObjectId,transformListenerResult:()=>transformListenerResult,triggerListenerOncreate:()=>triggerListenerOncreate,wrapArgs:()=>wrapArgs});module.exports=__toCommonJS(graphscript_node_exports);var EventHandler=class{data={};triggers={};ctr=0;constructor(data){if(typeof data==="object")this.data=data}setState=updateObj=>{Object.assign(this.data,updateObj);let props=Object.getOwnPropertyNames(updateObj);for(const prop of props){this.triggerEvent(prop,this.data[prop])}if(this.triggers[statesubKey]){let run=fn=>{fn(updateObj)};const l=this.triggers[statesubKey].length;for(let i=l-1;i>=0;i--){run(this.triggers[statesubKey][i].onchange)}}return this.data};setValue=(key,value)=>{this.data[key]=value;this.triggerEvent(key,value)};triggerEvent=(key,value)=>{if(this.triggers[key]){let fn=obj=>{obj.onchange(value)};const l=this.triggers[key].length;for(let i=l-1;i>=0;i--){fn(this.triggers[key][i])}}};subscribeState=onchange=>{return this.subscribeEvent(statesubKey,onchange)};unsubscribeState=sub=>{return this.unsubscribeEvent(statesubKey,sub)};subscribeEvent=(key,onchange,refObject,refKey)=>{if(key){if(refObject&&refKey&&!this.triggers[key]){Object.defineProperty(this.data,key,{get:()=>{return refObject[refKey]},set:value=>{refObject[refKey]=value},enumerable:true,configurable:true})}if(!this.triggers[key]){this.triggers[key]=[]}let l=this.ctr;this.ctr++;this.triggers[key].push({sub:l,onchange});return l}else return void 0};unsubscribeEvent=(key,sub)=>{let triggers=this.triggers[key];if(triggers){if(sub===void 0){delete this.triggers[key];delete this.data[key]}else{let idx=void 0;let obj=triggers.find((o,i)=>{if(o.sub===sub){idx=i;return true}});if(obj)triggers.splice(idx,1);if(Object.keys(triggers).length===0){delete this.triggers[key];delete this.data[key]}if(this.onRemoved)this.onRemoved(obj);return true}}};subscribeEventOnce=(key,onchange)=>{let sub;let changed=value=>{onchange(value);this.unsubscribeEvent(key,sub)};sub=this.subscribeEvent(key,changed);return sub};getEvent=(key,sub)=>{if(typeof sub!=="number")return this.triggers[key];for(const s in this.triggers[key]){if(this.triggers[key][s].sub===sub)return this.triggers[key][s]}};getSnapshot=()=>{const snapshot={};for(const key in this.data){snapshot[key]=this.data[key]}};onRemoved};var statesubKey="*s";var state=new EventHandler;var Callable=class extends Function{__bound;__call;constructor(){super("return this.__bound.__call.apply(this.__bound, arguments)");this.__bound=this.bind(this);return this.__bound}};var GraphNode=class _GraphNode{__node={tag:`node${Math.floor(Math.random()*1e15)}`,unique:`${Math.floor(Math.random()*1e15)}`,state};__children;__parent;__operator;__listeners;__props;__args;constructor(properties,parent,graph){this.__setProperties(properties,parent,graph);if(typeof properties==="function"||properties?.__callable){const callableInstance=new Callable;callableInstance.__call=(...args)=>this.__operator(...args);const proxy=new Proxy(callableInstance,{get:(target,prop,receiver)=>{if(Reflect.has(this,prop)){return Reflect.get(this,prop,receiver)}return Reflect.get(target,prop,receiver)},set:(target,prop,value,receiver)=>{if(Reflect.has(this,prop)){return Reflect.set(this,prop,value,receiver)}return Reflect.set(target,prop,value,receiver)}});Object.setPrototypeOf(proxy,this);return proxy}}get __graph(){return this.__node?.graph}set __graph(graph){this.__node.graph=graph}__setProperties=(properties,parent,graph)=>{let enforceProperties=()=>{let orig=properties;if(typeof properties==="function"){if(isNativeClass(properties)){properties=new properties}else properties={__operator:properties,__node:{forward:true,tag:properties.name}}}else if(typeof properties==="string"){if(graph?.get(properties)){properties=graph.get(properties)}}if(!("__node"in properties))properties.__node={};if(!properties.__node.initial)properties.__node.initial=orig};enforceProperties();if(typeof properties==="object"){let assignState=()=>{if(properties.__node?.state)this.__node.state=properties.__node.state;else if(graph){properties.__node.state=graph.__node.state}};let setProps=()=>{if(properties.__props){if(typeof properties.__props==="function")properties.__props=new properties.__props;if(typeof properties.__props==="object"){this.__proxyObject(properties.__props)}}};let setTag=()=>{if(!properties.__node.tag){if(properties.__operator?.name)properties.__node.tag=properties.__operator.name;else properties.__node.tag=`node${Math.floor(Math.random()*1e15)}`}};let setNode=()=>{if(typeof properties.__node==="string"){if(graph?.get(properties.__node.tag)){properties=graph.get(properties.__node.tag)}else properties.__node={}}else if(!properties.__node)properties.__node={};if(graph){properties.__node.graph=graph}if(properties instanceof Graph)properties.__node.source=properties};let setParent=()=>{if(!properties.__parent&&parent)properties.__parent=parent;if(parent?.__node&&!(parent instanceof Graph||properties instanceof Graph))properties.__node.tag=parent.__node.tag+"."+properties.__node.tag;if(parent instanceof Graph&&properties instanceof Graph){if(properties.__node.loaders)Object.assign(parent.__node.loaders?parent.__node.loaders:{},properties.__node.loaders);if(parent.__node.mapGraphs){properties.__node.nodes.forEach(n=>{parent.set(properties.__node.tag+"."+n.__node.tag,n)});let ondelete=()=>{properties.__node.nodes.forEach(n=>{parent.__node.nodes.delete(properties.__node.tag+"."+n.__node.tag)})};this.__addOndisconnected(ondelete)}}};let setOp=()=>{if(typeof properties.default==="function"&&!properties.__operator){properties.__operator=properties.default}if(properties.__operator){if(typeof properties.__operator==="string"){if(graph){let n=graph.get(properties.__operator);if(n)properties.__operator=n.__operator;if(!properties.__node.tag&&properties.__operator.name)properties.__node.tag=properties.__operator.name}}if(typeof properties.__operator==="function")properties.__operator=this.__setOperator(properties.__operator);if(properties.default)properties.default=properties.__operator}};let assignProps=()=>{properties.__node=Object.assign(this.__node,properties.__node);let keys=Object.getOwnPropertyNames(properties).filter(v=>{if(!objProps[v])return true});for(const key of keys){if(key in properties&&key!=="name")this[key]=properties[key]}};let bindCallbacks=()=>{if(this.__onconnected){if(typeof this.__onconnected==="function"){this.__onconnected=this.__onconnected.bind(this)}else if(Array.isArray(this.__onconnected)){this.__onconnected=this.__onconnected.map(f=>{return f.bind(this)})}if(typeof this.__ondisconnected==="function"){this.__ondisconnected=this.__ondisconnected.bind(this)}else if(Array.isArray(this.__ondisconnected)){this.__ondisconnected=this.__ondisconnected.map(f=>{return f.bind(this)})}}};assignState();setTag();setProps();setNode();setParent();assignProps();bindCallbacks();setOp()}};__subscribe=(callback,key,subInput,target,tkey,args,callbackStr)=>{const subscribeToFunction=(k,setTarget=(callback2,target2)=>target2?target2:callback2,triggerCallback=callback)=>{let wrappedArgs;if(args){let wrapped=wrapArgs(triggerCallback,args,this.__node.graph);triggerCallback=wrapped.__callback;wrappedArgs=wrapped.__args}let sub=this.__node.state.subscribeEvent(k,triggerCallback,this,key);let trigger=this.__node.state.getEvent(k,sub);if(!this.__listeners)this.__listeners={};this.__listeners[k]=this.__node.state.triggers[k];if(!trigger)return sub;trigger.source=this.__node.tag;if(key)trigger.key=key;trigger.target=setTarget(callback,target);if(tkey)trigger.tkey=tkey;if(subInput)trigger.subInput=subInput;if(args){trigger.arguments=wrappedArgs;trigger.__args=args}if(callbackStr)trigger.__callback=callbackStr;trigger.node=this;trigger.graph=this.__node.graph;return sub};const getCallbackFromGraph=callback2=>{let fn=this.__node.graph.get(callback2);if(!fn&&callback2.includes(".")){target=callback2.substring(0,callback2.lastIndexOf("."));let n=this.__node.graph.get(callback2.substring(0,target));tkey=callback2.lastIndexOf(".")+1;if(n&&typeof n[key]==="function")callback2=(...args2)=>{return n[tkey](...args2)}}else if(fn.__operator){callback2=fn.__operator;tkey="__operator"}return callback2};if(key){if(!this.__node.localState||!this.__node.localState[key]){this.__addLocalState(this,key)}if(typeof callback==="string"){callbackStr=this.__node.tag+"."+callback;tkey=callback;if(target){if(this.__node.graph?.get(target)){let n=this.__node.graph?.get(target);if(typeof n[callback]==="function"){let fn=n[callback];callback=(...inp)=>{fn(...inp)}}else{let k2=callback;let setter=inp=>{n[k2]=inp};callback=setter}}}else if(typeof this[callback]==="function"){let fn=this[callback];callback=(...inp)=>{fn(...inp)}}else if(this.__node.graph?.get(callback))callback=getCallbackFromGraph(callback);if(typeof callback!=="function")return void 0}let sub;let k=subInput?this.__node.unique+"."+key+"input":this.__node.unique+"."+key;if(typeof callback==="function"&&!callback?.__node)sub=subscribeToFunction(k,(callback2,target2)=>target2?target2:callback2,callback);else if(callback?.__node)sub=subscribeToFunction(k,(callback2,target2)=>target2?target2:callback2.__node.unique,(...inp)=>{if(callback.__operator)callback.__operator(...inp)});return sub}else{if(typeof callback==="string"){callbackStr=callback;if(!target)target=callback;if(this.__node.graph.get(callback))callback=this.__node.graph.get(callback);tkey="__operator";if(typeof callback!=="object")return void 0}let sub;let k=subInput?this.__node.unique+"input":this.__node.unique;if(typeof callback==="function"&&!callback?.__node)sub=subscribeToFunction(k,(callback2,target2)=>target2?target2:callback2,callback);else if(callback?.__node){sub=subscribeToFunction(k,(callback2,target2)=>target2?target2:callback2.__node.unique,(...inp)=>{if(callback.__operator)callback.__operator(...inp)})}return sub}};__unsubscribe=(sub,key,unsubInput)=>{if(key){return this.__node.state.unsubscribeEvent(unsubInput?this.__node.unique+"."+key+"input":this.__node.unique+"."+key,sub)}else return this.__node.state.unsubscribeEvent(unsubInput?this.__node.unique+"input":this.__node.unique,sub)};__setOperator=fn=>{fn=fn.bind(this);if(this.__args&&this.__node.graph){fn=wrapArgs(fn,this.__args,this.__node.graph).__callback}let inpstr=`${this.__node.unique}input`;this.__operator=(...args)=>{if(this.__node.state.triggers[inpstr])this.__node.state.setValue(inpstr,args);let result=fn(...args);if(this.__node.state.triggers[this.__node.unique]){if(typeof result?.then==="function"){result.then(res=>{if(res!==void 0)this.__node.state.setValue(this.__node.unique,res)}).catch(console.error)}else if(result!==void 0)this.__node.state.setValue(this.__node.unique,result)}return result};if(this.__parent instanceof _GraphNode&&!this.__subscribedToParent){if(this.__parent.__operator){let sub=this.__parent.__subscribe(this);let ondelete=()=>{this.__parent?.__unsubscribe(sub);delete this.__subscribedToParent};this.__addOndisconnected(ondelete);this.__subscribedToParent=true}}return this.__operator};__addLocalState=(props,key)=>{if(!props)return;if(!this.__node.localState){this.__node.localState={}}const localState=this.__node.localState;const initState=(props2,k)=>{let str=this.__node.unique+"."+k;let inpstr=`${str}input`;let get,set;let obj,descriptor;if(typeof props2[k]==="function"&&k!=="__operator"){if(this.__props?.[k]){obj=this.__props}else{obj=localState}get=()=>{return obj[k]};set=fn=>{if(!this.__props?.[k])fn=fn.bind(this);obj[k]=(...args)=>{if(this.__node.state.triggers[inpstr])this.__node.state.setValue(inpstr,args);let result=fn(...args);if(this.__node.state.triggers[str]){if(typeof result?.then==="function"){result.then(res=>{this.__node.state.triggerEvent(str,res)}).catch(console.error)}else this.__node.state.triggerEvent(str,result)}return result}};localState[k]=props2[k].bind(this);descriptor={get,set,enumerable:true,configurable:true}}else if(k!=="__graph"){let get2,set2;let obj2;if(this.__props?.[k]){obj2=this.__props}else{obj2=localState}get2=()=>{return obj2[k]};set2=v=>{obj2[k]=v;if(this.__node.state.triggers[str])this.__node.state.triggerEvent(str,v)};localState[k]=props2[k];descriptor={get:get2,set:set2,enumerable:true,configurable:true}}Object.defineProperty(props2,k,descriptor);if(typeof this.__node.initial==="object"){let dec=Object.getOwnPropertyDescriptor(this.__node.initial,k);if(dec===void 0||dec?.configurable){Object.defineProperty(this.__node.initial,k,descriptor)}}};if(key)initState(props,key);else{for(let k in props){initState(props,k)}}};__proxyObject=obj=>{const allProps=getAllProperties(obj);for(const k of allProps){const descriptor={get:()=>{return obj[k]},set:value=>{obj[k]=value},enumerable:true,configurable:true};Object.defineProperty(this,k,descriptor);if(typeof this.__node.initial==="object"){let dec=Object.getOwnPropertyDescriptor(this.__node.initial,k);if(dec===void 0||dec?.configurable){Object.defineProperty(this.__node.initial,k,descriptor)}}}};__addOnconnected(callback){callback=callback.bind(this);if(Array.isArray(this.__onconnected)){this.__onconnected.push(callback)}else if(typeof this.__onconnected==="function"){this.__onconnected=[callback,this.__onconnected]}else this.__onconnected=callback}__addOndisconnected(callback){callback=callback.bind(this);if(Array.isArray(this.__ondisconnected)){this.__ondisconnected.push(callback)}else if(typeof this.__ondisconnected==="function"){this.__ondisconnected=[callback,this.__ondisconnected]}else this.__ondisconnected=callback}__callConnected(node=this){if(typeof this.__onconnected==="function"){this.__onconnected(this)}else if(Array.isArray(this.__onconnected)){let fn=o=>{o(this)};this.__onconnected.forEach(fn)}}__callDisconnected(node=this){if(typeof this.__ondisconnected==="function")this.__ondisconnected(this);else if(Array.isArray(this.__ondisconnected)){let fn=o=>{o(this)};this.__ondisconnected.forEach(fn)}}};var Graph=class _Graph{__node={tag:`graph${Math.floor(Math.random()*1e15)}`,unique:`${Math.random()}`,nodes:new Map,state,roots:{}};constructor(options){this.init(options)}init=options=>{if(options){let cpy=Object.assign({},options);delete cpy.roots;recursivelyAssign(this.__node,cpy);if(options.roots)this.load(options.roots)}};load=(roots,overwrite=false)=>{function recursivelyAssignChildren(target,obj,inChildren=true,top=true){if(top){if(!target)target={};for(const key in obj){if(!key.startsWith("__")&&obj[key]&&typeof obj[key]==="object"){target[key]=obj[key];if(obj[key]?.__children){recursivelyAssignChildren({},obj[key].__children,false,false)}}else if(typeof obj[key]==="function")target[key]=obj[key]}recursivelyAssignChildren(target,obj,true,false)}else{if(obj?.__children&&!inChildren){if(obj.__children?.constructor.name==="Object"){if(target.__children?.constructor.name==="Object")target.__children=recursivelyAssignChildren(target.__children,obj.__children,true,false);else target.__children=recursivelyAssignChildren({},obj.__children,true,false)}else{target.__children=obj.__children}}else if(inChildren){for(const key in obj){if(!key.startsWith("__")&&obj[key]&&typeof obj[key]==="object"){target[key]=Object.assign({},obj[key]);if(obj[key]?.__children){target[key].__children=recursivelyAssignChildren({},obj[key].__children,false,false)}}else if(typeof obj[key]==="function")target[key]=obj[key]}}}return target}this.__node.roots=recursivelyAssignChildren(this.__node.roots?this.__node.roots:{},roots);let cpy=Object.assign({},roots);if(cpy.__node)delete cpy.__node;let listeners=this.recursiveSet(cpy,this,void 0,roots,overwrite);if(roots.__node){if(!roots.__node.tag)roots.__node._tag=`roots${Math.floor(Math.random()*1e15)}`;else if(!this.get(roots.__node.tag)){let node=new GraphNode(roots,this,this);this.set(node.__node.tag,node);this.runLoaders(node,this,roots,roots.__node.tag);if(node.__listeners){listeners[node.__node.tag]=node.__listeners}}}else if(roots.__listeners){this.setListeners(roots.__listeners)}this.setListeners(listeners);return cpy};setLoaders=(loaders2,replace)=>{if(replace)this.__node.loaders=loaders2;else Object.assign(this.__node.loaders,loaders2);return this.__node.loaders};runLoaders=(node,parent,properties,key)=>{for(const l in this.__node.loaders){if(typeof this.__node.loaders[l]==="object"){if(this.__node.loaders[l].init)this.__node.loaders[l](node,parent,this,this.__node.roots,properties,key);if(this.__node.loaders[l].connected)node.__addOnconnected(this.__node.loaders[l].connect);if(this.__node.loaders[l].disconnected)node.__addOndisconnected(this.__node.loaders[l].disconnect)}else if(typeof this.__node.loaders[l]==="function")this.__node.loaders[l](node,parent,this,this.__node.roots,properties,key)}};add=(properties,parent,overwrite=true)=>{let listeners={};if(typeof parent==="string")parent=this.get(parent);let instanced;if(typeof properties==="function"){if(isNativeClass(properties)){if(properties.prototype instanceof GraphNode){properties=properties.prototype.constructor(properties,parent,this);instanced=true}else properties=new properties}else properties={__operator:properties,__callable:true}}else if(typeof properties==="string"){properties=this.__node.roots[properties]}if(!properties)return;if(!instanced){let keys=Object.getOwnPropertyNames(properties);let nonArrowFunctions=Object.getOwnPropertyNames(Object.getPrototypeOf(properties));keys.push(...nonArrowFunctions);keys=keys.filter(v=>!objProps.includes(v));let cpy={};for(const key of keys){cpy[key]=properties[key]}properties=cpy}if(!properties.__node)properties.__node={};properties.__node.initial=properties;if(typeof properties==="object"&&this.get(properties.__node.tag)){if(overwrite)this.remove(properties.__node.tag,true);else return}else if(properties.__node.tag&&this.get(properties.__node.tag))return this.get(properties.__node.tag);let node;let root=recursivelyAssign({},properties,2);if(instanced)node=properties;else node=new GraphNode(properties,parent,this);this.set(node.__node.tag,node);this.runLoaders(node,parent,properties,node.__node.tag);this.__node.roots[node.__node.tag]=root;if(node.__children){node.__children=Object.assign({},node.__children);this.recursiveSet(node.__children,node,listeners,node.__children)}if(node.__listeners){listeners[node.__node.tag]=Object.assign({},node.__listeners);for(const key in node.__listeners){let listener=node.__listeners[key];if(node[key]){delete listeners[node.__node.tag][key];listeners[node.__node.tag][node.__node.tag+"."+key]=listener}if(typeof listener==="string"){if(node.__children?.[listener]){listeners[node.__node.tag][key]=node.__node.tag+"."+listener}else if(parent instanceof GraphNode&&(parent.__node.tag===listener||parent.__node.tag.includes(".")&&parent.__node.tag.split(".").pop()===listener)){listeners[node.__node.tag][key]=parent.__node.tag}}}}this.setListeners(listeners);node.__callConnected();return node};recursiveSet=(originCpy,parent,listeners={},origin,overwrite=false)=>{let keys=Object.getOwnPropertyNames(origin).filter(v=>!objProps.includes(v));let nonArrowFunctions=Object.getOwnPropertyNames(Object.getPrototypeOf(origin)).filter(v=>!objProps.includes(v));keys.push(...nonArrowFunctions);for(const key of keys){if(key.includes("__"))continue;let p=origin[key];if(Array.isArray(p))continue;let instanced;if(typeof p==="function"){if(isNativeClass(p)){p=new p;if(p instanceof GraphNode){p=p.prototype.constructor(p,parent,this);instanced=true}}else p={__operator:p,__callable:true}}else if(typeof p==="string"){if(this.__node.nodes.get(p))p=this.__node.nodes.get(p);else p=this.__node.roots[p]}else if(typeof p==="boolean"){if(this.__node.nodes.get(key))p=this.__node.nodes.get(key);else p=this.__node.roots[key]}if(p&&typeof p==="object"){if(!instanced&&!(p instanceof GraphNode)){let ks=Object.getOwnPropertyNames(p).filter(v=>!objProps.includes(v));let nonArrowFunctions2=Object.getOwnPropertyNames(Object.getPrototypeOf(p)).filter(v=>!objProps.includes(v));nonArrowFunctions2.splice(nonArrowFunctions2.indexOf("constructor"),1);ks.push(...nonArrowFunctions2);let cpy={};for(const key2 of ks){cpy[key2]=p[key2]}p=cpy}if(!p.__node)p.__node={};if(!p.__node.tag)p.__node.tag=key;if(!p.__node.initial)p.__node.initial=originCpy[key];if(overwrite&&this.get(p.__node.tag)){this.remove(p.__node.tag,true)}else if(this.get(p.__node.tag)&&!(!(parent instanceof _Graph)&&parent?.__node)||parent?.__node&&this.get(parent.__node.tag+"."+p.__node.tag))continue;let node;let newnode=false;let root=recursivelyAssign({},p,2);if(instanced||p instanceof GraphNode){node=p}else{node=new GraphNode(p,parent,this);newnode=true}if(!newnode&&p instanceof GraphNode&&!instanced&&parent instanceof GraphNode){let sub=this.subscribe(parent.__node.tag,node.__node.tag);let ondelete=node2=>{this.unsubscribe(parent.__node.tag,sub)};node.__addOndisconnected(ondelete)}else if(node){this.set(node.__node.tag,node);this.runLoaders(node,parent,originCpy[key],key);originCpy[key]=node;this.__node.roots[node.__node.tag]=root;if(node.__children){node.__children=Object.assign({},node.__children);this.recursiveSet(node.__children,node,listeners,node.__children)}if(node.__listeners){listeners[node.__node.tag]=Object.assign({},node.__listeners);for(const key2 in node.__listeners){let listener=node.__listeners[key2];let k=key2;if(node[key2]){delete listeners[node.__node.tag][key2];k=node.__node.tag+"."+key2;listeners[node.__node.tag][k]=listener}if(typeof listener==="string"){if(node.__children?.[listener]){listeners[node.__node.tag][k]=node.__node.tag+"."+listener}else if(parent instanceof GraphNode&&(parent.__node.tag===listener||parent.__node.tag.includes(".")&&parent.__node.tag.split(".").pop()===listener)){listeners[node.__node.tag][k]=parent.__node.tag}}}}node.__callConnected()}}}return listeners};remove=(node,clearListeners=true)=>{this.unsubscribe(node);if(typeof node==="string")node=this.get(node);if(node instanceof GraphNode){this.delete(node.__node.tag);delete this.__node.roots[node.__node.tag];if(clearListeners){this.clearListeners(node)}node.__callDisconnected();const recursiveRemove=t2=>{for(const key in t2){this.unsubscribe(t2[key]);this.delete(t2[key].__node.tag);delete this.__node.roots[t2[key].__node.tag];this.delete(key);delete this.__node.roots[key];t2[key].__node.tag=t2[key].__node.tag.substring(t2[key].__node.tag.lastIndexOf(".")+1);if(clearListeners){this.clearListeners(t2[key])}t2[key].__callDisconnected();if(t2[key].__children){recursiveRemove(t2[key].__children)}}};if(node.__children){recursiveRemove(node.__children)}}if(node?.__node.tag&&node?.__parent){delete node?.__parent;node.__node.tag=node.__node.tag.substring(node.__node.tag.indexOf(".")+1)}if(node?.__node.graph)node.__node.graph=void 0;return node};run=(node,...args)=>{if(typeof node==="string"){let nd=this.get(node);if(!nd&&node.includes(".")){nd=this.get(node.substring(0,node.lastIndexOf(".")));if(typeof nd?.[node.substring(node.lastIndexOf(".")+1)]==="function")return nd[node.substring(node.lastIndexOf(".")+1)](...args)}else if(nd?.__operator)return nd.__operator(...args)}if(node?.__operator){return node?.__operator(...args)}};setListeners=listeners=>{for(const key in listeners){let node=this.get(key);if(typeof listeners[key]==="object"){for(const k in listeners[key]){let n=this.get(k);let sub;if(typeof listeners[key][k]!=="object")listeners[key][k]={__callback:listeners[key][k]};else if(!listeners[key][k].__callback){for(const kk in listeners[key][k]){if(typeof listeners[key][k][kk]!=="object"){listeners[key][k][kk]={__callback:listeners[key][k][kk]};if(node.__operator&&(listeners[key][k][kk].__callback===true||typeof listeners[key][k][kk].__callback==="undefined"))listeners[key][k][kk].__callback=node.__operator}let nn=this.get(kk);if(!nn){let tag=k.substring(0,k.lastIndexOf("."));nn=this.get(tag);if(nn){let prop=k.substring(k.lastIndexOf(".")+1);sub=this.subscribe(nn,listeners[key][k][kk].__callback,listeners[key][k][kk].__args,prop,listeners[key][k][kk].subInput,key)}}else{sub=this.subscribe(nn,listeners[key][k][kk].__callback,listeners[key][k][kk].__args,void 0,listeners[key][k][kk].subInput,key)}}}if("__callback"in listeners[key][k]){if(node){if(listeners[key][k].__callback===true||typeof listeners[key][k].__callback==="undefined")listeners[key][k].__callback=node.__operator;if(typeof listeners[key][k].__callback==="function")listeners[key][k].__callback=listeners[key][k].__callback.bind(node)}if(!n){let tag=k.substring(0,k.lastIndexOf("."));n=this.get(tag);if(n){sub=this.subscribe(n,listeners[key][k].__callback,listeners[key][k].__args,k.substring(k.lastIndexOf(".")+1),listeners[key][k].subInput,key)}}else{sub=this.subscribe(n,listeners[key][k].__callback,listeners[key][k].__args,void 0,listeners[key][k].subInput,key)}}}}}};clearListeners=(node,listener)=>{if(typeof node==="string")node=this.get(node);if(node?.__listeners){for(const key in node.__listeners){if(listener&&key!==listener)continue;if(typeof node.__listeners[key]?.sub!=="number")continue;let n=this.get(key);if(!n){n=this.get(key.substring(0,key.lastIndexOf(".")));if(n){if(typeof node.__listeners[key]==="object"&&!node.__listeners[key]?.__callback){for(const k in node.__listeners[key]){if(typeof node.__listeners[key][k]?.sub==="number"){this.unsubscribe(n,node.__listeners[key][k].sub,key.substring(key.lastIndexOf(".")+1),node.__listeners[key][k].subInput);node.__listeners[key][k].sub=void 0}}}else if(typeof node.__listeners[key]?.sub==="number"){this.unsubscribe(n,node.__listeners[key].sub,key.substring(key.lastIndexOf(".")+1),node.__listeners[key].subInput);node.__listeners[key].sub=void 0}}}else{if(typeof!node.__listeners[key]?.__callback==="number"){for(const k in node.__listeners[key]){if(node.__listeners[key][k]?.sub){this.unsubscribe(n,node.__listeners[key][k].sub,void 0,node.__listeners[key][k].subInput);node.__listeners[key][k].sub=void 0}}}else if(typeof node.__listeners[key]?.sub==="number"){this.unsubscribe(n,node.__listeners[key].sub,void 0,node.__listeners[key].subInput);node.__listeners[key].sub=void 0}}}}};get=tag=>{return this.__node.nodes.get(tag)};getByUnique=unique=>{return Array.from(this.__node.nodes.values()).find(node=>{if(node.__node.unique===unique)return true})};set=(tag,node)=>{return this.__node.nodes.set(tag,node)};delete=tag=>{return this.__node.nodes.delete(tag)};list=()=>{return Array.from(this.__node.nodes.keys())};getListener=(nodeTag,key,sub)=>{let node=this.get(nodeTag);if(node){let k=node.__node.unique;if(key){k+="."+key}return this.__node.state.getEvent(k,sub)}};getProps=(node,getInitial)=>{if(typeof node==="string")node=this.get(node);if(node instanceof GraphNode){let cpy;if(getInitial)cpy=Object.assign({},this.__node.roots[node.__node.tag]);else{cpy=Object.assign({},node);for(const key in cpy){if(key.includes("__"))delete cpy[key]}}}};subscribe=(nodeEvent,onEvent,args,key,subInput,target,tkey)=>{let nd=nodeEvent;if(typeof nodeEvent==="string"){nd=this.get(nodeEvent);if(!nd&&nodeEvent.includes(".")){nd=this.get(nodeEvent.substring(0,nodeEvent.lastIndexOf(".")));key=nodeEvent.substring(nodeEvent.lastIndexOf(".")+1)}}if(target instanceof GraphNode)target=target.__node.tag;let callbackStr;if(typeof onEvent==="string"){callbackStr=onEvent;let setOnEventFromString=onEvent2=>{if(this.get(onEvent2)?.__operator){let node=this.get(onEvent2);target=onEvent2;onEvent2=function(...inp){return node.__operator(...inp)}}else if(onEvent2.includes(".")){target=onEvent2.substring(0,onEvent2.lastIndexOf("."));let n=this.get(target);let k=onEvent2.substring(onEvent2.lastIndexOf(".")+1);tkey=k;if(typeof n[k]==="function"){if(n[k]instanceof GraphNode)onEvent2=n[k];else onEvent2=function(...inp){return n[k](...inp)}}else{onEvent2=function(inp){n[k]=inp;return n[k]}}}return onEvent2};if(target){let node=this.get(target);if(typeof node?.[onEvent]==="function"){tkey=onEvent;onEvent=function(...inp){return node[key](...inp)}}else if(node?.[key]){tkey=key;if(node[key]instanceof GraphNode)onEvent=node[key];else onEvent=function(inp){node[key]=inp;return node[key]}}else{onEvent=setOnEventFromString(onEvent)}}else{onEvent=setOnEventFromString(onEvent)}}let sub;if(nd instanceof GraphNode){const doSub=()=>{sub=nd.__subscribe(onEvent,key,subInput,target,tkey,args,callbackStr);let ondelete=()=>{if(sub!==void 0)nd.__unsubscribe(sub,key,subInput);sub=void 0};nd.__addOndisconnected(()=>{ondelete();nd.__addOnconnected(()=>{if(sub===void 0&&nd.__node.graph.__node.tag===this.__node.tag)doSub()})});if(typeof onEvent==="string"&&this.get(onEvent))onEvent=this.get(onEvent);if(onEvent instanceof GraphNode){onEvent.__addOndisconnected(()=>{ondelete()})}};doSub()}else if(typeof nodeEvent==="string"){let node=this.get(nodeEvent);if(node){if(onEvent instanceof GraphNode&&onEvent.__operator){const doSub=()=>{sub=node.__subscribe(onEvent.__operator,key,subInput,target,tkey,args,callbackStr);let ondelete=()=>{if(sub!==void 0)node.__unsubscribe(sub,key,subInput)};node.__addOndisconnected(()=>{ondelete();node.__addOnconnected(()=>{if(sub===void 0&&node.__node.graph.__node.tag===this.__node.tag)doSub()})});onEvent.__addOndisconnected(ondelete)};doSub()}else if(typeof onEvent==="function"||typeof onEvent==="string"){const doSub=()=>{sub=node.__subscribe(onEvent,key,subInput,target,tkey,args,callbackStr);let ondelete=()=>{if(sub!==void 0)node.__unsubscribe(sub,key,subInput);sub=void 0};node.__addOndisconnected(()=>{ondelete();node.__addOnconnected(()=>{if(sub===void 0&&node.__node.graph.__node.tag===this.__node.tag)doSub()})});if(typeof onEvent==="string"&&this.get(onEvent))this.get(onEvent).__addOndisconnected(ondelete)};doSub()}}else{if(typeof onEvent==="string")onEvent=this.__node.nodes.get(onEvent).__operator;if(typeof onEvent==="function"&&!onEvent?.__node)sub=this.__node.state.subscribeEvent(nodeEvent,onEvent)}}return sub};unsubscribe=(node,sub,key,subInput)=>{if(node instanceof GraphNode){return node.__unsubscribe(sub,key,subInput)}else return this.get(node)?.__unsubscribe(sub,key,subInput)};setState=update=>{this.__node.state.setState(update)}};function recursivelyAssign(target,obj,maxDepth=Infinity,curDepth=0){for(const key in obj){if(obj[key]?.constructor.name==="Object"&&curDepth<maxDepth){curDepth++;if(target[key]?.constructor.name==="Object")recursivelyAssign(target[key],obj[key],maxDepth,curDepth);else target[key]=recursivelyAssign({},obj[key],maxDepth,curDepth)}else{target[key]=obj[key]}}return target}function getAllProperties(obj){var allProps=[],curr=obj;do{var props=Object.getOwnPropertyNames(curr);let fn=function(prop){if(allProps.indexOf(prop)===-1)allProps.push(prop)};props.forEach(fn)}while(curr=Object.getPrototypeOf(curr));return allProps}function instanceObject(obj){let props=getAllProperties(obj);let instance={};for(const key of props){instance[key]=obj[key]}return instance}function isNativeClass(thing){return isFunction(thing)==="class"}function isFunction(x){const res=typeof x==="function"?x.prototype?Object.getOwnPropertyDescriptor(x,"prototype")?.writable?"function":"class":x.constructor.name==="AsyncFunction"?"async":"arrow":"";return res}var getCallbackFromString=(a,graph)=>{if(graph.get(a)?.__operator){let node=graph.get(a);return(...inp)=>{node.__operator(...inp)}}else if(a.includes(".")){let split=a.split(".");let popped=split.pop();let joined=split.join(".");let node=graph.get(joined);if(typeof graph.get(joined)?.[popped]==="function"){return(...inp)=>{return node[popped](...inp)}}else return()=>{return node[popped]}}else if(graph.get(a)){let node=graph.get(a);return()=>{return node}}else{let arg=a;return()=>{return arg}}};var wrapArgs=(callback,argOrder,graph)=>{let args=[];let forArg=(a,i)=>{if(a==="__output"||a==="__input"||a==="__callback"){args[i]={__callback:inp=>{return inp},__args:void 0,idx:i}}else if(typeof a==="string"){args[i]={__callback:getCallbackFromString(a,graph),__args:void 0,idx:i}}else if(typeof a==="function"){let fn2=a;args[i]={__callback:(...inp)=>{return fn2(...inp)},__args:void 0,idx:i}}else if(typeof a==="object"&&(a.__input||a.__callback)){let recursivelyCreateCallback=function(c){let input=c.__input?c.__input:c.__callback;if(typeof c.__input==="string"){input={__callback:getCallbackFromString(c.__input,graph),__args:void 0,idx:i}}if(c.__args){let wrapped=wrapArgs(input,c.__args,graph);input={__callback:wrapped.__callback,__args:wrapped.__args,idx:i}}else{input={__callback:input,__args:void 0,idx:i}}if(c.__output){let output=c.__output;if(typeof c.__output==="string"){output={__callback:getCallbackFromString(output,graph),__args:void 0,idx:i}}else if(typeof a.__output==="object"){output=recursivelyCreateCallback(output)}if(typeof output?.__callback==="function"){let fn2=input.__callback;let callback2=output.__callback;input={__callback:(...inp)=>{return callback2(fn2(...inp))},__args:output.__args,idx:i}}}return input};args[i]=recursivelyCreateCallback(a)}else{let arg=a;args[i]={__callback:()=>{return arg},__args:void 0,idx:i}}};argOrder.forEach(forArg);if(typeof callback==="string")callback={__callback:getCallbackFromString(callback,graph),__args:void 0};let fn=typeof callback==="function"?callback:callback.__callback;callback=function(...inp){let mapArg=arg=>{return arg.__callback(...inp)};const result=fn(...args.map(mapArg));return result};return{__callback:callback,__args:args}};var objProps=Object.getOwnPropertyNames(Object.getPrototypeOf({}));var backprop=(node,parent,graph)=>{if(node.__node.backward&&parent instanceof GraphNode){graph.setListeners({[parent.__node.tag]:{[node.__node.tag]:parent}})}};var loop=(node,parent,graph)=>{if(node.__operator){let loopId=Math.random();if(!node.__node.loops)node.__node.loops={};if(typeof node.__node.delay==="number"){let fn=node.__operator;node.__setOperator((...args)=>{return new Promise((res,rej)=>{node.__node.loops[loopId]=setTimeout(async()=>{res(await fn(...args))},node.__node.delay)})})}else if(node.__node.frame===true){let fn=node.__operator;node.__setOperator((...args)=>{return new Promise((res,rej)=>{node.__node.loops[loopId]=requestAnimationFrame(async()=>{res(await fn(...args))})})})}if(typeof node.__node.repeat==="number"||typeof node.__node.recursive==="number"){let fn=node.__operator;node.__setOperator(async(...args)=>{let i=node.__node.repeat?node.__node.repeat:node.__node.recursive;let result;let repeater=async(tick,...inp)=>{while(tick>0){if(node.__node.delay||node.__node.frame){fn(...inp).then(async res=>{if(node.__node.recursive){await repeater(tick,res)}else await repeater(tick,...inp)});break}else result=await fn(...args);tick--}};await repeater(i,...args);return result})}if(node.__node.loop&&typeof node.__node.loop==="number"){let fn=node.__operator;let time=node.__node.loop;node.__setOperator((...args)=>{if(!("looping"in node.__node))node.__node.looping=true;if(node.__node.looping){let last=performance.now();fn(...args);node.__node.loops[loopId]=setTimeout(()=>{let now=performance.now();let overshoot=now-last-node.__node.loop;if(overshoot>0)time=node.__node.loop-overshoot;else time=node.__node.loop;if(time<=0)time=node.__node.loop;node.__operator(...args)},time)}});if(node.__node.looping)node.__operator();let ondelete=node2=>{if(node2.__node.looping)node2.__node.looping=false;if(node2.__node.loops[loopId]){clearTimeout(node2.__node.loops[loopId]);cancelAnimationFrame(node2.__node.loops[loopId])}};node.__addOndisconnected(ondelete)}}};var animate=(node,parent,graph)=>{if(node.__node.animate===true||node.__animation){let fn=node.__operator;node.__setOperator((...args)=>{if(!("animating"in node.__node))node.__node.animating=true;if(node.__node.animating){if(typeof node.__animation==="function")node.__animation(...args);else fn(...args);node.__node.animationFrame=requestAnimationFrame(()=>{node.__operator(...args)})}});if(node.__node.animating||(!("animating"in node.__node)||node.__node.animating)&&node.__animation)setTimeout(()=>{node.__node.animationFrame=requestAnimationFrame(node.__operator)},10);let ondelete=node2=>{if(node2.__node.animating)node2.__node.animating=false;if(node2.__node.animationFrame)cancelAnimationFrame(node2.__node.animationFrame)};node.__addOndisconnected(ondelete)}};var branching=(node,parent,graph)=>{if(typeof node.__branch==="object"&&node.__operator&&!node.__branchApplied){let fn=node.__operator;node.__branchApplied=true;node.__operator=(...args)=>{let result=fn(...args);for(const key in node.__branch){let triggered=()=>{if(typeof node.__branch[key].then==="function"){node.__branch[key].then(result)}else if(node.__branch[key].then instanceof GraphNode&&node.__branch[key].then.__operator){node.__branch[key].then.__operator(result)}else result=node.__branch[key].then};if(typeof node.__branch[key].if==="function"){if(node.__branch[key].if(result)==true){triggered()}}else if(node.__branch[key].if===result){triggered()}}return result}}if(node.__listeners){for(const key in node.__listeners){if(typeof node.__listeners[key]==="object"){if(node.__listeners[key].branch&&!node.__listeners[key].branchApplied){let fn=node.__listeners[key].callback;node.__listeners[key].branchApplied=true;node.__listeners.callback=ret=>{let triggered=()=>{if(typeof node.__listeners[key].branch.then==="function"){ret=node.__listeners[key].branch.then(ret)}else if(node.__listeners[key].branch.then instanceof GraphNode&&node.__listeners[key].branch.then.__operator){ret=node.__listeners[key].branch.then.__operator(ret)}else ret=node.__listeners[key].branch.then};if(typeof node.__listeners[key].branch.if==="function"){if(node.__listeners[key].branch.if(ret)){triggered()}}else if(node.__listeners[key].branch.if===ret){triggered()}return fn(ret)}}}}}};var triggerListenerOncreate=(node,parent,graph)=>{if(node.__listeners){for(const key in node.__listeners){if(typeof node.__listeners[key]==="object"){if(node.__listeners[key].oncreate){node.__listeners[key].callback(node.__listeners[key].oncreate)}}}}};var bindListener=(node,parent,graph)=>{if(node.__listeners){for(const key in node.__listeners){if(typeof node.__listeners[key]==="object"){if(typeof node.__listeners[key].binding==="object"){node.__listeners.callback=node.__listeners.callback.bind(node.__listeners[key].binding)}}}}};var transformListenerResult=(node,parent,graph)=>{if(node.__listeners){for(const key in node.__listeners){if(typeof node.__listeners[key]==="object"){if(typeof node.__listeners[key].transform==="function"&&!node.__listeners[key].transformApplied){let fn=node.__listeners[key].callback;node.__listeners[key].transformApplied=true;node.__listeners.callback=ret=>{ret=node.__listeners[key].transform(ret);return fn(ret)}}}}}};var substitute__operator=(node,parent,graph)=>{if(node.post&&!node.__operator){node.__setOperator(node.post)}else if(!node.__operator&&typeof node.get=="function"){node.__setOperator(node.get)}if(!node.get&&node.__operator){}if(node.aliases){node.aliases.forEach(a=>{graph.set(a,node);let ondelete=node2=>{graph.__node.nodes.delete(a)};node.__addOndisconnected(ondelete)})}if(typeof graph.__node.roots?.[node.__node.tag]==="object"&&node.get)graph.__node.roots[node.__node.tag].get=node.get};var loaders={backprop,loop,animate,branching,triggerListenerOncreate,bindListener,transformListenerResult,substitute__operator};var recursivelyStringifyFunctions=obj=>{let cpy={};for(const key in obj){if(typeof obj[key]==="object"){cpy[key]=recursivelyStringifyFunctions(obj[key])}else if(typeof obj[key]==="function"){cpy[key]=obj[key].toString()}else cpy[key]=obj[key]}return cpy};function getFnParamNames(fn){if(typeof fn!=="string")fn=fn.toString();const arrowMatch=fn.match(/\(?[^]*?\)?\s*=>/);if(arrowMatch)return arrowMatch[0].replace(/[()\s]/gi,"").replace("=>","").split(",");const match=fn.match(/\([^]*?\)/);return match?match[0].replace(/[()\s]/gi,"").split(","):[]}var getFunctionHead=methodString=>{let startindex=methodString.indexOf("=>")+1;if(startindex<=0){startindex=methodString.indexOf("){")}if(startindex<=0){startindex=methodString.indexOf(") {")}return methodString.slice(0,methodString.indexOf("{",startindex)+1)};function parseFunctionFromText(method=""){let getFunctionBody=methodString=>{return methodString.replace(/^\W*(function[^{]+\{([\s\S]*)\}|[^=]+=>[^{]*\{([\s\S]*)\}|[^=]+=>(.+))/i,"$2$3$4")};let newFuncHead=getFunctionHead(method);let newFuncBody=getFunctionBody(method);let newFunc;if(newFuncHead.includes("function")){let varName=newFuncHead.substring(newFuncHead.indexOf("(")+1,newFuncHead.lastIndexOf(")"));newFunc=new Function(varName,newFuncBody)}else{if(newFuncHead.substring(0,6)===newFuncBody.substring(0,6)){let varName=newFuncHead.substring(newFuncHead.indexOf("(")+1,newFuncHead.lastIndexOf(")"));newFunc=new Function(varName,newFuncBody.substring(newFuncBody.indexOf("{")+1,newFuncBody.length-1))}else{try{newFunc=(0,eval)(method)}catch{}}}return newFunc}function reconstructObject(json="{}"){try{let parsed=typeof json==="string"?JSON.parse(json):json;const parseObj=obj=>{for(const prop in obj){if(typeof obj[prop]==="string"){let funcParsed=parseFunctionFromText(obj[prop]);if(typeof funcParsed==="function"){obj[prop]=funcParsed}}else if(typeof obj[prop]==="object"){parseObj(obj[prop])}}return obj};return parseObj(parsed)}catch(err){console.error(err);return void 0}}var stringifyWithCircularRefs=function(){const refs=new Map;const parents=[];const path3=["this"];function clear(){refs.clear();parents.length=0;path3.length=1}function updateParents(key,value){var idx=parents.length-1;var prev=parents[idx];if(typeof prev==="object"){if(prev[key]===value||idx===0){path3.push(key);parents.push(value.pushed)}else{while(idx-->=0){prev=parents[idx];if(typeof prev==="object"){if(prev[key]===value){idx+=2;parents.length=idx;path3.length=idx;--idx;parents[idx]=value;path3[idx]=key;break}}idx--}}}}function checkCircular(key,value){if(value!=null){if(typeof value==="object"){if(key){updateParents(key,value)}let other=refs.get(value);if(other){return"[Circular Reference]"+other}else{refs.set(value,path3.join("."))}}}return value}return function stringifyWithCircularRefs2(obj,space){try{parents.push(obj);return JSON.stringify(obj,checkCircular,space)}finally{clear()}}}();if(JSON.stringifyWithCircularRefs===void 0){JSON.stringifyWithCircularRefs=stringifyWithCircularRefs}var stringifyWithFunctionsAndCircularRefs=function(){const refs=new Map;const parents=[];const path3=["this"];function clear(){refs.clear();parents.length=0;path3.length=1}function updateParents(key,value){var idx=parents.length-1;var prev=parents[idx];if(typeof prev==="object"){if(prev[key]===value||idx===0){path3.push(key);parents.push(value.pushed)}else{while(idx-->=0){prev=parents[idx];if(typeof prev==="object"){if(prev[key]===value){idx+=2;parents.length=idx;path3.length=idx;--idx;parents[idx]=value;path3[idx]=key;break}}idx--}}}}function checkCircular(key,value){if(value!=null){if(typeof value==="object"){if(key){updateParents(key,value)}let other=refs.get(value);if(other){return"[Circular Reference]"+other}else{refs.set(typeof value==="function"?value.toString():value,path3.join("."))}}}return typeof value==="function"?value.toString():value}return function stringifyWithFunctionsAndCircularRefs2(obj,space){try{parents.push(obj);return JSON.stringify(obj,checkCircular,space)}finally{clear()}}}();if(JSON.stringifyWithFunctionsAndCircularRefs===void 0){JSON.stringifyWithFunctionsAndCircularRefs=stringifyWithFunctionsAndCircularRefs}var stringifyFast=function(){const refs=new Map;const parents=[];const path3=["this"];function clear(){refs.clear();parents.length=0;path3.length=1}function updateParents(key,value){var idx=parents.length-1;if(parents[idx]){var prev=parents[idx];if(typeof prev==="object"){if(prev[key]===value||idx===0){path3.push(key);parents.push(value.pushed)}else{while(idx-->=0){prev=parents[idx];if(typeof prev==="object"){if(prev[key]===value){idx+=2;parents.length=idx;path3.length=idx;--idx;parents[idx]=value;path3[idx]=key;break}}idx++}}}}}function checkValues(key,value){let val;if(value!=null){if(typeof value==="object"){let c=value.constructor.name;if(key&&c==="Object"){updateParents(key,value)}let other=refs.get(value);if(other){return"[Circular Reference]"+other}else{refs.set(value,path3.join("."))}if(c==="Array"){if(value.length>20){val=value.slice(value.length-20)}else val=value}else if(c.includes("Set")){val=Array.from(value)}else if(c!=="Object"&&c!=="Number"&&c!=="String"&&c!=="Boolean"){val="instanceof_"+c}else if(c==="Object"){let obj={};for(const prop in value){if(value[prop]==null){obj[prop]=value[prop]}else if(Array.isArray(value[prop])){if(value[prop].length>20)obj[prop]=value[prop].slice(value[prop].length-20);else obj[prop]=value[prop]}else if(value[prop].constructor.name==="Object"){obj[prop]={};for(const p in value[prop]){if(Array.isArray(value[prop][p])){if(value[prop][p].length>20)obj[prop][p]=value[prop][p].slice(value[prop][p].length-20);else obj[prop][p]=value[prop][p]}else{if(value[prop][p]!=null){let con=value[prop][p].constructor.name;if(con.includes("Set")){obj[prop][p]=Array.from(value[prop][p])}else if(con!=="Number"&&con!=="String"&&con!=="Boolean"){obj[prop][p]="instanceof_"+con}else{obj[prop][p]=value[prop][p]}}else{obj[prop][p]=value[prop][p]}}}}else{let con=value[prop].constructor.name;if(con.includes("Set")){obj[prop]=Array.from(value[prop])}else if(con!=="Number"&&con!=="String"&&con!=="Boolean"){obj[prop]="instanceof_"+con}else{obj[prop]=value[prop]}}}val=obj}else{val=value}}else{val=value}}return val}return function stringifyFast2(obj,space){parents.push(obj);let res=JSON.stringify(obj,checkValues,space);clear();return res}}();if(JSON.stringifyFast===void 0){JSON.stringifyFast=stringifyFast}function methodstrings(node){if(typeof node.__methods==="object"){for(const key in node.__methods){let fstr=node.__methods[key];let fn=typeof fstr==="function"?fstr:parseFunctionFromText(fstr);if(key==="__operator"){node.__setOperator(fn)}else{node[key]=fn.bind(node)}}}}var Service=class extends Graph{name=`service${Math.floor(Math.random()*1e15)}`;restrict;constructor(options){super({...options,loaders:options?.loaders?Object.assign({...loaders},options.loaders):{...loaders}});if(options?.services)this.addServices(options.services);if(options?.restrict)this.restrict=options.restrict;this.load(this)}addServices=services=>{for(const s in services){if(typeof services[s]==="function")services[s]=new services[s];if(services[s]?.__node?.loaders)Object.assign(this.__node.loaders,services[s].__node.loaders);if(services[s]?.__node?.nodes){services[s].__node.nodes.forEach((n,tag)=>{if(!this.get(tag)){this.set(tag,n)}else this.set(s+"."+tag,n)});this.__node.nodes.forEach((n,k)=>{if(!services[s].__node.nodes.get(k))services[s].__node.nodes.set(k,n)});let set=this.set;this.set=(tag,node)=>{services[s].set(tag,node);return set(tag,node)};let del=this.delete;this.delete=tag=>{services[s].delete(tag);return del(tag)}}else if(typeof services[s]==="object"){this.load(services[s])}}};handleMethod=(route,method,args)=>{let m=method.toLowerCase();let src=this.__node.nodes.get(route);if(!src){src=this.__node.roots[route]}if(src?.[m]){if(typeof src[m]!=="function"){if(args){if(Array.isArray(args)&&args.length===1)src[m]=args[0];else src[m]=args;return}return src[m]}else{if(Array.isArray(args))return src[m](...args);else return src[m](args)}}else return this.handleServiceMessage({route,args,method})};handleServiceMessage(message){let call;if(typeof message==="object"){if(message.route)call=message.route;else if(message.node)call=message.node}if(call){if(Array.isArray(message.args))return this.run(call,...message.args);else return this.run(call,message.args)}else return message}handleGraphNodeCall(route,args){if(!route)return args;if(args?.args){this.handleServiceMessage(args)}else if(Array.isArray(args))return this.run(route,...args);else return this.run(route,args)}transmit=(...args)=>{if(typeof args[0]==="object"){const message=args[0];if(message.method){return this.handleMethod(message.route,message.method,message.args)}else if(message.route){return this.handleServiceMessage(message)}else if(message.node){return this.handleGraphNodeCall(message.node,message.args)}else if(this.__node.keepState){if(message.route)this.setState({[message.route]:message.args});if(message.node)this.setState({[message.node]:message.args})}return void 0}else return void 0};receive=(...args)=>{if(args[0]){let message=args[0];if(typeof message==="string"){let substr=message.substring(0,8);if(substr.includes("{")||substr.includes("[")){if(substr.includes("\\"))message=message.replace(/\\/g,"");if(message[0]==='"'){message=message.substring(1,message.length-1)};message=JSON.parse(message)}}if(typeof message==="object"){if(message.method){if(this.restrict?.[message.route])return void 0;return this.handleMethod(message.route,message.method,message.args)}else if(message.route){if(this.restrict?.[message.route])return void 0;return this.handleServiceMessage(message)}else if(message.node){if(typeof message.node==="string"&&this.restrict?.[message.node])return void 0;return this.handleGraphNodeCall(message.node,message.args)}else if(this.__node.keepState){if(message.route)this.setState({[message.route]:message.args});if(message.node)this.setState({[message.node]:message.args})}return void 0}}return void 0};pipe=(source,destination,endpoint,method,callback)=>{if(source instanceof GraphNode){if(callback)return this.subscribe(source,res=>{let mod=callback(res);if(mod!==void 0)this.transmit({route:destination,args:mod,method});else this.transmit({route:destination,args:res,method},endpoint)});else return this.subscribe(source,res=>{this.transmit({route:destination,args:res,method},endpoint)})}else if(typeof source==="string")return this.subscribe(source,res=>{this.transmit({route:destination,args:res,method},endpoint)})};pipeOnce=(source,destination,endpoint,method,callback)=>{if(source instanceof GraphNode){if(callback)return source.__node.state.subscribeEventOnce(source.__node.unique,res=>{let mod=callback(res);if(mod!==void 0)this.transmit({route:destination,args:mod,method});else this.transmit({route:destination,args:res,method},endpoint)});else return this.__node.state.subscribeEventOnce(source.__node.unique,res=>{this.transmit({route:destination,args:res,method},endpoint)})}else if(typeof source==="string")return this.__node.state.subscribeEventOnce(this.__node.nodes.get(source).__node.unique,res=>{this.transmit({route:destination,args:res,method},endpoint)})};terminate=(...args)=>{};isTypedArray=isTypedArray;recursivelyAssign=recursivelyAssign2;spliceTypedArray=spliceTypedArray;ping=()=>{console.log("pinged!");return"pong"};echo=(...args)=>{this.transmit(...args);return args};log=(...args)=>{console.log(...args);return true};error=(...args)=>{console.error(...args);return true}};function isTypedArray(x){return ArrayBuffer.isView(x)&&Object.prototype.toString.call(x)!=="[object DataView]"}var recursivelyAssign2=(target,obj)=>{for(const key in obj){if(obj[key]?.constructor.name==="Object"&&!Array.isArray(obj[key])){if(target[key]?.constructor.name==="Object"&&!Array.isArray(target[key]))recursivelyAssign2(target[key],obj[key]);else target[key]=recursivelyAssign2({},obj[key])}else target[key]=obj[key]}return target};function spliceTypedArray(arr,start,end){let s=arr.subarray(0,start);let e;if(end){e=arr.subarray(end+1)}let ta;if(s.length>0||e?.length>0)ta=new arr.constructor(s.length+e.length);if(ta){if(s.length>0)ta.set(s);if(e&&e.length>0)ta.set(e,s.length)}return ta}var SessionsService=class extends Service{name="sessions";users={};sessions={oneWay:{},shared:{}};invites={};constructor(options,users){super(options);this.setLoaders(loaders);this.load(this);if(users)this.users=users}getSessionInfo=(sessionIdOrName,userId)=>{if(!sessionIdOrName){return this.sessions.shared}else{if(this.sessions.oneWay[sessionIdOrName]){let s=this.sessions.oneWay[sessionIdOrName];if(s.settings){if(s.settings.source===userId||s.settings.listener===userId||s.settings.ownerId===userId||s.settings.admins?.[userId]||s.settings.moderators?.[userId]){const res={...s.settings};delete res.password;return{oneWay:{[sessionIdOrName]:res}}}}}else if(this.sessions.shared[sessionIdOrName]){const res={...this.sessions.shared[sessionIdOrName]?.settings};delete res.password;return{shared:{[sessionIdOrName]:res}}}else{let res={};for(const id in this.sessions.shared){if(this.sessions.shared[id].settings?.name===sessionIdOrName){res[id]={...this.sessions.shared[id]?.settings};delete res[id].password}}if(Object.keys(res).length>0)return res}}};openOneWaySession=(options={},sourceUserId,listenerUserId)=>{if(!options._id){options._id=`oneWay${Math.floor(Math.random()*1e15)}`;if(this.sessions.oneWay[options._id]){delete options._id;this.openOneWaySession(options,sourceUserId)}}if(options._id&&sourceUserId&&this.users[sourceUserId]){if(sourceUserId){if(!options.settings)options.settings={listener:sourceUserId,source:sourceUserId,propnames:{latency:true},admins:{[sourceUserId]:true},ownerId:sourceUserId};if(!options.settings.listener)options.settings.listener=listenerUserId?listenerUserId:sourceUserId;if(!options.settings.source)options.settings.source=sourceUserId;if(!this.users[sourceUserId].sessions)this.users[sourceUserId].sessions={};this.users[sourceUserId].sessions[options._id]=options}if(!options.data)options.data={};if(options.onopen)options.onopen(options);if(this.sessions.oneWay[options._id]){return this.updateSession(options,sourceUserId)}else if(options.settings?.listener&&options.settings.source)this.sessions.oneWay[options._id]=options}return options};openSharedSession=(options,userId)=>{if(!options._id){options._id=`shared${Math.floor(Math.random()*1e15)}`;if(this.sessions.shared[options._id]){delete options._id;return this.openSharedSession(options,userId)}}if(options._id&&userId&&this.users[userId]){if(typeof userId==="string"){if(!options.settings)options.settings={name:"shared",propnames:{latency:true},users:{[userId]:true},admins:{[userId]:true},ownerId:userId};if(!options.settings.users)options.settings.users={[userId]:true};if(!options.settings.admins)options.settings.admins={[userId]:true};if(!options.settings.ownerId)options.settings.ownerId=userId;if(!this.users[userId].sessions)this.users[userId].sessions={};this.users[userId].sessions[options._id]=options}else if(!options.settings)options.settings={name:"shared",propnames:{latency:true},users:{}};if(!options.data)options.data={oneWay:{},shared:{}};if(!options.settings.name)options.name=options.id;if(options.onopen)options.onopen(options);if(this.sessions.shared[options._id]){return this.updateSession(options,userId)}else this.sessions.shared[options._id]=options}return options};open=(options,userId)=>{if(options.listener)this.openOneWaySession(options,userId);else this.openSharedSession(options,userId)};updateSession=(options,userId)=>{let session;if(options._id){session=this.sessions.oneWay[options._id];if(!session)session=this.sessions.shared[options._id];if(session&&userId){if(session.settings&&(session?.settings.source===userId||session.settings.admins?.[userId]||session.settings.moderators?.[userId]||session.settings.ownerId===userId)){return this.recursivelyAssign(session,options)}}else if(options.settings?.source){return this.openOneWaySession(options,userId)}else return this.openSharedSession(options,userId)}return false};joinSession=(sessionId,userId,options,remoteUser=true)=>{if(!userId&&!this.users[userId])return false;if(!this.users[userId].sessions)this.users[userId].sessions={};let sesh=this.sessions.shared[sessionId];if(!sesh)sesh=this.sessions.oneWay[sessionId];if(sesh?.settings){if(sesh.settings?.banned){if(sesh.settings.banned[userId])return false}if(sesh.settings?.password){if(!options?.settings?.password)return false;if(options.settings.password!==sesh.settings.password)return false}if(sesh.settings.maxUsers&&Object.keys(sesh.settings.users)>sesh.setting.maxUsers)return false;sesh.settings.users[userId]=true;sesh.settings.newUser=true;this.users[userId].sessions[sessionId]=sesh;if(options){return this.updateSession(options,userId)};if(remoteUser&&this.users[userId]?.send){this.users[userId].send({route:"joinSession",args:[sessionId,userId,sesh]})}return sesh}else if(options?.source||options?.listener){sesh=this.openOneWaySession(options,userId);if(remoteUser&&this.users[userId]?.send){this.users[userId].send({route:"joinSession",args:[sessionId,userId,sesh]})}return sesh}else if(options){sesh=this.openSharedSession(options,userId);if(remoteUser&&this.users[userId]?.send){this.users[userId].send({route:"joinSession",args:[sessionId,userId,sesh]})}return sesh}return false};inviteToSession=(session,userInvited,inviteEndpoint,remoteUser=true)=>{if(remoteUser&&this.users[userInvited]?.send){this.users[userInvited]?.send({route:"receiveSessionInvite",args:[session,userInvited,inviteEndpoint]})}else{this.receiveSessionInvite(session,userInvited,inviteEndpoint)}};receiveSessionInvite=(session,userInvited,endpoint)=>{if(!this.invites[userInvited])this.invites[userInvited]={};let id=typeof session==="string"?session:session._id;this.invites[userInvited][id]={session,endpoint};return id};acceptInvite=(session,userInvited,remoteUser=true)=>{let id=typeof session==="string"?session:session._id;let invite=this.invites[userInvited]?.[id];let endpoint;if(invite){session=invite.session;endpoint=invite.endpoint;delete this.invites[userInvited]?.[id]}return new Promise((res,rej)=>{if(!id)res(false);if(remoteUser&&endpoint&&this.users[endpoint]?.send){let resolved;let timeout=setTimeout(()=>{if(!resolved){this.unsubscribe("joinSession",subbed);rej(new Error("Session join timed out"))}},1e4);let subbed=this.subscribe("joinSession",result=>{if(typeof result==="object"&&result?._id===id){if(result.setting?.users?.includes(userInvited)){this.unsubscribe("joinSession",subbed);resolved=true;if(timeout)clearTimeout(timeout);res(result)}}});this.users[endpoint]?.send({route:"joinSession",args:[id,userInvited,void 0,true]})}else res(this.joinSession(id,userInvited,typeof session==="object"?session:void 0))})};rejectInvite=(session,userInvited,remoteUser=true)=>{let id=typeof session==="string"?session:session._id;if(this.invites[userInvited]?.[id]){let endpoint=this.invites[userInvited][id].endpoint;delete this.invites[userInvited][id];if(remoteUser&&endpoint&&this.users[endpoint]?.send){this.users[endpoint].send({route:"rejectInvite",args:[id,userInvited]})}return true}};leaveSession=(session,userId,clear=true,remoteUser=true)=>{let sessionId;if(typeof session==="string"){sessionId=session;session=this.sessions.oneWay[sessionId];if(!session)session=this.sessions.shared[sessionId]}else sessionId=session._id;if(session){if(this.sessions.oneWay[sessionId]){if(userId===session.settings.source||userId===session.settings.listener||session.settings.admins?.[userId]||session.settings.moderators?.[userId]){delete this.sessions.oneWay[sessionId];delete this.users[userId]?.sessions[sessionId];delete this.users[userId]?.sessionSubs?.[sessionId];if(clear){if(session.settings.admins?.[userId])delete(this.sessions.shared[sessionId].settings?.admins)[userId];if(session.settings.moderators?.[userId])delete(this.sessions.shared[sessionId].settings?.moderators)[userId]}if(remoteUser&&this.users[userId]?.send){this.users[userId].send({route:"unsubscribeFromSession",args:[session._id,userId,clear]})}else{this.unsubsribeFromSession(session,userId,clear)}}}else if(this.sessions.shared[sessionId]){delete this.sessions.shared.settings.users[userId];delete this.users[userId]?.sessions[sessionId];delete this.users[userId]?.sessionSubs?.[sessionId];if(clear){if(session.settings.admins?.[userId])delete(this.sessions.shared[sessionId].settings?.admins)[userId];if(session.settings.moderators?.[userId])delete(this.sessions.shared[sessionId].settings?.moderators)[userId];if(session.data.shared[userId])delete this.sessions.shared[sessionId].data?.shared[userId];if(session.settings.host===userId){this.swapHost(session,void 0,true);delete session.data.shared[userId]}}if(remoteUser&&this.users[userId]?.send){this.users[userId].send({route:"unsubscribeFromSession",args:[session._id,userId,clear]})}else{this.unsubsribeFromSession(session,userId,clear)}}return true}return false};deleteSession=(session,userId,remoteUsers=true)=>{if(typeof session==="string"){let id=session;session=this.sessions.oneWay[id];if(!session)session=this.sessions.shared[id]}if(session){if(session.source===userId||session.listener===userId||session.admins?.[userId]||session.ownerId===userId){for(const user in session.settings.users){if(this.users[user]?.sessions)delete this.users[user].sessions[session._id];if(this.users[user]?.sessionSubs)delete this.users[user].sessionSubs[session._id];if(remoteUsers){if(session.users){for(const key in session.users){if(this.users[key]?.send)this.users[key].send({route:"unsubscribeFromSession",args:[session._id,key]})}}else if(session.listener){if(this.users[session.listener]?.send)this.users[session.listener].send({route:"unsubscribeFromSession",args:[session._id,session.listener]})}else if(this.users[userId]?.send){this.users[userId].send({route:"unsubscribeFromSession",args:[session._id,userId]})}}else{this.unsubsribeFromSession(session,user)}}if(this.sessions.oneWay[session._id])delete this.sessions.oneWay[session._id];else if(this.sessions.shared[session._id])delete this.sessions.oneWay[session._id];if(session.onclose)session.onclose(session)}}return true};getFirstMatch(obj1,obj2){for(const i in obj1){if(i in obj2)return i}return false}swapHost=(session,newHostId,adoptData=true,remoteUser=true)=>{if(typeof session==="string"){if(this.sessions.oneWay[session])session=this.sessions.oneWay[session];else if(this.sessions.shared[session])session=this.sessions.shared[session]}if(typeof session==="object"&&session.settings){let oldHost=session.settings.host;delete session.settings.host;if(newHostId){if(session.settings.users[newHostId])session.settings.host=newHostId}if(session.settings.ownerId&&!session.settings.host){if(session.settings.users[session.settings.ownerId])session.settings.host=session.settings.ownerId}if(session.settings.admins&&!session.settings.host){let match=this.getFirstMatch(session.settings.users,session.settings.admins);if(match)session.settings.host=match}if(session.settings.moderators&&!session.settings.host){let match=this.getFirstMatch(session.settings.users,session.settings.moderators);if(match)session.settings.host=match}if(!session.settings.host)session.settings.host=Object.keys(session.settings.users)[0];if(adoptData&&oldHost&&session.settings.inheritHostData!==false){if(session.data?.shared[oldHost]){if(session.data?.shared[oldHost]){session.data.shared[session.settings.host]=Object.assign(session.data.shared[session.settings.host]?session.data.shared[session.settings.host]:{},session.data.shared[oldHost]);if(remoteUser){}}}}return true}return false};subscribeToSession=(session,userId,onmessage,onopen,onclose)=>{if(typeof session==="string"){let s=this.sessions.oneWay[session];if(!s)s=this.sessions.shared[session];if(!s)return void 0;session=s}let user=this.users[userId];if(!user)return void 0;if(!user.sessionSubs)user.sessionSubs={};if(!user.sessionSubs[session._id])user.sessionSubs[session._id]={};if(onmessage)user.sessionSubs[session._id].onmessage=onmessage;if(onopen)this.sessionSubs[userId][session._id].onopen=onopen;if(onclose)user.sessionSubs[session._id].onclose=onclose;if(typeof onopen==="function"){let sub=this.subscribe("joinSession",res=>{if(res._id===session._id)this.sessionSubs[userId][session._id].onopen(session,user);this.unsubscribe("joinSession",sub)});user.sessionSubs[session._id].onopenSub=sub}return session};unsubsribeFromSession=(session,userId,clear=true)=>{if(typeof session==="string"){let s=this.sessions.oneWay[session];if(!s)s=this.sessions.shared[session];if(!s)return void 0;session=s}const clearSessionSubs=(Id,s)=>{let u2=this.users[Id];if(!u2)return void 0;if(u2.sessionSubs?.[s._id]){if(u2.sessionSubs[s._id].onopenSub){this.unsubscribe("joinSession",u2.sessionSubs[s._id].onopenSub)}}if(u2.sessionSubs[s._id].onclose)u2.sessionSubs[s._id].onclose(s,u2);delete u2.sessionSubs[s._id]};if(userId){clearSessionSubs(userId,session)}else{for(const key in this.users){clearSessionSubs(key,session)}}if(clear){if(this.sessions.oneWay[session._id])delete this.sessions.oneWay[session._id];else if(this.sessions.shared[session._id])delete this.sessions.shared[session._id]}};sessionUpdateCheck=(sessionHasUpdate,transmit=true)=>{let updates={oneWay:{},shared:{}};for(const session in this.sessions.oneWay){const sesh=this.sessions.oneWay[session];const updateObj={_id:sesh._id,settings:{listener:sesh.listener,source:sesh.source},data:{}};if(!this.users[sesh.source]){delete this.sessions.oneWay[session];continue}if(sesh.settings&&sesh.data){for(const prop in sesh.settings.propnames){if(prop in this.users[sesh.source]){if(this.sessions.oneWay[session].data){if(typeof sesh.data[prop]==="object"){if(this.users[sesh.source][prop]&&(stringifyFast(sesh.data[prop])!==stringifyFast(this.users[sesh.source][prop])||!(prop in sesh.data)))updateObj.data[prop]=this.users[sesh.source][prop]}else if(prop in this.users[sesh.source]&&(sesh.data[prop]!==this.users[sesh.source][prop]||!(prop in sesh.data)))updateObj.data[prop]=this.users[sesh.source][prop]}else updateObj.data[prop]=this.users[sesh.source][prop]}else if(this.sessions.oneWay[session]?.data&&prop in this.sessions.oneWay[session]?.data)delete this.sessions.oneWay[session].data[prop]}}if(Object.keys(updateObj.data).length>0){this.recursivelyAssign(this.sessions.oneWay[session].data,updateObj.data);updates.oneWay[sesh._id]=updateObj;if(sessionHasUpdate)sessionHasUpdate(sesh,updateObj);if(sesh.settings.onhasupdate)sesh.onhasupdate(sesh,updateObj)}}for(const session in this.sessions.shared){const sesh=this.sessions.shared[session];const updateObj={_id:sesh._id,settings:{name:sesh.name},data:{}};if(sesh.settings?.host){const oneWayData={};const sharedData={};for(const user in sesh.settings.users){if(!this.users[user]){delete sesh.settings.users[user];if(sesh.settings.host===user)this.swapHost(sesh,void 0,true);if(sesh.data?.shared[user])delete sesh.data.shared[user];if(sesh.data?.oneWay?.[user])delete sesh.data.shared[user];updateObj.settings.users=sesh.settings.users;updateObj.settings.host=sesh.settings.host;continue}else if(sesh.settings.newUser){updateObj.settings.users=sesh.settings.users;updateObj.settings.host=sesh.settings.host;sesh.settings.newUser=false}if(user!==sesh.settings.host){oneWayData[user]={};for(const prop in sesh.settings.propnames){if(prop in this.users[user]){if(sesh.data?.oneWay&&!(user in sesh.data.oneWay)){if(typeof this.users[user][prop]==="object")oneWayData[user][prop]=this.recursivelyAssign({},this.users[user][prop]);else oneWayData[user][prop]=this.users[user][prop]}else if(typeof oneWayData[user][prop]==="object"&&sesh.data){if(prop in this.users[user][prop]&&(stringifyFast(sesh.data?.shared[user][prop])!==stringifyFast(this.users[user][prop])||!(prop in sesh.data)))oneWayData[user][prop]=this.users[user][prop]}else if(this.users[user][prop]&&sesh.data?.oneWay?.[prop]!==this.users[user][prop])oneWayData[user][prop]=this.users[user][prop]}else if(sesh.data?.oneWay?.[user]&&prop in sesh.data?.oneWay?.[user])delete sesh.data.oneWay[user][prop]}if(Object.keys(oneWayData[user]).length===0)delete oneWayData[user]}else{sharedData[user]={};for(const prop in sesh.settings.hostprops){if(prop in this.users[user]){if(sesh.data&&!(user in sesh.data.shared)){if(typeof this.users[user][prop]==="object")sharedData[user][prop]=this.recursivelyAssign({},this.users[user][prop]);else sharedData[user][prop]=this.users[user][prop]}else if(typeof sharedData[user][prop]==="object"&&sesh.data){if(stringifyFast(sesh.data?.shared[user][prop])!==stringifyFast(this.users[user][prop])||!(prop in sesh.data.shared[user]))sharedData[user][prop]=this.users[user][prop]}else if(sesh.data?.shared[user][prop]!==this.users[user][prop])sharedData[user][prop]=this.users[user][prop]}else if(sesh.data?.shared[user]&&prop in sesh.data?.shared[user])delete sesh.data.shared[user][prop]}}}if(Object.keys(oneWayData).length>0){updateObj.data.oneWay=oneWayData}if(Object.keys(sharedData).length>0){updateObj.data.shared=sharedData}}else{const sharedData={};if(sesh.settings?.users){for(const user in sesh.settings.users){if(!this.users[user]){delete sesh.settings.users[user];if(sesh.settings.host===user)this.swapHost(sesh,void 0,true);if(sesh.data?.shared[user])delete sesh.data.shared[user];if(sesh.data?.oneWay?.[user])delete sesh.data.shared[user];updateObj.settings.users=sesh.settings.users;updateObj.settings.host=sesh.settings.host;continue}sharedData[user]={};for(const prop in sesh.settings.propnames){if(prop in this.users[user]){if(sesh.data&&!(user in sesh.data.shared)){if(typeof this.users[user][prop]==="object")sharedData[user][prop]=this.recursivelyAssign({},this.users[user][prop]);else sharedData[user][prop]=this.users[user][prop]}else if(typeof sesh.data?.shared[user]?.[prop]==="object"){if(stringifyFast(sesh.data.shared[user][prop])!==stringifyFast(this.users[user][prop])||!(prop in sesh.data.shared[user])){sharedData[user][prop]=this.users[user][prop]}}else if(sesh.data?.shared[user]?.[prop]!==this.users[user][prop])sharedData[user][prop]=this.users[user][prop]}else if(sesh.data?.shared[user]&&prop in sesh.data?.shared[user])delete sesh.data.shared[user][prop]}if(Object.keys(sharedData[user]).length===0)delete sharedData[user]}if(Object.keys(sharedData).length>0){updateObj.data.shared=sharedData}}}if(updateObj.data.shared||updateObj.data.oneWay){updates.shared[sesh._id]=updateObj;if(updateObj.data.shared){Object.assign(this.sessions.shared[session].data?.shared,updateObj.data.shared)}if(updateObj.data.oneWay){Object.assign(this.sessions.shared[session].data?.oneWay,updateObj.data.oneWay)}if(sessionHasUpdate)sessionHasUpdate(sesh,updateObj);if(sesh.settings.onhasupdate)sesh.settings.onhasupdate(sesh,updateObj)}}if(Object.keys(updates.oneWay).length===0)delete updates.oneWay;if(Object.keys(updates.shared).length===0)delete updates.shared;if(Object.keys(updates).length===0)return void 0;if(transmit)this.transmitSessionUpdates(updates);return updates};transmitSessionUpdates=updates=>{let users={};if(updates.oneWay){for(const s in updates.oneWay){let session=this.sessions.oneWay[s];if(session?.settings){let u2=session.settings.listener;if(!users[u2])users[u2]={};users[u2].oneWay[s]=updates.oneWay[s]}}}if(updates.shared){for(const s in updates.shared){let session=this.sessions.shared[s];if(session?.settings){for(const u2 in session.settings.users){if(!users[u2])users[u2]={};users[u2].shared[s]=updates.shared[s]}}}}let message={route:"receiveSessionUpdates",args:null};for(const u2 in users){message.args=[u2,users[u2]];if(this.users[u2]?.send)this.users[u2].send(JSON.stringify(message));this.setState({[u2]:Object.create(message)})}return users};receiveSessionUpdates=(origin,update)=>{if(update){if(typeof update==="string")update=JSON.parse(update)}if(typeof update==="object"){let user=this.users[origin];if(user){if(!user.sessions)user.sessions={oneWay:{},shared:{}};if(!user.sessionSubs)user.sessionSubs={}}if(update.oneWay){for(const key in update.oneWay){this.recursivelyAssign(this.sessions.oneWay[key].data,update.oneWay[key].data);if(this.sessions.oneWay[key]?.settings.onmessage)this.sessions.oneWay[key].settings.onmessage(this.sessions.oneWay[key],update.oneWay[key]);if(user?.sessionSubs[user._id]?.[key]?.onmessage)user.sessionSubs[user._id][key].onmessage(user.sessions[key],update,user)}}if(update.shared){for(const key in update.shared){if(update.shared[key].settings.users)this.sessions.shared[key].settings.users=update.shared[key].settings.users;if(update.shared[key].settings.host)this.sessions.shared[key].settings.host=update.shared[key].settings.host;if(update.shared[key].data.oneWay)this.recursivelyAssign(this.sessions.shared[key].data.oneWay,update.shared[key].data.oneWay);if(update.shared[key].data.shared)this.recursivelyAssign(this.sessions.shared[key].data.shared,update.shared[key].data.shared);if(this.sessions.shared[key]?.settings.onmessage)this.sessions.shared[key].settings.onmessage(this.sessions.shared[key],update.shared[key]);if(user?.sessionSubs[user._id]?.[key]?.onmessage)user.sessionSubs[user._id][key].onmessage(user.sessions[key],update,user)}}return user}};getUpdatedUserData=user=>{const updateObj={};for(const key in user.sessions){let s=user.sessions[key];if(s.settings.users[user._id]||s.settings.source===user._id){if(!s.settings.spectators?.[user._id]){if(s.settings.host===user._id){for(const prop in s.settings.hostprops){if(!updateObj[prop]&&prop in user){if(s.data.shared?.[user._id]&&prop in s.data.shared?.[user._id]){if(typeof user[prop]==="object"){if(stringifyFast(s.data.shared[user._id][prop])!==stringifyFast(user[prop]))updateObj[prop]=user[prop]}else if(s.data.shared[user._id][prop]!==user[prop])updateObj[prop]=user[prop]}else updateObj[prop]=user[prop]}}}else{for(const prop in s.settings.propnames){if(!updateObj[prop]&&user[prop]!==void 0){if(s.settings.source){if(typeof user[prop]==="object"&&prop in s.data){if(stringifyFast(s.data[prop])!==stringifyFast(user[prop]))updateObj[prop]=user[prop]}else if(s.data[prop]!==user[prop])updateObj[prop]=user[prop]}else{if(s.data.shared?.[user._id]&&prop in s.data.shared?.[user._id]){if(typeof user[prop]==="object"){if(stringifyFast(s.data.shared[user._id][prop])!==stringifyFast(user[prop]))updateObj[prop]=user[prop]}else if(s.data.shared[user._id][prop]!==user[prop])updateObj[prop]=user[prop]}else updateObj[prop]=user[prop]}}}}}}}return updateObj};userUpdateCheck=(user,onupdate)=>{if(user.sessions){const updateObj=this.getUpdatedUserData(user);if(Object.keys(updateObj).length>0){let message={route:"setUserProps",args:[user._id,updateObj]};if(user.send)user.send(message);this.setState({[user._id]:message});if(onupdate){onupdate(user,updateObj)};return updateObj}}return void 0};setUserProps=(user,props)=>{if(user){if(typeof user==="string"){user=this.users[user];if(!user)return false}}if(props){if(typeof props==="string"){props=JSON.parse(props)}}this.recursivelyAssign(user,props);return true};userUpdateLoop={__operator:this.userUpdateCheck,__node:{loop:10}};sessionLoop={__operator:this.sessionUpdateCheck,__node:{loop:10}};STREAMLATEST=0;STREAMALLLATEST=1;streamSettings={};streamFunctions={allLatestValues:(prop,setting)=>{let result=void 0;if(Array.isArray(prop)){if(prop.length!==setting.lastRead){result=prop.slice(setting.lastRead);setting.lastRead=prop.length}}else if(typeof prop==="object"){result={};for(const p in prop){if(Array.isArray(prop[p])){if(typeof setting==="number")setting={[p]:{lastRead:void 0}};else if(!setting[p])setting[p]={lastRead:void 0};if(prop[p].length!==setting[p].lastRead){result[p]=prop[p].slice(setting[p].lastRead);setting[p].lastRead=prop[p].length}}else{if(typeof setting==="number")setting={[p]:{lastRead:void 0}};else if(!setting[p])setting[p]={lastRead:void 0};if(setting[p].lastRead!==prop[p]){result[p]=prop[p];setting[p].lastRead=prop[p]}}}if(Object.keys(result).length===0)result=void 0}else{if(setting.lastRead!==prop){result=prop;setting.lastRead=prop}}return result},latestValue:(prop,setting)=>{let result=void 0;if(Array.isArray(prop)){if(prop.length!==setting.lastRead){result=prop[prop.length-1];setting.lastRead=prop.length}}else if(typeof prop==="object"){result={};for(const p in prop){if(Array.isArray(prop[p])){if(typeof setting==="number")setting={[p]:{lastRead:void 0}};else if(!setting[p])setting[p]={lastRead:void 0};if(prop[p].length!==setting[p].lastRead){result[p]=prop[p][prop[p].length-1];setting[p].lastRead=prop[p].length}}else{if(typeof setting==="number")setting={[p]:{lastRead:void 0}};else if(!setting[p])setting[p]={lastRead:void 0};if(setting[p].lastRead!==prop[p]){result[p]=prop[p];setting[p].lastRead=prop[p]}}}}else{if(setting.lastRead!==prop){result=prop;setting.lastRead=prop}}return result}};setStreamFunc=(name,key,callback=this.streamFunctions.allLatestValues)=>{if(!this.streamSettings[name].settings[key])this.streamSettings[name].settings[key]={lastRead:0};if(callback===this.STREAMLATEST)this.streamSettings[name].settings[key].callback=this.streamFunctions.latestValue;else if(callback===this.STREAMALLLATEST)this.streamSettings[name].settings[key].callback=this.streamFunctions.allLatestValues;else if(typeof callback==="string")this.streamSettings[name].settings[key].callback=this.streamFunctions[callback];else if(typeof callback==="function")this.streamSettings[name].settings[key].callback=callback;if(!this.streamSettings[name].settings[key].callback)this.streamSettings[name].settings[key].callback=this.streamFunctions.allLatestValues;return true};addStreamFunc=(name,callback=data=>{})=>{this.streamFunctions[name]=callback};setStream=(object={},settings={},streamName=`stream${Math.floor(Math.random()*1e10)}`,onupdate,onclose)=>{if(settings.keys){if(settings.keys.length===0){let k=Object.keys(object);if(k.length>0){settings.keys=Array.from(k)}}}else{settings.keys=Array.from(Object.keys(object))}this.streamSettings[streamName]={object,settings,onupdate,onclose};this.subscribe(streamName,res=>{if(this.streamSettings[streamName].onupdate)this.streamSettings[streamName].onupdate(res,this.streamSettings[streamName])});settings.keys.forEach(prop=>{if(settings[prop]?.callback)this.setStreamFunc(streamName,prop,settings[prop].callback);else this.setStreamFunc(streamName,prop,settings.callback)});return this.streamSettings[streamName]};removeStream=(streamName,key)=>{if(streamName&&this.streamSettings[streamName]&&!key){if(this.streamSettings[streamName].onclose)this.streamSettings[streamName].onclose(this.streamSettings[streamName]);this.unsubscribe(streamName);delete this.streamSettings[streamName]}else if(key&&this.streamSettings[streamName]?.settings?.keys){let idx=this.streamSettings[streamName].settings.keys.indexOf(key);if(idx>-1)this.streamSettings[streamName].settings.keys.splice(idx,1);if(this.streamSettings[streamName].settings[key])delete this.streamSettings[streamName].settings[key];return true}return false};updateStreamData=(streamName,data={})=>{if(this.streamSettings[streamName]){Object.assign(this.streamSettings[streamName].object,data);return this.streamSettings[streamName].object}return false};getStreamUpdate=streamName=>{if(!this.streamSettings[streamName])return;let streamUpdate={};this.streamSettings[streamName].settings.keys.forEach(key=>{if(this.streamSettings[streamName].settings[key]){let data=this.streamSettings[streamName].settings[key].callback(this.streamSettings[streamName].object[key],this.streamSettings[streamName].settings[key]);if(data!==void 0)streamUpdate[key]=data}});this.setState({[streamName]:streamUpdate});return streamUpdate};getAllStreamUpdates=()=>{let updateObj={};for(const streamName in this.streamSettings){let streamUpdate=this.getStreamUpdate(streamName);Object.assign(updateObj,streamUpdate)}return updateObj};streamLoop={__operator:this.getAllStreamUpdates,__node:{loop:10}}};var sjcl={cipher:{},hash:{},keyexchange:{},mode:{},misc:{},codec:{},exception:{corrupt:function(a){this.toString=function(){return"CORRUPT: "+this.message};this.message=a},invalid:function(a){this.toString=function(){return"INVALID: "+this.message};this.message=a},bug:function(a){this.toString=function(){return"BUG: "+this.message};this.message=a},notReady:function(a){this.toString=function(){return"NOT READY: "+this.message};this.message=a}}};sjcl.cipher.aes=function(a){this.s[0][0][0]||this.O();var b,c,d,e,f=this.s[0][4],g=this.s[1];b=a.length;var h=1;if(4!==b&&6!==b&&8!==b)throw new sjcl.exception.invalid("invalid aes key size");this.b=[d=a.slice(0),e=[]];for(a=b;a<4*b+28;a++){c=d[a-1];if(0===a%b||8===b&&4===a%b)c=f[c>>>24]<<24^f[c>>16&255]<<16^f[c>>8&255]<<8^f[c&255],0===a%b&&(c=c<<8^c>>>24^h<<24,h=h<<1^283*(h>>7));d[a]=d[a-b]^c}for(b=0;a;b++,a--)c=d[b&3?a:a-4],e[b]=4>=a||4>b?c:g[0][f[c>>>24]]^g[1][f[c>>16&255]]^g[2][f[c>>8&255]]^g[3][f[c&255]]};sjcl.cipher.aes.prototype={encrypt:function(a){return t(this,a,0)},decrypt:function(a){return t(this,a,1)},s:[[[],[],[],[],[]],[[],[],[],[],[]]],O:function(){var a=this.s[0],b=this.s[1],c=a[4],d=b[4],e,f,g,h=[],k=[],l,n,m,p;for(e=0;256>e;e++)k[(h[e]=e<<1^283*(e>>7))^e]=e;for(f=g=0;!c[f];f^=l||1,g=k[g]||1)for(m=g^g<<1^g<<2^g<<3^g<<4,m=m>>8^m&255^99,c[f]=m,d[m]=f,n=h[e=h[l=h[f]]],p=16843009*n^65537*e^257*l^16843008*f,n=257*h[m]^16843008*m,e=0;4>e;e++)a[e][f]=n=n<<24^n>>>8,b[e][m]=p=p<<24^p>>>8;for(e=0;5>e;e++)a[e]=a[e].slice(0),b[e]=b[e].slice(0)}};function t(a,b,c){if(4!==b.length)throw new sjcl.exception.invalid("invalid aes block size");var d=a.b[c],e=b[0]^d[0],f=b[c?3:1]^d[1],g=b[2]^d[2];b=b[c?1:3]^d[3];var h,k,l,n=d.length/4-2,m,p=4,r=[0,0,0,0];h=a.s[c];a=h[0];var q=h[1],v=h[2],w=h[3],x=h[4];for(m=0;m<n;m++)h=a[e>>>24]^q[f>>16&255]^v[g>>8&255]^w[b&255]^d[p],k=a[f>>>24]^q[g>>16&255]^v[b>>8&255]^w[e&255]^d[p+1],l=a[g>>>24]^q[b>>16&255]^v[e>>8&255]^w[f&255]^d[p+2],b=a[b>>>24]^q[e>>16&255]^v[f>>8&255]^w[g&255]^d[p+3],p+=4,e=h,f=k,g=l;for(m=0;4>m;m++)r[c?3&-m:m]=x[e>>>24]<<24^x[f>>16&255]<<16^x[g>>8&255]<<8^x[b&255]^d[p++],h=e,e=f,f=g,g=b,b=h;return r}sjcl.bitArray={bitSlice:function(a,b,c){a=sjcl.bitArray.$(a.slice(b/32),32-(b&31)).slice(1);return void 0===c?a:sjcl.bitArray.clamp(a,c-b)},extract:function(a,b,c){var d=Math.floor(-b-c&31);return((b+c-1^b)&-32?a[b/32|0]<<32-d^a[b/32+1|0]>>>d:a[b/32|0]>>>d)&(1<<c)-1},concat:function(a,b){if(0===a.length||0===b.length)return a.concat(b);var c=a[a.length-1],d=sjcl.bitArray.getPartial(c);return 32===d?a.concat(b):sjcl.bitArray.$(b,d,c|0,a.slice(0,a.length-1))},bitLength:function(a){var b=a.length;return 0===b?0:32*(b-1)+sjcl.bitArray.getPartial(a[b-1])},clamp:function(a,b){if(32*a.length<b)return a;a=a.slice(0,Math.ceil(b/32));var c=a.length;b=b&31;0<c&&b&&(a[c-1]=sjcl.bitArray.partial(b,a[c-1]&2147483648>>b-1,1));return a},partial:function(a,b,c){return 32===a?b:(c?b|0:b<<32-a)+1099511627776*a},getPartial:function(a){return Math.round(a/1099511627776)||32},equal:function(a,b){if(sjcl.bitArray.bitLength(a)!==sjcl.bitArray.bitLength(b))return false;var c=0,d;for(d=0;d<a.length;d++)c|=a[d]^b[d];return 0===c},$:function(a,b,c,d){var e;e=0;for(void 0===d&&(d=[]);32<=b;b-=32)d.push(c),c=0;if(0===b)return d.concat(a);for(e=0;e<a.length;e++)d.push(c|a[e]>>>b),c=a[e]<<32-b;e=a.length?a[a.length-1]:0;a=sjcl.bitArray.getPartial(e);d.push(sjcl.bitArray.partial(b+a&31,32<b+a?c:d.pop(),1));return d},i:function(a,b){return[a[0]^b[0],a[1]^b[1],a[2]^b[2],a[3]^b[3]]},byteswapM:function(a){var b,c;for(b=0;b<a.length;++b)c=a[b],a[b]=c>>>24|c>>>8&65280|(c&65280)<<8|c<<24;return a}};sjcl.codec.utf8String={fromBits:function(a){var b="",c=sjcl.bitArray.bitLength(a),d,e;for(d=0;d<c/8;d++)0===(d&3)&&(e=a[d/4]),b+=String.fromCharCode(e>>>8>>>8>>>8),e<<=8;return decodeURIComponent(escape(b))},toBits:function(a){a=unescape(encodeURIComponent(a));var b=[],c,d=0;for(c=0;c<a.length;c++)d=d<<8|a.charCodeAt(c),3===(c&3)&&(b.push(d),d=0);c&3&&b.push(sjcl.bitArray.partial(8*(c&3),d));return b}};sjcl.codec.hex={fromBits:function(a){var b="",c;for(c=0;c<a.length;c++)b+=((a[c]|0)+0xf00000000000).toString(16).substr(4);return b.substr(0,sjcl.bitArray.bitLength(a)/4)},toBits:function(a){var b,c=[],d;a=a.replace(/\s|0x/g,"");d=a.length;a=a+"00000000";for(b=0;b<a.length;b+=8)c.push(parseInt(a.substr(b,8),16)^0);return sjcl.bitArray.clamp(c,4*d)}};sjcl.codec.base32={B:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",X:"0123456789ABCDEFGHIJKLMNOPQRSTUV",BITS:32,BASE:5,REMAINING:27,fromBits:function(a,b,c){var d=sjcl.codec.base32.BASE,e=sjcl.codec.base32.REMAINING,f="",g=0,h=sjcl.codec.base32.B,k=0,l=sjcl.bitArray.bitLength(a);c&&(h=sjcl.codec.base32.X);for(c=0;f.length*d<l;)f+=h.charAt((k^a[c]>>>g)>>>e),g<d?(k=a[c]<<d-g,g+=e,c++):(k<<=d,g-=d);for(;f.length&7&&!b;)f+="=";return f},toBits:function(a,b){a=a.replace(/\s|=/g,"").toUpperCase();var c=sjcl.codec.base32.BITS,d=sjcl.codec.base32.BASE,e=sjcl.codec.base32.REMAINING,f=[],g,h=0,k=sjcl.codec.base32.B,l=0,n,m="base32";b&&(k=sjcl.codec.base32.X,m="base32hex");for(g=0;g<a.length;g++){n=k.indexOf(a.charAt(g));if(0>n){if(!b)try{return sjcl.codec.base32hex.toBits(a)}catch(p){}throw new sjcl.exception.invalid("this isn't "+m+"!")}h>e?(h-=e,f.push(l^n>>>h),l=n<<c-h):(h+=d,l^=n<<c-h)}h&56&&f.push(sjcl.bitArray.partial(h&56,l,1));return f}};sjcl.codec.base32hex={fromBits:function(a,b){return sjcl.codec.base32.fromBits(a,b,1)},toBits:function(a){return sjcl.codec.base32.toBits(a,1)}};sjcl.codec.base64={B:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",fromBits:function(a,b,c){var d="",e=0,f=sjcl.codec.base64.B,g=0,h=sjcl.bitArray.bitLength(a);c&&(f=f.substr(0,62)+"-_");for(c=0;6*d.length<h;)d+=f.charAt((g^a[c]>>>e)>>>26),6>e?(g=a[c]<<6-e,e+=26,c++):(g<<=6,e-=6);for(;d.length&3&&!b;)d+="=";return d},toBits:function(a,b){a=a.replace(/\s|=/g,"");var c=[],d,e=0,f=sjcl.codec.base64.B,g=0,h;b&&(f=f.substr(0,62)+"-_");for(d=0;d<a.length;d++){h=f.indexOf(a.charAt(d));if(0>h)throw new sjcl.exception.invalid("this isn't base64!");26<e?(e-=26,c.push(g^h>>>e),g=h<<32-e):(e+=6,g^=h<<32-e)}e&56&&c.push(sjcl.bitArray.partial(e&56,g,1));return c}};sjcl.codec.base64url={fromBits:function(a){return sjcl.codec.base64.fromBits(a,1,1)},toBits:function(a){return sjcl.codec.base64.toBits(a,1)}};sjcl.hash.sha256=function(a){this.b[0]||this.O();a?(this.F=a.F.slice(0),this.A=a.A.slice(0),this.l=a.l):this.reset()};sjcl.hash.sha256.hash=function(a){return new sjcl.hash.sha256().update(a).finalize()};sjcl.hash.sha256.prototype={blockSize:512,reset:function(){this.F=this.Y.slice(0);this.A=[];this.l=0;return this},update:function(a){"string"===typeof a&&(a=sjcl.codec.utf8String.toBits(a));var b,c=this.A=sjcl.bitArray.concat(this.A,a);b=this.l;a=this.l=b+sjcl.bitArray.bitLength(a);if(9007199254740991<a)throw new sjcl.exception.invalid("Cannot hash more than 2^53 - 1 bits");if("undefined"!==typeof Uint32Array){var d=new Uint32Array(c),e=0;for(b=512+b-(512+b&511);b<=a;b+=512)u(this,d.subarray(16*e,16*(e+1))),e+=1;c.splice(0,16*e)}else for(b=512+b-(512+b&511);b<=a;b+=512)u(this,c.splice(0,16));return this},finalize:function(){var a,b=this.A,c=this.F,b=sjcl.bitArray.concat(b,[sjcl.bitArray.partial(1,1)]);for(a=b.length+2;a&15;a++)b.push(0);b.push(Math.floor(this.l/4294967296));for(b.push(this.l|0);b.length;)u(this,b.splice(0,16));this.reset();return c},Y:[],b:[],O:function(){function a(a2){return 4294967296*(a2-Math.floor(a2))|0}for(var b=0,c=2,d,e;64>b;c++){e=true;for(d=2;d*d<=c;d++)if(0===c%d){e=false;break}e&&(8>b&&(this.Y[b]=a(Math.pow(c,.5))),this.b[b]=a(Math.pow(c,1/3)),b++)}}};function u(a,b){var c,d,e,f=a.F,g=a.b,h=f[0],k=f[1],l=f[2],n=f[3],m=f[4],p=f[5],r=f[6],q=f[7];for(c=0;64>c;c++)16>c?d=b[c]:(d=b[c+1&15],e=b[c+14&15],d=b[c&15]=(d>>>7^d>>>18^d>>>3^d<<25^d<<14)+(e>>>17^e>>>19^e>>>10^e<<15^e<<13)+b[c&15]+b[c+9&15]|0),d=d+q+(m>>>6^m>>>11^m>>>25^m<<26^m<<21^m<<7)+(r^m&(p^r))+g[c],q=r,r=p,p=m,m=n+d|0,n=l,l=k,k=h,h=d+(k&l^n&(k^l))+(k>>>2^k>>>13^k>>>22^k<<30^k<<19^k<<10)|0;f[0]=f[0]+h|0;f[1]=f[1]+k|0;f[2]=f[2]+l|0;f[3]=f[3]+n|0;f[4]=f[4]+m|0;f[5]=f[5]+p|0;f[6]=f[6]+r|0;f[7]=f[7]+q|0}sjcl.mode.ccm={name:"ccm",G:[],listenProgress:function(a){sjcl.mode.ccm.G.push(a)},unListenProgress:function(a){a=sjcl.mode.ccm.G.indexOf(a);-1<a&&sjcl.mode.ccm.G.splice(a,1)},fa:function(a){var b=sjcl.mode.ccm.G.slice(),c;for(c=0;c<b.length;c+=1)b[c](a)},encrypt:function(a,b,c,d,e){var f,g=b.slice(0),h=sjcl.bitArray,k=h.bitLength(c)/8,l=h.bitLength(g)/8;e=e||64;d=d||[];if(7>k)throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");for(f=2;4>f&&l>>>8*f;f++);f<15-k&&(f=15-k);c=h.clamp(c,8*(15-f));b=sjcl.mode.ccm.V(a,b,c,d,e,f);g=sjcl.mode.ccm.C(a,g,c,b,e,f);return h.concat(g.data,g.tag)},decrypt:function(a,b,c,d,e){e=e||64;d=d||[];var f=sjcl.bitArray,g=f.bitLength(c)/8,h=f.bitLength(b),k=f.clamp(b,h-e),l=f.bitSlice(b,h-e),h=(h-e)/8;if(7>g)throw new sjcl.exception.invalid("ccm: iv must be at least 7 bytes");for(b=2;4>b&&h>>>8*b;b++);b<15-g&&(b=15-g);c=f.clamp(c,8*(15-b));k=sjcl.mode.ccm.C(a,k,c,l,e,b);a=sjcl.mode.ccm.V(a,k.data,c,d,e,b);if(!f.equal(k.tag,a))throw new sjcl.exception.corrupt("ccm: tag doesn't match");return k.data},na:function(a,b,c,d,e,f){var g=[],h=sjcl.bitArray,k=h.i;d=[h.partial(8,(b.length?64:0)|d-2<<2|f-1)];d=h.concat(d,c);d[3]|=e;d=a.encrypt(d);if(b.length)for(c=h.bitLength(b)/8,65279>=c?g=[h.partial(16,c)]:4294967295>=c&&(g=h.concat([h.partial(16,65534)],[c])),g=h.concat(g,b),b=0;b<g.length;b+=4)d=a.encrypt(k(d,g.slice(b,b+4).concat([0,0,0])));return d},V:function(a,b,c,d,e,f){var g=sjcl.bitArray,h=g.i;e/=8;if(e%2||4>e||16<e)throw new sjcl.exception.invalid("ccm: invalid tag length");if(4294967295<d.length||4294967295<b.length)throw new sjcl.exception.bug("ccm: can't deal with 4GiB or more data");c=sjcl.mode.ccm.na(a,d,c,e,g.bitLength(b)/8,f);for(d=0;d<b.length;d+=4)c=a.encrypt(h(c,b.slice(d,d+4).concat([0,0,0])));return g.clamp(c,8*e)},C:function(a,b,c,d,e,f){var g,h=sjcl.bitArray;g=h.i;var k=b.length,l=h.bitLength(b),n=k/50,m=n;c=h.concat([h.partial(8,f-1)],c).concat([0,0,0]).slice(0,4);d=h.bitSlice(g(d,a.encrypt(c)),0,e);if(!k)return{tag:d,data:[]};for(g=0;g<k;g+=4)g>n&&(sjcl.mode.ccm.fa(g/k),n+=m),c[3]++,e=a.encrypt(c),b[g]^=e[0],b[g+1]^=e[1],b[g+2]^=e[2],b[g+3]^=e[3];return{tag:d,data:h.clamp(b,l)}}};sjcl.mode.ocb2={name:"ocb2",encrypt:function(a,b,c,d,e,f){if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception.invalid("ocb iv must be 128 bits");var g,h=sjcl.mode.ocb2.S,k=sjcl.bitArray,l=k.i,n=[0,0,0,0];c=h(a.encrypt(c));var m,p=[];d=d||[];e=e||64;for(g=0;g+4<b.length;g+=4)m=b.slice(g,g+4),n=l(n,m),p=p.concat(l(c,a.encrypt(l(c,m)))),c=h(c);m=b.slice(g);b=k.bitLength(m);g=a.encrypt(l(c,[0,0,0,b]));m=k.clamp(l(m.concat([0,0,0]),g),b);n=l(n,l(m.concat([0,0,0]),g));n=a.encrypt(l(n,l(c,h(c))));d.length&&(n=l(n,f?d:sjcl.mode.ocb2.pmac(a,d)));return p.concat(k.concat(m,k.clamp(n,e)))},decrypt:function(a,b,c,d,e,f){if(128!==sjcl.bitArray.bitLength(c))throw new sjcl.exception.invalid("ocb iv must be 128 bits");e=e||64;var g=sjcl.mode.ocb2.S,h=sjcl.bitArray,k=h.i,l=[0,0,0,0],n=g(a.encrypt(c)),m,p,r=sjcl.bitArray.bitLength(b)-e,q=[];d=d||[];for(c=0;c+4<r/32;c+=4)m=k(n,a.decrypt(k(n,b.slice(c,c+4)))),l=k(l,m),q=q.concat(m),n=g(n);p=r-32*c;m=a.encrypt(k(n,[0,0,0,p]));m=k(m,h.clamp(b.slice(c),p).concat([0,0,0]));l=k(l,m);l=a.encrypt(k(l,k(n,g(n))));d.length&&(l=k(l,f?d:sjcl.mode.ocb2.pmac(a,d)));if(!h.equal(h.clamp(l,e),h.bitSlice(b,r)))throw new sjcl.exception.corrupt("ocb: tag doesn't match");return q.concat(h.clamp(m,p))},pmac:function(a,b){var c,d=sjcl.mode.ocb2.S,e=sjcl.bitArray,f=e.i,g=[0,0,0,0],h=a.encrypt([0,0,0,0]),h=f(h,d(d(h)));for(c=0;c+4<b.length;c+=4)h=d(h),g=f(g,a.encrypt(f(h,b.slice(c,c+4))));c=b.slice(c);128>e.bitLength(c)&&(h=f(h,d(h)),c=e.concat(c,[-2147483648,0,0,0]));g=f(g,c);return a.encrypt(f(d(f(h,d(h))),g))},S:function(a){return[a[0]<<1^a[1]>>>31,a[1]<<1^a[2]>>>31,a[2]<<1^a[3]>>>31,a[3]<<1^135*(a[0]>>>31)]}};sjcl.mode.gcm={name:"gcm",encrypt:function(a,b,c,d,e){var f=b.slice(0);b=sjcl.bitArray;d=d||[];a=sjcl.mode.gcm.C(true,a,f,d,c,e||128);return b.concat(a.data,a.tag)},decrypt:function(a,b,c,d,e){var f=b.slice(0),g=sjcl.bitArray,h=g.bitLength(f);e=e||128;d=d||[];e<=h?(b=g.bitSlice(f,h-e),f=g.bitSlice(f,0,h-e)):(b=f,f=[]);a=sjcl.mode.gcm.C(false,a,f,d,c,e);if(!g.equal(a.tag,b))throw new sjcl.exception.corrupt("gcm: tag doesn't match");return a.data},ka:function(a,b){var c,d,e,f,g,h=sjcl.bitArray.i;e=[0,0,0,0];f=b.slice(0);for(c=0;128>c;c++){(d=0!==(a[Math.floor(c/32)]&1<<31-c%32))&&(e=h(e,f));g=0!==(f[3]&1);for(d=3;0<d;d--)f[d]=f[d]>>>1|(f[d-1]&1)<<31;f[0]>>>=1;g&&(f[0]^=-520093696)}return e},j:function(a,b,c){var d,e=c.length;b=b.slice(0);for(d=0;d<e;d+=4)b[0]^=4294967295&c[d],b[1]^=4294967295&c[d+1],b[2]^=4294967295&c[d+2],b[3]^=4294967295&c[d+3],b=sjcl.mode.gcm.ka(b,a);return b},C:function(a,b,c,d,e,f){var g,h,k,l,n,m,p,r,q=sjcl.bitArray;m=c.length;p=q.bitLength(c);r=q.bitLength(d);h=q.bitLength(e);g=b.encrypt([0,0,0,0]);96===h?(e=e.slice(0),e=q.concat(e,[1])):(e=sjcl.mode.gcm.j(g,[0,0,0,0],e),e=sjcl.mode.gcm.j(g,e,[0,0,Math.floor(h/4294967296),h&4294967295]));h=sjcl.mode.gcm.j(g,[0,0,0,0],d);n=e.slice(0);d=h.slice(0);a||(d=sjcl.mode.gcm.j(g,h,c));for(l=0;l<m;l+=4)n[3]++,k=b.encrypt(n),c[l]^=k[0],c[l+1]^=k[1],c[l+2]^=k[2],c[l+3]^=k[3];c=q.clamp(c,p);a&&(d=sjcl.mode.gcm.j(g,h,c));a=[Math.floor(r/4294967296),r&4294967295,Math.floor(p/4294967296),p&4294967295];d=sjcl.mode.gcm.j(g,d,a);k=b.encrypt(e);d[0]^=k[0];d[1]^=k[1];d[2]^=k[2];d[3]^=k[3];return{tag:q.bitSlice(d,0,f),data:c}}};sjcl.misc.hmac=function(a,b){this.W=b=b||sjcl.hash.sha256;var c=[[],[]],d,e=b.prototype.blockSize/32;this.w=[new b,new b];a.length>e&&(a=b.hash(a));for(d=0;d<e;d++)c[0][d]=a[d]^909522486,c[1][d]=a[d]^1549556828;this.w[0].update(c[0]);this.w[1].update(c[1]);this.R=new b(this.w[0])};sjcl.misc.hmac.prototype.encrypt=sjcl.misc.hmac.prototype.mac=function(a){if(this.aa)throw new sjcl.exception.invalid("encrypt on already updated hmac called!");this.update(a);return this.digest(a)};sjcl.misc.hmac.prototype.reset=function(){this.R=new this.W(this.w[0]);this.aa=false};sjcl.misc.hmac.prototype.update=function(a){this.aa=true;this.R.update(a)};sjcl.misc.hmac.prototype.digest=function(){var a=this.R.finalize(),a=new this.W(this.w[1]).update(a).finalize();this.reset();return a};sjcl.misc.pbkdf2=function(a,b,c,d,e){c=c||1e4;if(0>d||0>c)throw new sjcl.exception.invalid("invalid params to pbkdf2");"string"===typeof a&&(a=sjcl.codec.utf8String.toBits(a));"string"===typeof b&&(b=sjcl.codec.utf8String.toBits(b));e=e||sjcl.misc.hmac;a=new e(a);var f,g,h,k,l=[],n=sjcl.bitArray;for(k=1;32*l.length<(d||1);k++){e=f=a.encrypt(n.concat(b,[k]));for(g=1;g<c;g++)for(f=a.encrypt(f),h=0;h<f.length;h++)e[h]^=f[h];l=l.concat(e)}d&&(l=n.clamp(l,d));return l};sjcl.prng=function(a){this.c=[new sjcl.hash.sha256];this.m=[0];this.P=0;this.H={};this.N=0;this.U={};this.Z=this.f=this.o=this.ha=0;this.b=[0,0,0,0,0,0,0,0];this.h=[0,0,0,0];this.L=void 0;this.M=a;this.D=false;this.K={progress:{},seeded:{}};this.u=this.ga=0;this.I=1;this.J=2;this.ca=65536;this.T=[0,48,64,96,128,192,256,384,512,768,1024];this.da=3e4;this.ba=80};sjcl.prng.prototype={randomWords:function(a,b){var c=[],d;d=this.isReady(b);var e;if(d===this.u)throw new sjcl.exception.notReady("generator isn't seeded");if(d&this.J){d=!(d&this.I);e=[];var f=0,g;this.Z=e[0]=new Date().valueOf()+this.da;for(g=0;16>g;g++)e.push(4294967296*Math.random()|0);for(g=0;g<this.c.length&&(e=e.concat(this.c[g].finalize()),f+=this.m[g],this.m[g]=0,d||!(this.P&1<<g));g++);this.P>=1<<this.c.length&&(this.c.push(new sjcl.hash.sha256),this.m.push(0));this.f-=f;f>this.o&&(this.o=f);this.P++;this.b=sjcl.hash.sha256.hash(this.b.concat(e));this.L=new sjcl.cipher.aes(this.b);for(d=0;4>d&&(this.h[d]=this.h[d]+1|0,!this.h[d]);d++);}for(d=0;d<a;d+=4)0===(d+1)%this.ca&&y(this),e=z(this),c.push(e[0],e[1],e[2],e[3]);y(this);return c.slice(0,a)},setDefaultParanoia:function(a,b){if(0===a&&"Setting paranoia=0 will ruin your security; use it only for testing"!==b)throw new sjcl.exception.invalid("Setting paranoia=0 will ruin your security; use it only for testing");this.M=a},addEntropy:function(a,b,c){c=c||"user";var d,e,f=new Date().valueOf(),g=this.H[c],h=this.isReady(),k=0;d=this.U[c];void 0===d&&(d=this.U[c]=this.ha++);void 0===g&&(g=this.H[c]=0);this.H[c]=(this.H[c]+1)%this.c.length;switch(typeof a){case"number":void 0===b&&(b=1);this.c[g].update([d,this.N++,1,b,f,1,a|0]);break;case"object":c=Object.prototype.toString.call(a);if("[object Uint32Array]"===c){e=[];for(c=0;c<a.length;c++)e.push(a[c]);a=e}else for("[object Array]"!==c&&(k=1),c=0;c<a.length&&!k;c++)"number"!==typeof a[c]&&(k=1);if(!k){if(void 0===b)for(c=b=0;c<a.length;c++)for(e=a[c];0<e;)b++,e=e>>>1;this.c[g].update([d,this.N++,2,b,f,a.length].concat(a))}break;case"string":void 0===b&&(b=a.length);this.c[g].update([d,this.N++,3,b,f,a.length]);this.c[g].update(a);break;default:k=1}if(k)throw new sjcl.exception.bug("random: addEntropy only supports number, array of numbers or string");this.m[g]+=b;this.f+=b;h===this.u&&(this.isReady()!==this.u&&A("seeded",Math.max(this.o,this.f)),A("progress",this.getProgress()))},isReady:function(a){a=this.T[void 0!==a?a:this.M];return this.o&&this.o>=a?this.m[0]>this.ba&&new Date().valueOf()>this.Z?this.J|this.I:this.I:this.f>=a?this.J|this.u:this.u},getProgress:function(a){a=this.T[a?a:this.M];return this.o>=a?1:this.f>a?1:this.f/a},startCollectors:function(){if(!this.D){this.a={loadTimeCollector:B(this,this.ma),mouseCollector:B(this,this.oa),keyboardCollector:B(this,this.la),accelerometerCollector:B(this,this.ea),touchCollector:B(this,this.qa)};if(window.addEventListener)window.addEventListener("load",this.a.loadTimeCollector,false),window.addEventListener("mousemove",this.a.mouseCollector,false),window.addEventListener("keypress",this.a.keyboardCollector,false),window.addEventListener("devicemotion",this.a.accelerometerCollector,false),window.addEventListener("touchmove",this.a.touchCollector,false);else if(document.attachEvent)document.attachEvent("onload",this.a.loadTimeCollector),document.attachEvent("onmousemove",this.a.mouseCollector),document.attachEvent("keypress",this.a.keyboardCollector);else throw new sjcl.exception.bug("can't attach event");this.D=true}},stopCollectors:function(){this.D&&(window.removeEventListener?(window.removeEventListener("load",this.a.loadTimeCollector,false),window.removeEventListener("mousemove",this.a.mouseCollector,false),window.removeEventListener("keypress",this.a.keyboardCollector,false),window.removeEventListener("devicemotion",this.a.accelerometerCollector,false),window.removeEventListener("touchmove",this.a.touchCollector,false)):document.detachEvent&&(document.detachEvent("onload",this.a.loadTimeCollector),document.detachEvent("onmousemove",this.a.mouseCollector),document.detachEvent("keypress",this.a.keyboardCollector)),this.D=false)},addEventListener:function(a,b){this.K[a][this.ga++]=b},removeEventListener:function(a,b){var c,d,e=this.K[a],f=[];for(d in e)e.hasOwnProperty(d)&&e[d]===b&&f.push(d);for(c=0;c<f.length;c++)d=f[c],delete e[d]},la:function(){C(this,1)},oa:function(a){var b,c;try{b=a.x||a.clientX||a.offsetX||0,c=a.y||a.clientY||a.offsetY||0}catch(d){c=b=0}0!=b&&0!=c&&this.addEntropy([b,c],2,"mouse");C(this,0)},qa:function(a){a=a.touches[0]||a.changedTouches[0];this.addEntropy([a.pageX||a.clientX,a.pageY||a.clientY],1,"touch");C(this,0)},ma:function(){C(this,2)},ea:function(a){a=a.accelerationIncludingGravity.x||a.accelerationIncludingGravity.y||a.accelerationIncludingGravity.z;if(window.orientation){var b=window.orientation;"number"===typeof b&&this.addEntropy(b,1,"accelerometer")}a&&this.addEntropy(a,2,"accelerometer");C(this,0)}};function A(a,b){var c,d=sjcl.random.K[a],e=[];for(c in d)d.hasOwnProperty(c)&&e.push(d[c]);for(c=0;c<e.length;c++)e[c](b)}function C(a,b){"undefined"!==typeof window&&window.performance&&"function"===typeof window.performance.now?a.addEntropy(window.performance.now(),b,"loadtime"):a.addEntropy(new Date().valueOf(),b,"loadtime")}function y(a){a.b=z(a).concat(z(a));a.L=new sjcl.cipher.aes(a.b)}function z(a){for(var b=0;4>b&&(a.h[b]=a.h[b]+1|0,!a.h[b]);b++);return a.L.encrypt(a.h)}function B(a,b){return function(){b.apply(a,arguments)}}sjcl.random=new sjcl.prng(6);a:try{if(G="undefined"!==typeof module&&module.exports){try{H=require("crypto")}catch(a){H=null}G=E=H}if(G&&E.randomBytes)D=E.randomBytes(128),D=new Uint32Array(new Uint8Array(D).buffer),sjcl.random.addEntropy(D,1024,"crypto['randomBytes']");else if("undefined"!==typeof window&&"undefined"!==typeof Uint32Array){F=new Uint32Array(32);if(window.crypto&&window.crypto.getRandomValues)window.crypto.getRandomValues(F);else if(window.msCrypto&&window.msCrypto.getRandomValues)window.msCrypto.getRandomValues(F);else break a;sjcl.random.addEntropy(F,1024,"crypto['getRandomValues']")}}catch(a){"undefined"!==typeof window&&window.console&&(console.log("There was an error collecting entropy from the browser:"),console.log(a))}var D;var E;var F;var G;var H;sjcl.json={defaults:{v:1,iter:1e4,ks:128,ts:64,mode:"ccm",adata:"",cipher:"aes"},ja:function(a,b,c,d){c=c||{};d=d||{};var e=sjcl.json,f=e.g({iv:sjcl.random.randomWords(4,0)},e.defaults),g;e.g(f,c);c=f.adata;"string"===typeof f.salt&&(f.salt=sjcl.codec.base64.toBits(f.salt));"string"===typeof f.iv&&(f.iv=sjcl.codec.base64.toBits(f.iv));if(!sjcl.mode[f.mode]||!sjcl.cipher[f.cipher]||"string"===typeof a&&100>=f.iter||64!==f.ts&&96!==f.ts&&128!==f.ts||128!==f.ks&&192!==f.ks&&256!==f.ks||2>f.iv.length||4<f.iv.length)throw new sjcl.exception.invalid("json encrypt: invalid parameters");"string"===typeof a?(g=sjcl.misc.cachedPbkdf2(a,f),a=g.key.slice(0,f.ks/32),f.salt=g.salt):sjcl.ecc&&a instanceof sjcl.ecc.elGamal.publicKey&&(g=a.kem(),f.kemtag=g.tag,a=g.key.slice(0,f.ks/32));"string"===typeof b&&(b=sjcl.codec.utf8String.toBits(b));"string"===typeof c&&(f.adata=c=sjcl.codec.utf8String.toBits(c));g=new sjcl.cipher[f.cipher](a);e.g(d,f);d.key=a;f.ct="ccm"===f.mode&&sjcl.arrayBuffer&&sjcl.arrayBuffer.ccm&&b instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.encrypt(g,b,f.iv,c,f.ts):sjcl.mode[f.mode].encrypt(g,b,f.iv,c,f.ts);return f},encrypt:function(a,b,c,d){var e=sjcl.json,f=e.ja.apply(e,arguments);return e.encode(f)},ia:function(a,b,c,d){c=c||{};d=d||{};var e=sjcl.json;b=e.g(e.g(e.g({},e.defaults),b),c,true);var f,g;f=b.adata;"string"===typeof b.salt&&(b.salt=sjcl.codec.base64.toBits(b.salt));"string"===typeof b.iv&&(b.iv=sjcl.codec.base64.toBits(b.iv));if(!sjcl.mode[b.mode]||!sjcl.cipher[b.cipher]||"string"===typeof a&&100>=b.iter||64!==b.ts&&96!==b.ts&&128!==b.ts||128!==b.ks&&192!==b.ks&&256!==b.ks||!b.iv||2>b.iv.length||4<b.iv.length)throw new sjcl.exception.invalid("json decrypt: invalid parameters");"string"===typeof a?(g=sjcl.misc.cachedPbkdf2(a,b),a=g.key.slice(0,b.ks/32),b.salt=g.salt):sjcl.ecc&&a instanceof sjcl.ecc.elGamal.secretKey&&(a=a.unkem(sjcl.codec.base64.toBits(b.kemtag)).slice(0,b.ks/32));"string"===typeof f&&(f=sjcl.codec.utf8String.toBits(f));g=new sjcl.cipher[b.cipher](a);f="ccm"===b.mode&&sjcl.arrayBuffer&&sjcl.arrayBuffer.ccm&&b.ct instanceof ArrayBuffer?sjcl.arrayBuffer.ccm.decrypt(g,b.ct,b.iv,b.tag,f,b.ts):sjcl.mode[b.mode].decrypt(g,b.ct,b.iv,f,b.ts);e.g(d,b);d.key=a;return 1===c.raw?f:sjcl.codec.utf8String.fromBits(f)},decrypt:function(a,b,c,d){var e=sjcl.json;return e.ia(a,e.decode(b),c,d)},encode:function(a){var b,c="{",d="";for(b in a)if(a.hasOwnProperty(b)){if(!b.match(/^[a-z0-9]+$/i))throw new sjcl.exception.invalid("json encode: invalid property name");c+=d+'"'+b+'":';d=",";switch(typeof a[b]){case"number":case"boolean":c+=a[b];break;case"string":c+='"'+escape(a[b])+'"';break;case"object":c+='"'+sjcl.codec.base64.fromBits(a[b],0)+'"';break;default:throw new sjcl.exception.bug("json encode: unsupported type")}}return c+"}"},decode:function(a){a=a.replace(/\s/g,"");if(!a.match(/^\{.*\}$/))throw new sjcl.exception.invalid("json decode: this isn't json!");a=a.replace(/^\{|\}$/g,"").split(/,/);var b={},c,d;for(c=0;c<a.length;c++){if(!(d=a[c].match(/^\s*(?:(["']?)([a-z][a-z0-9]*)\1)\s*:\s*(?:(-?\d+)|"([a-z0-9+\/%*_.@=\-]*)"|(true|false))$/i)))throw new sjcl.exception.invalid("json decode: this isn't json!");null!=d[3]?b[d[2]]=parseInt(d[3],10):null!=d[4]?b[d[2]]=d[2].match(/^(ct|adata|salt|iv)$/)?sjcl.codec.base64.toBits(d[4]):unescape(d[4]):null!=d[5]&&(b[d[2]]="true"===d[5])}return b},g:function(a,b,c){void 0===a&&(a={});if(void 0===b)return a;for(var d in b)if(b.hasOwnProperty(d)){if(c&&void 0!==a[d]&&a[d]!==b[d])throw new sjcl.exception.invalid("required parameter overridden");a[d]=b[d]}return a},sa:function(a,b){var c={},d;for(d in a)a.hasOwnProperty(d)&&a[d]!==b[d]&&(c[d]=a[d]);return c},ra:function(a,b){var c={},d;for(d=0;d<b.length;d++)void 0!==a[b[d]]&&(c[b[d]]=a[b[d]]);return c}};sjcl.encrypt=sjcl.json.encrypt;sjcl.decrypt=sjcl.json.decrypt;sjcl.misc.pa={};sjcl.misc.cachedPbkdf2=function(a,b){var c=sjcl.misc.pa,d;b=b||{};d=b.iter||1e3;c=c[a]=c[a]||{};d=c[d]=c[d]||{firstSalt:b.salt&&b.salt.length?b.salt.slice(0):sjcl.random.randomWords(2,0)};c=void 0===b.salt?d.firstSalt:b.salt;d[c]=d[c]||sjcl.misc.pbkdf2(a,c,b.iter);return{key:d[c].slice(0),salt:c.slice(0)}};var sjcl_default=sjcl;var E2EEService=class extends Service{name="e2ee";keys;securedKeys=false;encryptedkeys;secret;constructor(options,keys,secureKeys,secret){super(options);if(keys){if(secureKeys&&secret){this.securedKeys=true;this.encryptedkeys=sjcl_default.encrypt(secret,JSON.stringify(keys)).cipher;this.secret=secret}else Object.assign(this.keys,keys)}this.load(this)}addKey=(key,_id)=>{if(!_id)_id=`key${Math.floor(Math.random()*1e15)}`;if(this.securedKeys&&this.secret&&this.encryptedkeys){let decrypted=JSON.parse(sjcl_default.decrypt(this.secret,this.encryptedkeys));decrypted[_id]={key,_id};this.encryptedkeys=sjcl_default.encrypt(this.secret,decrypted).cipher;return this.encryptedkeys}else this.keys[_id]={key,_id};return this.keys[_id]};static generateSecret(){return sjcl_default.codec.base64.fromBits(sjcl_default.random.randomWords(8,10))}encrypt(message,key){message=sjcl_default.encrypt(key,message).cipher;return message}decrypt(message,key){message=sjcl_default.decrypt(key,message);return message}encryptRoute=(message,keyId)=>{if(typeof message==="object")message=JSON.stringify(message);let key;if(this.securedKeys&&this.secret&&this.encryptedkeys){let decrypted=JSON.parse(sjcl_default.decrypt(this.secret,this.encryptedkeys));if(decrypted[keyId]?.key){message=sjcl_default.encrypt(this.secret,decrypted[keyId].key).cipher}}else{if(this.keys[keyId]){if(!key)key=keyId;message=this.encrypt(message,key)}}message={route:"decryptRoute",args:[message,keyId]};return message};decryptRoute=(message,keyId)=>{let decryptedMessage=message;if(typeof message==="object"){if(!keyId){if(typeof message.keyId==="string")keyId=message.keyId}if(keyId){let key;if(this.securedKeys&&this.secret&&this.encryptedkeys){let decrypted=JSON.parse(sjcl_default.decrypt(this.secret,this.encryptedkeys));if(decrypted[keyId]?.key){decryptedMessage=sjcl_default.decrypt(this.secret,decrypted[keyId].key);return decryptedMessage}}else{if(this.keys[keyId])key=this.keys[keyId].key;if(key)decryptedMessage=this.decrypt(message.args,key)}}}else{let key;if(this.securedKeys&&this.secret&&this.encryptedkeys){let decrypted=JSON.parse(sjcl_default.decrypt(this.secret,this.encryptedkeys));if(decrypted[keyId]?.key){decryptedMessage=sjcl_default.decrypt(this.secret,decrypted[keyId].key);return decryptedMessage}}else{if(this.keys[keyId])key=this.keys[keyId].key;if(key)decryptedMessage=this.decrypt(message,key)}}return decryptedMessage};transmit=(message,keyId)=>{if(!keyId){keyId=Object.keys(this.keys)[0]}message=this.encryptRoute(message,keyId);return this.handleServiceMessage(message)};receive=(message,keyId)=>{if(!keyId){keyId=Object.keys(this.keys)[0]}message=this.decryptRoute(message,keyId);if(typeof message==="string"){let substr=message.substring(0,8);if(substr.includes("{")||substr.includes("[")){if(substr.includes("\\"))message=message.replace(/\\/g,"");if(message[0]==='"'){message=message.substring(1,message.length-1)};message=JSON.parse(message)}}if(typeof message==="object"){if(typeof message.method==="string"){return this.handleMethod(message.route,message.method,message.args)}else if(typeof message.route==="string"){return this.handleServiceMessage(message)}else if(typeof message.node==="string"||message.node instanceof GraphNode){return this.handleGraphNodeCall(message.node,message.args)}else if(this.__node.keepState){if(message.route)this.setState({[message.route]:message.args});if(message.node)this.setState({[message.node]:message.args})}}else return message}};var Router=class extends Service{name="router";connections={};sources={};services={};serviceConnections={};users={};userTimeout=1e4;order;constructor(options){super(options);this.load(this);if(options){if(options.order)this.order=options.order;if(options.timeout)this.userTimeout=options.timeout;if(options.graph){for(const key in options.graph){let opt=options.graph[key];if(typeof opt==="function")opt=new opt;if(opt?.__node?.nodes){opt.name=key;opt.__node.tag=key;this.addServices({[opt.name]:opt});this.routeService(opt,opt.connections)}else{if(typeof opt?.service==="function")opt.service=new opt.service;if(opt?.service?.__node?.nodes){opt.service.name=key;opt.service.__node.tag=key;this.addServices({[opt.service.name]:opt.service});this.routeService(opt.service)}if(typeof opt?.service==="object"){if(opt.connections){if(Array.isArray(opt.connections)){opt.connections.forEach(k=>{this.addServiceConnections(opt[key].service,k)})}else this.addServiceConnections(opt.service,opt.connections)}if(opt.config){for(const c in opt.config){this.openConnection(opt.service,opt.config[c],opt.config[c].source,opt.config[c].args)}}}}}}}}addUser=async(info,connections,config,receiving)=>{let user;if(!info._id){info._id=`user${Math.floor(Math.random()*1e15)}`}if(this.users[info._id]){user=this.users[info._id]}else{user=Object.assign({},info)}if(connections){for(const key in connections){if(typeof connections[key]==="object"){if(!connections[key].connection._id){await new Promise((res,rej)=>{let start=performance.now();let checker=()=>{if(!connections[key].connection._id){if(performance.now()-start>this.userTimeout){delete connections[key];rej(false)}else{setTimeout(()=>{checker()},100)}}else{res(true)}};checker()}).catch(er=>{console.error("Connections timed out:",er)})}}}for(const key in connections){connections[key]=this.addConnection(connections[key],user._id)}}if(config){for(const c in config){this.openConnection(config[c].service,config[c],user._id,config[c].args)}}if(!this.users[info._id]){let send=(message,...a)=>{let connection=this.getConnection(user._id,"send");if(connection?.send)return connection.send(message,...a)};let sendAll=(message,...a)=>{let connections2=this.getConnections(user._id,"send");for(const key in connections2)if(connections2[key]?.send)return connections2[key].send(message,...a)};let request=(message,method,...a)=>{let connection=this.getConnection(user._id,"request");if(connection?.request)return connection.request(message,method,...a)};let requestAll=(message,method,...a)=>{let connections2=this.getConnections(user._id,"request");let results=[];for(const key in connections2)if(connections2[key]?.request)results.push(connections2[key].request(message,method,...a));return Promise.all(results)};let post=(route,args,method,...a)=>{let connection=this.getConnection(user._id,"post");if(connection?.post)return connection.post(route,args,method,...a)};let postAll=(route,args,method,...a)=>{let connections2=this.getConnections(user._id,"post");for(const key in connections2)if(connections2[key]?.post)connections2[key].post(route,args,method,...a)};let run=(route,args,method,...a)=>{let connection=this.getConnection(user._id,"run");if(connection?.run)return connection.run(route,args,method,...a)};let runAll=(route,args,method,...a)=>{let connections2=this.getConnections(user._id,"run");let results=[];for(const key in connections2)if(connections2[key]?.run)results.push(connections2[key].run(route,args,method,...a));return Promise.all(results)};let subscribe=(route,callback,...a)=>{let connection=this.getConnection(user._id,"subscribe");if(connection?.subscribe)return connection.subscribe(route,callback,...a)};let subscribeAll=(route,callback,...a)=>{let connections2=this.getConnections(user._id,"subscribe");let results=[];for(const key in connections2)if(connections2[key]?.post)results.push(connections2[key].subscribe(route,callback,...a));return Promise.all(results)};let unsubscribe=(route,sub,...a)=>{let connection=this.getConnection(user._id,"unsubscribe");if(connection?.unsubscribe)return connection.unsubscribe(route,sub,...a)};let unsubscribeAll=(route,subs,...a)=>{let connections2=this.getConnections(user._id,"unsubscribe");let results=[];for(const key in connections2)if(connections2[key]?.post&&subs?.[key])results.push(connections2[key].unsubscribe(route,subs[key],...a));return Promise.all(results)};let terminate=()=>{return this.removeUser(user)};user.send=send;user.request=request;user.post=post;user.run=run;user.subscribe=subscribe;user.unsubscribe=unsubscribe;user.terminate=terminate;user.sendAll=sendAll;user.requestAll=requestAll;user.postAll=postAll;user.runAll=runAll;user.subscribeAll=subscribeAll;user.unsubscribeAll=unsubscribeAll;user.terminateAll=terminate;this.users[user._id]=user}if(connections&&!receiving){let connectionIds={};let pass=false;Object.keys(connections).map((k,i)=>{if(connections[k]?._id){connectionIds[`${i}`]=connections[k]?._id;pass=true}});if(pass){user.send({route:"addUser",args:[{_id:user._id},connectionIds,void 0,true]})}}return user};removeUser(profile,terminate){if(terminate)this.removeConnection(profile,terminate);if(typeof profile==="string")profile=this.users[profile];if(typeof profile==="object"&&profile._id){delete this.users[profile._id];if(profile.onclose)profile.onclose(profile)}return true}getConnection=(sourceId,hasMethod,connectionId)=>{if(this.connections[sourceId]){return this.connections[sourceId]}else if(this.sources[sourceId]){if(hasMethod?.includes("All"))return this.users[sourceId];if(connectionId){if(hasMethod){if(this.sources[sourceId][connectionId]?.[hasMethod])return this.sources[sourceId][connectionId]}else if(this.sources[sourceId][connectionId])return this.sources[sourceId][connectionId];else return void 0}else if(this.order){for(let i=0;i<this.order.length;i++){let k=this.order[i];for(const key in this.sources[sourceId]){if(this.sources[sourceId][key].service){if(typeof this.sources[sourceId][key].service==="object"){if(this.sources[sourceId][key].service.__node.tag===k){if(this.sources[sourceId][key].connectionType&&this.sources[sourceId][key].service?.name){if(!this.serviceConnections[this.sources[sourceId][key].service.name]){this.removeConnection(this.sources[sourceId][key]);continue}}if(hasMethod){if(this.sources[sourceId][key][hasMethod])return this.sources[sourceId][key]}else return this.sources[sourceId][key]}}else if(this.sources[sourceId][key].service===k){if(this.sources[sourceId][key].connectionType&&this.sources[sourceId][key].service?.name){if(!this.serviceConnections[this.sources[sourceId][key].service.name])this.removeConnection(this.sources[sourceId][key]);continue}if(hasMethod){if(this.sources[sourceId][key][hasMethod])return this.sources[sourceId][key]}else return this.sources[sourceId][key]}}}}}else{for(const k in this.sources[sourceId]){if(this.sources[sourceId][k].connectionType&&this.sources[sourceId][k].service?.name){if(!this.serviceConnections[this.sources[sourceId][k].service.name]){this.removeConnection(this.sources[sourceId][k]);continue}}if(hasMethod){if(this.sources[sourceId][k][hasMethod])return this.sources[sourceId][k]}else{return this.sources[sourceId][k]}}}}else if(this.order&&!this.connections[sourceId]){for(let i=0;i<this.order.length;i++){let k=this.order[i];if(this.sources[k]?.[sourceId]){if(this.sources[k][sourceId].connectionType&&this.sources[k][sourceId].service?.name){if(!this.serviceConnections[this.sources[k][sourceId].service.service.name]){this.removeConnection(this.sources[k][sourceId].service);continue}}if(hasMethod){if(this.sources[k][sourceId][hasMethod])return this.sources[k][sourceId]}else{return this.sources[k][sourceId]}}}}};getConnections=(sourceId,hasMethod,props)=>{if(this.sources[sourceId]){if(!props&&!hasMethod)return this.sources[sourceId];let found={};for(const key in this.sources[sourceId]){if(typeof this.sources[sourceId][key]==="object"){if(!this.sources[sourceId][key]._id){for(const k in this.sources[sourceId][key]){if(typeof this.sources[sourceId][key][k]==="object"){let pass=true;if(hasMethod&&!this.sources[sourceId][key][k][hasMethod])pass=false;if(props){for(const p in props){if(typeof this.sources[sourceId][key][k][p]==="object"&&typeof props[p]==="object"){for(const pp in props[p]){if(props[p][pp]!==this.sources[sourceId][key][k][p][pp]){pass=false;break}}}else if(this.sources[sourceId][key][k][p]!==props[p]){pass=false}else{pass=false;break}}}if(pass){found[this.sources[sourceId][key][k]._id]=this.sources[sourceId][key][k]}}}}else{let pass=true;if(hasMethod&&!this.sources[sourceId][key][hasMethod])pass=false;if(props){for(const p in props){if(typeof this.sources[sourceId][key][p]==="object"&&typeof props[p]==="object"){for(const pp in props[p]){if(props[p][pp]!==this.sources[sourceId][key][p][pp]){pass=false;break}}}else if(this.sources[sourceId][key][p]!==props[p]){pass=false}else{pass=false;break}}}if(pass){found[this.sources[sourceId][key]._id]=this.sources[sourceId][key]}}}}return found}};runConnection=async(userId,method,args,connectionId)=>{let sendTo;if(method.indexOf("All")>-1){sendTo=this.users[userId]}else{sendTo=this.getConnection(userId,method,connectionId)}if(sendTo){let res=sendTo[method](...args);res=await res;return res}};subscribeThroughConnection=(route,remoteRelay,remoteEndpoint,callback,...args)=>{if(typeof remoteRelay==="string"){remoteRelay=this.getConnection(remoteRelay,"run")}if(typeof remoteRelay==="object")return new Promise((res,rej)=>{remoteRelay.run("routeConnections",[route,remoteEndpoint,remoteRelay._id,...args]).then(sub=>{this.__node.state.subscribeEvent(remoteEndpoint,res2=>{if(res2?.callbackId===route){if(!callback)this.setState({[remoteEndpoint]:res2.args});else if(typeof callback==="string"){this.setState({[callback]:res2.args})}else callback(res2.args)}});res(sub)}).catch(rej)})};addConnection=(options,source,autoRemove=true)=>{let settings={};if(typeof options==="string"){if(this.connections[options]){options=this.connections[options]}else{for(const j in this.serviceConnections){for(const k in this.serviceConnections[j]){if(this.serviceConnections[j][k][options]){options={connection:this.serviceConnections[j][k][options]};options.service=j;settings.connectionType=j;settings.connectionsKey=k;break}}}}if(typeof options==="string"&&this.__node.nodes.get(options))options={connection:this.__node.nodes.get(options)}}if(!options||typeof options==="string")return void 0;if(source)settings.source=source;if(options.connection instanceof GraphNode){settings.connection=options.connection;let node=settings.connection;settings.send=async message=>{if(message.method){if(Array.isArray(message.args)){return node[message.method]?.(...message.args)}else return node[message.method]?.(message.args)}else{if(!node.__operator)return;if(Array.isArray(message.args)){return node.__operator(...message.args)}else return node.__operator(message.args)}};settings.request=async(message,method)=>{if(method){if(Array.isArray(message.args)){return node[method]?.(...message.args)}else return node[method]?.(message.args)}else{if(!node.__operator)return;if(Array.isArray(message.args)){return node.__operator(...message.args)}else return node.__operator(message.args)}};settings.post=async(route,args,method)=>{if(route&&node.__node.graph.get(route)){let n=node.__node.graph.get(route);if(method){if(Array.isArray(args)){return n[method]?.(...args)}else return n[method]?.(args)}else{if(Array.isArray(args)){return n.__operator(...args)}else return n.__operator(args)}}else{if(method){if(Array.isArray(args)){return node[method]?.(...args)}else return node[method]?.(args)}else{if(Array.isArray(args)){return node.__operator(...args)}else return node.__operator(args)}}};settings.run=settings.post;settings.subscribe=async callback=>{return node.__subscribe(callback)};settings.unsubscribe=async sub=>{return node.__unsubscribe(sub)};settings.terminate=()=>{node.__node.graph.remove(node);return true};settings.onclose=options.onclose;if(settings.onclose){node.__addOndisconnected(n=>{if(settings.onclose)settings.onclose(settings,n)})}}else if(options.connection instanceof Graph){if(options.connection.__node.nodes.get("open"))settings.service=options.connection;let graph=settings.connection;settings.send=async message=>{if(Array.isArray(message.args))graph.run(message.route,...message.args);else graph.run(message.route,message.args)};settings.request=async(message,method)=>{if(!message.route)return void 0;if(method){if(Array.isArray(message.args)){return graph.__node.nodes.get(message.route)[method]?.(...message.args)}else return graph.__node.nodes.get(message.route)[method]?.(message.args)}else{if(Array.isArray(message.args)){return graph.run(message.route,...message.args)}else return graph.run(message.route,message.args)}};settings.post=async(route,args,method)=>{if(route&&graph.get(route)){let n=graph.get(route);if(method){if(Array.isArray(args)){return n[method]?.(...args)}else return n[method]?.(args)}else{if(Array.isArray(args)){return n.run(...args)}else return n.run(args)}}};settings.run=settings.post;settings.subscribe=async(route,callback)=>{return graph.subscribe(route,callback)};settings.unsubscribe=async(route,sub)=>{return graph.unsubscribe(route,sub)};settings.terminate=n=>{graph.remove(n);return true}}else if(!(options._id&&this.connections[options._id])){let c=options.connection;if(typeof c==="string"){if(this.connections[c])c=this.connections[c];else if(options.service){if(typeof options.service==="string"){options.service=this.services[options.service]}if(typeof options.service==="object"){if(options.service.connections){for(const key in options.service.connections){if(options.service.connections[key][c]){c=options.service.connections[key][c];settings.connectionType=key;settings.connectionsKey=c;break}}}}}else{for(const j in this.serviceConnections){for(const k in this.serviceConnections[j]){if(this.serviceConnections[j][k][c]){c=this.serviceConnections[j][k][c];options.service=j;settings.connectionType=j;settings.connectionsKey=k;break}}}}}if(typeof c!=="object")return void 0;settings._id=c._id;settings.connection=options.connection;settings.send=c.send;settings.request=c.request;settings.run=c.run;settings.post=c.post;settings.subscribe=c.subscribe;settings.unsubscribe=c.unsubscribe;settings.terminate=c.terminate;settings.onclose=options.onclose;if(settings.onclose){if(!(c.onclose&&settings.onclose.toString()===c.onclose.toString())){let oldonclose=c.onclose;c.onclose=(...args)=>{if(settings.onclose)settings.onclose(settings,...args);if(autoRemove&&settings.source&&this.users[settings.source]&&Object.keys(this.sources[settings.source]).length===0){this.removeUser(settings.source,false)}if(oldonclose)oldonclose(...args)}}}else{let oldonclose=c.onclose;c.onclose=(...args)=>{this.removeConnection(settings);if(autoRemove&&settings.source&&this.users[settings.source]&&Object.keys(this.sources[settings.source]).length===0){this.removeUser(settings.source,false)}if(oldonclose)oldonclose(...args)}}if(options.service){if(typeof options.service==="string")options.service=this.services[options.service];settings.service=options.service}else if(c.graph)settings.service=c.graph}if(!settings.source&&options.source){settings.source=options.source}else if(!settings.source&&options.service){settings.source=typeof options.service==="object"?options.service?.name:void 0}else if(!settings.source&&(settings.connection instanceof GraphNode||settings.connection instanceof Graph)){settings.source="local";if(!this.order.indexOf("local"))this.order.unshift("local")}if(!settings._id)settings._id=`connection${Math.floor(Math.random()*1e15)}`;if(settings.source){if(!this.sources[settings.source])this.sources[settings.source]={};this.sources[settings.source][settings._id]=settings}if(!this.connections[settings._id])this.connections[settings._id]=settings;return settings};removeConnection=(connection,terminate=false)=>{if(typeof connection==="object"&&connection._id)connection=connection._id;if(typeof connection==="string"){if(this.connections[connection]){if(terminate&&this.connections[connection])this.connections[connection].terminate();delete this.connections[connection];for(const key in this.sources){if(this.sources[key][connection])delete this.sources[key][connection];else{for(const k in this.sources[key]){if(this.sources[key][k]?.[connection]){delete this.sources[key][connection]}}}}return true}else if(this.sources[connection]){for(const key in this.sources[connection]){this.removeConnection(this.sources[connection][key],terminate)}return true}}};routeService=(service,connections,source,order)=>{this.services[service.name]=service;if(service.__node?.nodes)this.__node.nodes.forEach((n,k)=>{if(!service.__node?.nodes.get(k)){service.__node?.nodes.set(k,n)}else service.__node?.nodes.set(this.name+"."+k,n)});if(service.users)service.users=this.users;if(connections){if(typeof connections==="string")this.addServiceConnections(service,connections,source);else{for(const c in connections){this.addServiceConnections(service,c,source)}}}if(order)this.order=order;else{if(!this.order)this.order=[];this.order.push(service.name)}};addServiceConnections=(service,connectionsKey,source)=>{if(typeof service==="string"){service=this.services[service]}if(connectionsKey&&service[connectionsKey]){let newConnections={};if(!this.serviceConnections[service.name])this.serviceConnections[service.name]={};this.serviceConnections[service.name][connectionsKey]=service[connectionsKey];for(const key in service[connectionsKey]){if(!this.connections[key]){newConnections[key]=this.addConnection({connection:service[connectionsKey][key],service},source);newConnections[key].connectionType=connectionsKey}}return newConnections}};openConnection=async(service,options,source,...args)=>{if(typeof service==="string"){service=this.services[service]}if(service?.__node.nodes){let connection=service.run("open",options,...args);if(connection instanceof Promise){return connection.then(async info=>{if(!info._id){await connectionHasId(info,this.userTimeout)}if(info._id)this.addConnection({connection:info,service},source)})}else if(connection){if(!connection._id){await connectionHasId(connection,this.userTimeout)}if(connection._id)return this.addConnection({connection,service},source)}}};terminate=connection=>{if(typeof connection==="string")connection=this.connections[connection];return connection.terminate()};routeConnections=(route,transmitter,receiver,...args)=>{let rxsrc;if(typeof receiver==="string"){if(this.sources[receiver]){rxsrc=receiver}receiver=this.getConnection(receiver,"send")}if(typeof transmitter==="string"){transmitter=this.getConnection(transmitter,"subscribe")}if(transmitter?.subscribe&&receiver?.send){let res=new Promise((res2,rej)=>{transmitter.subscribe(route,res3=>{if(!this.connections[receiver._id]&&rxsrc){if(this.sources[rxsrc]){rxsrc=receiver;Object.keys(this.sources[rxsrc]).forEach(k=>{if(this.sources[receiver][k].send){receiver=this.sources[receiver][k]}})}}if(this.connections[receiver._id])receiver.send({callbackId:route,args:res3})},...args).then(sub=>{res2(sub)})});return res}};setUserData=(user,data)=>{if(user){if(typeof user==="string"){user=this.users[user];if(!user)return false}}if(data){if(typeof data==="string"){data=JSON.parse(data)}}if(typeof data==="object"){this.recursivelyAssign(user,data);return true}}};function connectionHasId(connection,timeout=1e4){return new Promise((res,rej)=>{let start=performance.now();let checker=()=>{if(!connection._id){if(performance.now()-start>timeout){rej(false)}else{setTimeout(()=>{checker()},100)}}else{res(true)}};checker()}).catch(er=>{console.error("Connection timed out:",er)})}var http=__toESM(require("http"));var https=__toESM(require("https"));var fs=__toESM(require("fs"));var path=__toESM(require("path"));function htmlBodyBoilerPlate(html){let template=`<!DOCTYPE html><html><head><body>`;if(Array.isArray(html)){html.forEach(src=>{template+=src})}else{template+=html}template+=`</body></html>`;return template}function scriptBoilerPlate(scripts){let template=`<!DOCTYPE html><html><head><body>`;if(Array.isArray(scripts)){scripts.forEach(src=>{template+=`<script src="${src}"></script>`})}else{template+=`<script src="${scripts}"></script>`}template+=`</body></html>`;return template}var defaultServiceWorker=function(cacheExpirationDays=4/24){return`//https://github.com/ibrahima92/pwa-with-vanilla-js

//https://github.com/ibrahima92/pwa-with-vanilla-js
let cacheName = 'pwa-assets';
const assets = [
  "/",
  "/index.html",
  "/dist/index.css", //alt default paths
  "/dist/index.js",
  '/favicon.ico'
];

let cacheExpiration = 1000 * 60 * //seconds 
  60 * //minutes
  24 * //hours
  ${cacheExpirationDays};    //days

let isValid = function (response) {
	if (!response) return false;
	var fetched = response.headers.get('sw-fetched-on');
	if (fetched && (!navigator.onLine || (parseFloat(fetched) + (cacheExpiration)) > new Date().getTime())) 
      return true;
	return false;
};

self.addEventListener("install", installEvent => {
  installEvent.waitUntil(
    caches.open(cacheName).then(cache => {
      cache.addAll(assets);
    })
  );
});

self.addEventListener("fetch", fetchEvent => { //https://gomakethings.com/how-to-set-an-expiration-date-for-items-in-a-service-worker-cache/
  fetchEvent.respondWith(
    caches.match(fetchEvent.request).then(function (response) {

        // If there's a cached API and it's still valid, use it
        if (isValid(response)) {
            return response;
        }

        // Otherwise, make a fresh API call
        if(response && !assets.includes(fetchEvent.request.url)) return response;
        // Otherwise, make a fresh API call
        else return fetch(fetchEvent.request).then(function (response) {

            // Cache for offline access
            if(assets.includes(fetchEvent.request.url)){
              var copy = response.clone();
              fetchEvent.waitUntil(caches.open(cacheName).then(function (cache) {
                var headers = new Headers(copy.headers);
                headers.append('sw-fetched-on', new Date().getTime());
                return copy.blob().then(function (body) {
                  return cache.put(fetchEvent.request, new Response(body, {
                    status: copy.status ? copy.status : 200,
                    statusText: copy.statusText,
                    headers: headers
                  }));
                });
              }));
            }
            
            // Return the requested file
            return response;

        })
        // .catch(function (error) {
        // 	return caches.match(request).then(function (response) { //fallback to offline cache
        // 		return response || caches.match('/offline.json'); //todo: figure out what is supposed to go in offline.json (https://gomakethings.com/how-to-set-an-expiration-date-for-items-in-a-service-worker-cache/)
        // 	});
        // });  
  }));
});

`};var defaultManifest=(pwaName="PWA")=>{return`{
    "short_name": "${pwaName}",
    "name": "${pwaName}",
    "start_url": "/",
    "display": "standalone",
    "theme_color": "#000000",
    "background_color": "#ffffff",
    "description": "${pwaName} Test",
    "lang": "en-US",
    "permissions": [
        "storage"
    ],
    "icons":[{
        "src": "./assets/logo196.png",
        "sizes": "196x196"
    },
    {
        "src": "./assets/logo512.png",
        "sizes": "512x512"
    }]
}`};var HTTPbackend=class extends Service{name="http";server;debug=false;servers={};mimeTypes={".html":"text/html",".htm":"text/html",".js":"text/javascript",".css":"text/css",".json":"application/json",".txt":"text/plain",".png":"image/png",".jpg":"image/jpg",".jpeg":"image/jpg",".gif":"image/gif",".svg":"image/svg+xml",".xhtml":"application/xhtml+xml",".bmp":"image/bmp",".wav":"audio/wav",".mp3":"audio/mpeg",".mp4":"video/mp4",".xml":"application/xml",".webm":"video/webm",".webp":"image/webp",".weba":"audio/webm",".woff":"font/woff","woff2":"font/woff2",".ttf":"application/font-ttf",".eot":"application/vnd.ms-fontobject",".otf":"application/font-otf",".wasm":"application/wasm",".zip":"application/zip",".xlsx":"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",".tif":"image/tiff",".sh":"application/x-sh",".csh":"application/x-csh",".rar":"application/vnd.rar",".ppt":"application/vnd.ms-powerpoint",".pptx":"application/vnd.openxmlformats-officedocument.presentationml.presentation",".odt":"application/vnd.oasis.opendocument.text",".ods":"application/vnd.oasis.opendocument.spreadsheet",".odp":"application/vnd.oasis.opendocument.presentation",".mpeg":"video/mpeg",".mjs":"text/javascript",".cjs":"text/javascript",".jsonld":"application/ld+json",".jar":"application/java-archive",".ico":"image/vnd.microsoft.icon",".gz":"application/gzip","epub":"application/epub+zip",".doc":"application/msword",".docx":"application/vnd.openxmlformats-officedocument.wordprocessingml.document",".csv":"text/csv",".avi":"video/x-msvideo",".aac":"audio/aac",".mpkg":"application/vnd.apple.installer+xml",".oga":"audio/ogg",".ogv":"video/ogg","ogx":"application/ogg",".php":"application/x-httpd-php",".rtf":"application/rtf",".swf":"application/x-shockwave-flash",".7z":"application/x-7z-compressed",".3gp":"video/3gpp"};constructor(options,settings){super(options);this.load(this);if(settings){this.setupServer(settings)}}onStarted=(protocol,host,port)=>{console.log(`\u{1F431} Node server running at 
            ${protocol}://${host}:${port}/`)};setupServer=(options={protocol:"http",host:"localhost",port:8080,startpage:"index.html"},requestListener,onStarted)=>{if(options.pages){for(const key in options.pages){if(typeof options.pages[key]==="string"){this.addPage(`${options.port}/${key}`,options.pages[key])}else if(typeof options.pages[key]==="object"||typeof options.pages[key]==="function"){if(options.pages[key].template){options.pages[key].get=options.pages[key].template}let rt=`${options.port}/${key}`;if(key!=="_all")this.load({[rt]:options.pages[key]})}}}this.setupHTTPserver(options,requestListener,onStarted)};open=this.setupServer;setupHTTPserver=(options={host:"localhost",port:8080,startpage:"index.html",errpage:void 0},requestListener,onStarted=()=>{this.onStarted("http",options.host,options.port)})=>{const host=options.host?options.host:"localhost";const port=options.port?options.port:8e3;if(!host||!port)return;const address=`${host}:${port}`;if(this.servers[address])this.terminate(this.servers[address]);if(!("keepState"in options))options.keepState=true;const served={server:void 0,type:"httpserver",address,...options};if(!requestListener)requestListener=(request,response)=>{let received={args:{request,response},method:request.method,served};let url=request.url.slice(1);if(!url)url="/";if(options.debug){let time=getHoursAndMinutes(new Date);console.log(time," | ","From: ",request.socket?.remoteAddress,"For: ",request.url," | ",request.method)}if(options.pages){getPageOptions.call(this,url,received,options.pages,request,response,options.port)}else received.route=url;this.receive(received)};let server=void 0;if(options.protocol==="http")server=http.createServer(requestListener);else{let opts;if(options.keypath&&options.certpath){opts={key:fs.readFileSync(options.keypath),cert:fs.readFileSync(options.certpath),passphrase:options.passphrase};server=https.createServer(opts,requestListener)}else console.error("Error, key and/or cert .pem SSL files not provided. See OpenSSL certbot for more info on how to create free SSL certifications, or create your own self-signed one for local development.")}if(!server){console.error("Server not successfully created.");return void 0}served.server=server;served.terminate=()=>{this.terminate(served)};served.service=this;this.servers[address]=served;served._id=options._id?options._id:address;return new Promise((resolve,reject)=>{let resolved;server.on("error",err=>{if(served.onerror)served.onerror(err,served);else console.error("Server error:",err.toString());if(!resolved)reject(err)});server.on("clientError",(err,socket)=>{if(served.onerror)served.onerror(err,served);else console.error(getHoursAndMinutes(new Date)," | Server clientError:",err.toString()," | From: ",socket.remoteAddress);if(socket)socket.destroy()});server.on("tlsClientError",(err,socket)=>{if(served.onerror)served.onerror(err,served);else console.error(getHoursAndMinutes(new Date)," | Server tlsClientError: ",err.toString()," | From: ",socket.remoteAddress);if(socket)socket.destroy()});server.on("upgrade",(request,socket,head)=>{if(served.onupgrade)served.onupgrade(request,socket,head,served)});server.listen(port,host,()=>{onStarted();if(served.onopen)served.onopen(served);resolved=true;resolve(served)})})};transmit=(message,options,ondata,onend)=>{let input=message;if(typeof input==="object"&&!input.byteLength)input=JSON.stringify(input);if(typeof options==="string"&&message)return this.POST(options,message);else if(typeof options==="string")return this.GET(options);if(!options){let server=this.servers[Object.keys(this.servers)[0]];options={protocol:server.protocol,host:server.host,port:server.port,method:"POST",path:message.route,headers:{"Content-Type":"application/json","Content-Length":input.length}}}else if(!options.headers){options.headers={"Content-Type":"application/json","Content-Length":input.length}}return this.request(options,input,ondata,onend)};withResult=(response,result,message)=>{if(result&&!response.writableEnded&&!response.destroyed){let mimeType="text/plain";let head={};if(typeof result==="string"){let extname2=path.extname(result);if(extname2&&fs.existsSync(path.join(process.cwd(),result))){mimeType=this.mimeTypes[extname2]||"application/octet-stream";result=fs.readFileSync(path.join(process.cwd(),result));if(mimeType==="text/html"&&(message.served?.pages?._all||message.served?.pages?.[message.route])){let{templateString,headers}=this.injectPageCode(result.toString(),message.route,message.served);result=templateString;Object.assign(head,headers)}}else if(typeof result==="string"&&result.includes("<")&&result.includes(">")&&result.indexOf("<")<result.indexOf(">")){head["Content-Type"]="text/html";if(message?.served?.pages?._all||message?.served?.pages?.[message.route]){let{templateString,headers}=this.injectPageCode(result,message.route,message.served);result=templateString;Object.assign(head,headers)}response.writeHead(200,head);response.end(result,"utf-8");return}}else if(typeof result==="object"){result=JSON.stringify(result);mimeType="application/json"}head["Content-Type"]=mimeType;response.writeHead(200,head);response.end(result,"utf-8")}else{try{response.destroy()}catch{}}};injectPageCode=(templateString,url,served)=>{if(served?.pages?.[url]?.inject){if(typeof served.pages[url].inject==="object")templateString=this.buildPage(served.pages[url].inject,templateString);else if(typeof served.pages[url].inject==="function")templateString+=served.pages[url].inject();else if(typeof served.pages[url].inject==="string"||typeof served.pages[url].inject==="number")templateString+=served.pages[url].inject}if(served?.pages?._all?.inject){if(typeof served.pages._all.inject==="object")templateString=this.buildPage(served.pages._all.inject,templateString);else if(typeof served.pages._all.inject==="function")templateString+=served.pages._all.inject();else if(typeof served.pages._all.inject==="string"||typeof served.pages._all.inject==="number")templateString+=served.pages._all.inject}let headers={};if(served.pages._all?.headers)Object.assign(headers,served.pages._all.headers);if(served.pages[url]?.headers)Object.assign(headers,served.pages[url].headers);return{templateString,headers}};receive=message=>{if(this.debug)console.log(message.args.request.method,message.args.request.url);let result=new Promise((resolve,reject)=>{this.responsePromiseHandler(resolve,reject,message,message.args.request,message.args.response,message.method,message.served)}).catch(er=>{console.error("Request Error:",er)});return result};responseOnErrorPromiseHandler=(response,reject,err)=>{if(!response.writableEnded||!response.destroyed){response.statusCode=400;response.end(void 0,void 0);reject(err)}else{try{response.destroy()}catch{}reject(err)}};getFailedPromiseHandler=(resolve,reject,requestURL,message,response,served)=>{if(response.writableEnded||response.destroyed)reject(requestURL);if(requestURL=="./"||requestURL==served?.startpage){let template=`<!DOCTYPE html><html><head></head><body style='background-color:#101010 color:white;'><h1>Brains@Play Server</h1></body></html>`;if(served?.pages?._all||served?.pages?.error){let{templateString,headers}=this.injectPageCode(template,message.route,served);template=templateString}response.writeHead(200,{"Content-Type":"text/html"});response.end(template,"utf-8");resolve(template);if(served?.keepState)this.setState({[served.address]:template});return}else if(this.debug)console.log(`File ${requestURL} does not exist on path!`);response.writeHead(500);response.end(void 0,void 0);reject(requestURL)};handleBufferedPostBodyPromiseHandler=(resolve,body,message,response,served)=>{body=Buffer.concat(body).toString();if(typeof body==="string"){let substr=body.substring(0,8);if(substr.includes("{")||substr.includes("[")){if(substr.includes("\\"))body=body.replace(/\\/g,"");if(body[0]==='"'){body=body.substring(1,body.length-1)};body=JSON.parse(body)}}let route,method,args;if(body?.route){route=body.route;method=body.method;args=body.args;if(!route){if(typeof body.route==="string"){if(body.route.includes("/")&&body.route.length>1)body.route=body.route.split("/").pop()}route=body.route}}if(!route){if(message?.route){let route2=message.route;method=message.method;args=message.args;if(!route2){if(typeof message.route==="string"){if(message.route.includes("/")&&message.route.length>1)message.route=message.route.split("/").pop()}route2=message.route}}}let res=body;if(route){if(this.restrict?.[route]){try{response.destroy()}catch{}resolve(res)}else{if(body.method){res=this.handleMethod(route,method,args)}else if(body.node){res=this.handleGraphNodeCall(body.node,body.args)}else res=this.handleServiceMessage({route,args,method});if(res instanceof Promise){res.then(r=>{this.withResult(response,r,message);if(served?.keepState)this.setState({[served.address]:res});resolve(res)})}else{this.withResult(response,res,message);if(served?.keepState)this.setState({[served.address]:res});resolve(res)}}}else if(!response.writableEnded||!response.destroyed){response.statusCode=200;response.end(void 0,void 0);resolve(res)}else{try{response.destroy()}catch{}resolve(res)}};onRequestFileReadPromiseHandler=(error,content,resolve,reject,requestURL,response,message,served)=>{if(error){if(error.code=="ENOENT"){if(served?.errpage){fs.readFile(served.errpage,(er,content2)=>{response.writeHead(404,{"Content-Type":"text/html"});if(served.pages?._all||served.pages?.error){let{templateString,headers}=this.injectPageCode(content2.toString(),message.route,served);content2=templateString}response.end(content2,"utf-8");reject(content2)})}else{response.writeHead(404,{"Content-Type":"text/html"});let content2=`<!DOCTYPE html><html><head></head><body style='background-color:#101010 color:white;'><h1>Error: ${error.code}</h1></body></html>`;if(served?.pages?._all||served?.pages?.[message.route]){let{templateString,headers}=this.injectPageCode(content2.toString(),message.route,served);content2=templateString}response.end(content2,"utf-8");reject(error.code)}}else{response.writeHead(500);response.end("Something went wrong: "+error.code+" ..\n","utf-8");reject(error.code)}}else{var extname2=String(path.extname(requestURL)).toLowerCase();var contentType=this.mimeTypes[extname2]||"application/octet-stream";let head={"Content-Type":contentType};if(contentType==="text/html"&&(served?.pages?._all||served?.pages?.[message.route])){let{templateString,headers}=this.injectPageCode(content.toString(),message.route,served);Object.assign(head,headers);content=templateString}response.writeHead(200,head);response.end(content,"utf-8");resolve(content)}};responsePromiseHandler=(resolve,reject,message,request,response,method,served)=>{response.on("error",err=>{if(served.debug){let time=getHoursAndMinutes(new Date);console.error(time,"| Response Error: ",err," From: ",request.socket?.remoteAddress," For: ",request.url," | ",request.method)}this.responseOnErrorPromiseHandler(response,reject,err);request.destroy();request.socket?.destroy()});if(method==="GET"||method==="get"){var requestURL="."+request.url;if(request.url&&this.restrict?.[request.url])reject(request.url);if(requestURL=="./"&&served?.startpage){requestURL=served.startpage}if(requestURL.includes("?"))requestURL=requestURL.substring(0,requestURL.indexOf("?"));if((request.url!=="/"||served?.startpage)&&fs.existsSync(path.join(process.cwd(),requestURL))){if(response.writableEnded||response.destroyed)reject(requestURL);else{fs.readFile(path.join(process.cwd(),requestURL),(error,content)=>{this.onRequestFileReadPromiseHandler(error,content,resolve,reject,requestURL,response,message,served)})}}else if(message.route){let route;if(served){let rt=`${served.port}/${message.route}`;if(this.__node.nodes.get(rt))route=rt}if(!route&&this.__node.nodes.get(message.route))route=message.route;if(route){let res;if(message.method){res=this.handleMethod(route,message.method,void 0)}else if(message.node){res=this.handleGraphNodeCall(message.node,void 0)}else res=this.handleServiceMessage({route,args:void 0,method:message.method});if(res instanceof Promise)res.then(r=>{if(served?.keepState)this.setState({[served.address]:res});this.withResult(response,r,message);resolve(res)});else if(res){if(served?.keepState)this.setState({[served.address]:res});this.withResult(response,res,message);resolve(res)}}else if(message.redirect){response.writeHead(301,{"Location":message.redirect});response.end();resolve(true)}else this.getFailedPromiseHandler(resolve,reject,requestURL,message,response,served)}else this.getFailedPromiseHandler(resolve,reject,requestURL,message,response,served)}else{let requestBody;let timedOut=true;let timeout;request.on("data",chunk=>{if(!requestBody)requestBody=[];requestBody.push(chunk);if(timedOut){timedOut=false;if(timeout)clearTimeout(timeout)}}).on("end",()=>{this.handleBufferedPostBodyPromiseHandler(resolve,requestBody,message,response,served)});timeout=setTimeout(()=>{if(timedOut){let errMessage=new Error(`Request timed out from | ${request.socket?.remoteAddress} | For: ${request.url} | ${request.method}`);request.destroy(errMessage);served.server.emit("clientError",errMessage,request.socket);if(served.debug){console.error(errMessage)}reject(errMessage)}},served.timeout?served.timeout:1e3)}};request=(options,send,ondata,onend)=>{let client=http;if(options.protocol?.includes("https")){client=https}delete options.protocol;const req=client.request(options,res=>{if(ondata)res.on("data",ondata);if(onend)res.on("end",onend)});if(options.headers){for(const head in options.headers){req.setHeader(head,options.headers[head])}}if(send)req.write(send);req.end();return req};POST=(url,data,headers)=>{let urlstring=url;if(urlstring instanceof URL)urlstring=url.toString();let protocol=urlstring.startsWith("https")?"https":"http";let host,port,path3;let split=urlstring.split("/");split.forEach(s=>{if(s.includes(":")){let ss=s.split(":");host=ss[0];port=ss[1]}});if(split.length>3){path3=split.slice(3).join("/")}let req=this.request({protocol,host,port,path:path3,method:"POST",headers},data);return req};GET=url=>{return new Promise((resolve,reject)=>{let client=http;let urlstring=url;if(url instanceof URL)urlstring=url.toString();if(urlstring.includes("https")){client=https}client.get(url,resp=>{let chunks=[];resp.on("data",chunk=>{chunks.push(chunk)});resp.on("end",()=>{resolve(Buffer.concat(chunks))})}).on("error",err=>{reject(err)})})};terminate=served=>{if(typeof served==="string")served=this.servers[served];if(typeof served==="object"){served.server.close();if(served.onclose)served.onclose(served)}};getRequestBody(req){let chunks=[];return new Promise((resolve,reject)=>{req.on("data",chunk=>{chunks.push(chunk)}).on("end",()=>{resolve(Buffer.concat(chunks))}).on("error",er=>{let errMessage=new Error(`Request timed out from | ${req.socket?.remoteAddress} | For: ${req.url} | ${req.method}`);req.destroy(errMessage);reject(errMessage)})})}addPage=(path3,template)=>{if(typeof template==="string"){if(!template.includes("<html"))template="<!DOCTYPE html><html>"+template+"</html>"}if(typeof this.__node.roots?.[path3]==="object"){this.__node.roots[path3].get=template;this.__node.nodes.get(path3).get=template}else this.load({[path3]:{get:template}})};addHTML=(path3,template)=>{if(typeof template==="string"){if(!template.includes("<")||!template.includes(">"))template="<div>"+template+"</div>"}if(typeof this.__node.roots?.[path3]==="object"){this.__node.roots[path3].get=template;this.__node.nodes.get(path3).get=template}else this.load({[path3]:{get:template}})};buildPage=(pageStructure,baseTemplate)=>{let result=``;if(baseTemplate)result+=baseTemplate;let appendTemplate=(obj,r,res)=>{if(!Array.isArray(obj[r])&&typeof obj[r]==="object"){for(const key in obj){appendTemplate(obj,key,res)}}else if(this.__node.nodes.get(r)?.get){let toAdd=this.__node.nodes.get(r)?.get;if(typeof toAdd==="function"){if(Array.isArray(obj[r])){toAdd=toAdd(...obj[r])}else toAdd=toAdd(obj[r])}if(typeof toAdd==="string"){let lastDiv=res.lastIndexOf("<");if(lastDiv>0){let end=res.substring(lastDiv);res=res.substring(0,lastDiv)+toAdd+end}else res+=toAdd}}else if(this.__node.nodes.get(r)?.__operator){let routeresult;if(this.__node.nodes.get(r)?.__operator)routeresult=this.__node.nodes.get(r).__operator(obj[r]);if(typeof routeresult==="string"){let lastDiv=res.lastIndexOf("<");if(lastDiv>0){let end=res.substring(lastDiv);res=res.substring(0,lastDiv)+routeresult+end}else res+=routeresult}}else if(typeof this.__node.nodes.get(r)==="string")res+=this.__node.nodes.get(r);return res};if(Array.isArray(pageStructure)){pageStructure.forEach(r=>{result=appendTemplate(pageStructure,r,result)})}else if(typeof pageStructure==="object"){for(const r in pageStructure){result=appendTemplate(pageStructure,r,result)}}else if(typeof pageStructure==="string")result+=pageStructure;else if(typeof pageStructure==="function")result+=pageStructure();return result};hotreload=(socketURL=`http://localhost:8080/wss`,esbuild_cssFileName)=>{if(socketURL instanceof URL)socketURL=socketURL.toString();const HotReloadClient=(socketUrl,esbuild_cssFileName2)=>{let socket=new WebSocket(socketUrl);function reloadLink(file){let split=file.includes("/")?file.split("/"):file.split("\\");let fname=split[split.length-1];var links=document.getElementsByTagName("link");for(var cl in links){var link=links[cl];if(!file||link.href?.includes(fname)){let href=link.getAttribute("href").split("?")[0];let newHref=href+="";link.setAttribute("href",newHref)}}}function reloadAsset(file,reloadscripts,isJs){let split=file.includes("/")?file.split("/"):file.split("\\");let fname=split[split.length-1];let elements=document.querySelectorAll("[src]");let found=false;for(const s of elements){if(s.src.includes(fname)){if(s.tagName==="SCRIPT"&&!reloadscripts){window.location.reload();return}else{let placeholder=document.createElement("object");s.insertAdjacentElement("afterend",placeholder);s.remove();let elm=s.cloneNode(true);placeholder.insertAdjacentElement("beforebegin",elm);placeholder.remove();found=true}}}if(!found)window.location.reload()}socket.addEventListener("message",ev=>{let message=ev.data;if(typeof message==="string"&&message.startsWith("{")){message=JSON.parse(message)}if(message.file){let f=message.file;let rs=message.reloadscripts;if(f.endsWith("html")||f.endsWith("xml")||f.endsWith("wasm")){window.location.reload()}else if(f.endsWith("css")){if(!esbuild_cssFileName2.endsWith("css"))esbuild_cssFileName2+=".css";reloadLink(esbuild_cssFileName2)}else if(f.endsWith("js")||f.endsWith("ts")||f.endsWith("jsx")||f.endsWith("tsx")||f.endsWith("vue")){reloadAsset(f,rs)}else{reloadLink(f);reloadAsset(f)}}});socket.addEventListener("close",()=>{const interAttemptTimeoutMilliseconds=100;const maxDisconnectedTimeMilliseconds=3e3;const maxAttempts=Math.round(maxDisconnectedTimeMilliseconds/interAttemptTimeoutMilliseconds);let attempts=0;const reloadIfCanConnect=()=>{attempts++;if(attempts>maxAttempts){console.error("Could not reconnect to dev server.");return}socket=new WebSocket(socketUrl);socket.onerror=er=>{console.error(`Hot reload port disconnected, will reload on reconnected. Attempt ${attempts} of ${maxAttempts}`)};socket.addEventListener("error",()=>{setTimeout(reloadIfCanConnect,interAttemptTimeoutMilliseconds)});socket.addEventListener("open",()=>{location.reload()})};reloadIfCanConnect()})};return`
            <script>
                console.log('Hot Reload port available at ${socketURL}');  
                (`+HotReloadClient.toString()+`)('${socketURL}',${esbuild_cssFileName?`'${esbuild_cssFileName}'`:void 0}); 
            </script>
        `};pwa=(pwaName="PWA",cacheExpirationDays=4/24,serviceWorkerUrl="service-worker.js")=>{if(!fs.existsSync(serviceWorkerUrl)){fs.writeFileSync(path.join(process.cwd(),serviceWorkerUrl),defaultServiceWorker(cacheExpirationDays))}if(!fs.existsSync("manifest.webmanifest")){fs.writeFileSync(path.join(process.cwd(),"/manifest.webmanifest"),defaultManifest(pwaName))}function ServiceWorkerInstaller(serviceWorkerUrl2){if(!Array.from(document.head.querySelectorAll("link")).find(elm=>{if(elm.href.includes("manifest"))return true})){document.head.insertAdjacentHTML("beforeend",`<link rel="manifest" href="./manifest.webmanifest">`)}const isLocalhost=Boolean(window.location.hostname==="localhost"||window.location.hostname==="[::1]"||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));function registerSW(){navigator.serviceWorker.register(serviceWorkerUrl2).then(registration=>{registration.onupdatefound=()=>{const installingWorker=registration.installing;if(installingWorker==null){return}installingWorker.onstatechange=()=>{if(installingWorker.state==="installed"){if(navigator.serviceWorker.controller){console.log("New content is available and will be used when all tabs for this page are closed.")}else{console.log("Content is cached for offline use.")}}}}}).catch(error=>{console.error("Error during service worker registration:",error)})}if("serviceWorker"in navigator)addEventListener("load",()=>{if(isLocalhost){fetch(serviceWorkerUrl2).then(response=>{const contentType=response.headers.get("content-type");if(response.status===404||contentType!=null&&contentType.indexOf("javascript")===-1){navigator.serviceWorker.ready.then(registration=>{registration.unregister().then(()=>{window.location.reload()})})}else{registerSW()}}).catch(()=>{console.log("No internet connection found. App is running in offline mode.")});navigator.serviceWorker.ready.then(()=>{console.log("This web app is being served cache-first by a service worker.")})}else{registerSW()}})}return`
            <script>
                (`+ServiceWorkerInstaller.toString()+`)('${serviceWorkerUrl}'); 
            </script>
        `}};function getPageOptions(url,received,pages,request,response,port){let pageOptions=pages[url];let key=url;if(!pageOptions){let url2="/"+url;pageOptions=pages[url2];key=url2;if(!pageOptions&&!path.extname(url)){let split=url.split("/");key=split[0]+"/*";if(pages[key]){pageOptions=pages[key];received.route=key;request.url=key}else{let spl=url2.split("/");spl[spl.length-1]="";key=spl.join("/")+"*";if(pages[key]){pageOptions=pages[key];received.route=key;request.url=key}}}else{received.route=url2;request.url=url2}}else{received.route=url;request.url=url}if(typeof pageOptions==="object"){if(pageOptions.redirect){url=pageOptions.redirect;received.redirect=url;received.route=url}if(pageOptions.onrequest){if(typeof pageOptions.onrequest==="string"){pageOptions.onrequest=this.__node.nodes.get(pageOptions.onrequest)}if(typeof pageOptions.onrequest==="object"){if(pageOptions.onrequest.__operator){pageOptions.onrequest.__operator(pageOptions,request,response)}}else if(typeof pageOptions.onrequest==="function"){pageOptions.onrequest(this,this.__node.nodes.get(`${port}/${key}`),request,response)}}}return pageOptions}function getHoursAndMinutes(date){let hours=date.getHours();let minutes=date.getMinutes();hours=hours<10?"0"+hours:hours;minutes=minutes<10?"0"+minutes:minutes;return`${hours}:${minutes}`}var import_better_sse=__toESM(require_build());var SSEbackend=class extends Service{name="sse";debug=false;servers={};eventsources={};connections={servers:this.servers,eventsources:this.eventsources};constructor(options){super(options);this.load(this)}openSSE=options=>{const server=options.server;let path3=options.path;if(this.servers[path3]){return false}const channel=(0,import_better_sse.createChannel)();let sse={type:"sse",channel,sessions:{},requests:{},...options};this.servers[path3]=sse;sse._id=options._id?options._id:path3;const send=(message,eventName,sessionId)=>{return this.transmit(message,path3,eventName,sessionId)};const terminate=()=>{return this.terminate(path3)};let request=(message,method,sessionId,eventName)=>{if(!sessionId){let promises=[];for(const key in sse.sessions){promises.push(this.request(message,path3,key,eventName))}return promises}return this.request(message,path3,method,sessionId,eventName)};let post=(route,args,method,sessionId,eventName)=>{let message={route,args};if(method)message.method=method;return this.transmit(message,path3,eventName,sessionId)};let run=(route,args,method,sessionId,eventName)=>{let r={route,args};if(!sessionId){let promises=[];for(const key in sse.sessions){promises.push(this.request(r,path3,key,eventName))}return promises}return this.request(r,path3,method,sessionId,eventName)};let subscribe=(route,callback,args,key,subInput,sessionId,eventName)=>{return this.subscribeToSSE(route,options.url,callback,args,key,subInput,sessionId,eventName)};let unsubscribe=(route,sub,sessionId,eventName)=>{return run("unsubscribe",[route,sub],void 0,sessionId,eventName)};sse.send=send;sse.request=request;sse.post=post;sse.run=run;sse.subscribe=subscribe;sse.unsubscribe=unsubscribe;sse.terminate=terminate;sse.graph=this;let onRequest=(req,response)=>{if(req.url?.includes(path3)){if(req.method==="GET"){if(this.debug)console.log("SSE Request",path3);(0,import_better_sse.createSession)(req,response).then(session=>{channel.register(session);let _id=`sse${Math.floor(Math.random()*1e15)}`;sse.sessions[_id]=session;this.eventsources[_id]={_id,session,served:sse,send:(message,eventName)=>{return send(message,eventName,_id)},request:(message,method,eventName)=>{return request(message,method,_id,eventName)},post:(route,args,method,eventName)=>{return post(route,args,method,_id,eventName)},run:(route,args,method,eventName)=>{return run(route,args,method,_id,eventName)},subscribe:(route,callback)=>{return subscribe(route,callback,void 0,_id)},unsubscribe:(route,sub,eventName)=>{return unsubscribe(route,sub,_id,eventName)},terminate:()=>{delete this.eventsources[_id];delete sse.sessions[_id];return true},onclose:(session2,sse2,_id2,req2,res)=>{if(sse2.onconnectionclose)sse2.onconnectionclose(session2,sse2,_id2,req2,res)},graph:this};session.push(JSON.stringify({route:"setId",args:_id}));session.on("close",()=>{let obj=this.eventsources[_id];let onclose=obj.onclose;delete this.eventsources[_id];if(onclose)obj.onclose(session,sse,_id,req,response)});if(sse.onconnection){sse.onconnection(session,sse,_id,req,response)}})}else{let body=[];req.on("data",chunk=>{body.push(chunk)}).on("end",()=>{body=Buffer.concat(body).toString();if(typeof body==="string"){let substr=body.substring(0,8);if(substr.includes("{")||substr.includes("[")){if(substr.includes("\\"))body=body.replace(/\\/g,"");if(body[0]==='"'){body=body.substring(1,body.length-1)};body=JSON.parse(body)}}let route,method,args,callbackId;if(body?.route||body?.callbackId){method=body.method;args=body.args;callbackId=body.callbackId;if(typeof body.route==="string"){if(body.route.includes("/")&&body.route.length>1)body.route=body.route.split("/").pop();route=this.__node.roots?.[body.route]}}if(route){let res=this.receive({route,args,method})}else if(callbackId&&sse.requests[callbackId]){sse.requests[callbackId](args)}if(this.__node.keepState)this.setState({[path3]:body})})}}};let requestListeners=server.listeners("request");server.removeAllListeners("request");const otherListeners=(req,res)=>{requestListeners.forEach(l=>{l(req,res)})};const sseListener=(req,res)=>{if(req.url)if(req.url.indexOf(path3)>-1){if(!this.servers[path3]){server.removeListener("request",sseListener);server.addListener("request",otherListeners)}onRequest(req,res)}else otherListeners(req,res)};server.addListener("request",sseListener);server.addListener("close",()=>{if(sse.onclose)sse.onclose(sse)});return sse};open=this.openSSE;streamIterable=(path3,iterable,sessionId,eventName="message")=>{let server=this.servers[path3];if(server){if(sessionId){if(server.sessions[sessionId]){return server.sessions[sessionId].iterate(iterable,{eventName})}}else{let promises=[];for(const key in server.sessions){promises.push(server.sessions[key].iterate(iterable))}return promises}}};streamReadable=(path3,readable,sessionId,eventName="message")=>{let server=this.servers[path3];if(server){if(sessionId){if(server.sessions[sessionId]){return server.sessions[sessionId].stream(readable,{eventName})}}else{let promises=[];for(const key in server.sessions){promises.push(server.sessions[key].stream(readable))}return promises}}};transmit=(data,path3,eventName,sessionId)=>{if(!path3&&(typeof data==="object"&&!data.byteLength||typeof data==="number")){if(data?.route){let keys=Object.keys(this.servers);if(keys.length>0){let evs=this.servers[keys[0]];if(evs.channels?.includes(data.route)){path3=evs.path;eventName=data.route}}if(!path3&&data.route){if(this.servers[data.route])path3=data.route}}data=JSON.stringify(data)}if(!path3)path3=Object.keys(this.servers)[0];if(path3&&this.servers[path3]){if(sessionId){if(this.servers[path3].sessions[sessionId]?.isConnected){this.servers[path3].sessions[sessionId].push(data,eventName)}else if(this.servers[path3].sessions[sessionId]){delete this.servers[path3].sessions[sessionId];return false}}else this.servers[path3].channel.broadcast(data,eventName);return true}return false};request=(message,path3,method,sessionId,eventName)=>{return new Promise((res,rej)=>{let callbackId=`${Math.random()}`;let req={route:"runRequest",args:[message,path3,callbackId,sessionId]};if(method)req.method=method;let sse=this.servers[path3];let callback=result=>{res(result)};sse.requests[callbackId]=callback;if(sse){if(sessionId){if(sse.sessions[sessionId])sse.sessions[sessionId].push(JSON.stringify(req),eventName)}else sse.channel.broadcast(JSON.stringify(req),eventName)}})};runRequest=(message,path3,callbackId,sessionId)=>{let res=this.receive(message);if(path3){let sse=this.servers[path3];if(sse){if(res instanceof Promise){res.then(r=>{if(sessionId){if(sse.sessions[sessionId]){sse.sessions[sessionId].push(JSON.stringify({args:r,callbackId}))}}else{sse.channel.broadcast(JSON.stringify({args:r,callbackId}))}})}else{if(sessionId){if(sse.sessions[sessionId]){sse.sessions[sessionId].push(JSON.stringify({args:res,callbackId}))}}else sse.channel.broadcast(JSON.stringify({args:res,callbackId}))}}}return res};subscribeSSE=(route,path3,args,key,subInput,sessionId,eventName)=>{if(this.restrict?.[route])return void 0;if(this.servers[path3]){return this.subscribe(route,res=>{this.servers[path3].send({args:res,callbackId:route},eventName,sessionId)},args,key,subInput)}};subscribeToSSE=(route,path3,callback,args,key,subInput,sessionId,eventName)=>{if(this.servers[path3]){this.__node.state.subscribeEvent(path3,res=>{if(res?.callbackId===route){if(!callback)this.setState({[path3]:res.args});else if(typeof callback==="string"){this.run(callback,res.args)}else callback(res.args)}});if(sessionId){if(this.servers[path3].sessions[sessionId]){return this.eventsources[sessionId].run("subscribeSSE",{route:"subscribeSSE",args:[route,path3,args,key,subInput]},void 0,eventName)}}else{let promises=[];for(const k in this.servers[path3].sessions){promises.push(this.eventsources[k].run("subscribeSSE",{route:"subscribeSSE",args:[route,path3,args,key,subInput]},void 0,eventName))}return promises}}};terminate=sse=>{if(typeof sse==="object")delete this.servers[sse.path];else if(typeof sse==="string"){delete this.servers[sse];delete this.eventsources[sse]}return true}};var import_stream=__toESM(require_stream(),1);var import_receiver=__toESM(require_receiver(),1);var import_sender=__toESM(require_sender(),1);var import_websocket=__toESM(require_websocket(),1);var import_websocket_server=__toESM(require_websocket_server(),1);var wrapper_default=import_websocket.default;var WSSbackend=class extends Service{name="wss";debug=false;servers={};sockets={};connections={servers:this.servers,sockets:this.sockets};constructor(options){super(options);this.load(this)}open=options=>{if(options?.server){return this.setupWSS(options)}else return this.openWS(options)};setupWSS=options=>{let port=options.port;let path3=options.path;const server=typeof options.server==="object"?options.server:void 0;let host=options.host;delete options.server;if(!("keepState"in options))options.keepState=true;let opts={};if(options.noServer)opts.noServer=true;else if(port){if(port)opts.port=port}else if(server)opts.server=server;if(options.perMessageDeflate)opts.perMessageDeflate=options.perMessageDeflate;if(typeof options.serverOptions)Object.assign(opts,options.serverOptions);const wss=new import_websocket_server.default(opts);let address="";if(!host&&server){let addr=server.address();if(!port)port=addr.port;address=addr.address}else if(host)address=host;if(port)address+=":"+port;if(path3){if(!path3.startsWith("/"))path3="/"+path3;address+=path3}this.servers[address]={type:"wss",wss,clients:{},address,...options};wss.addListener("connection",(ws,request2)=>{if(this.debug)console.log(`New socket connection on ${address}`);let clientId=`socket${Math.floor(Math.random()*1e12)}`;this.servers[address].clients[clientId]=ws;ws.send(JSON.stringify({route:"setId",args:clientId}));this.openWS({socket:ws,address:clientId,_id:clientId,debug:options.debug,onclose:(code,reason)=>{if(this.servers[address].onconnectionclosed)this.servers[address].onconnectionclosed(code,reason,ws,this.servers[address],clientId);delete this.servers[address].clients[clientId]},onmessage:options.onmessage});if(options.debug){let time=getHoursAndMinutes2(new Date);console.log(time," | ",clientId," | Number of live sockets: ",Object.keys(this.servers[address].clients).length)}if(this.servers[address].onconnection)this.servers[address].onconnection(ws,request2,this.servers[address],clientId)});wss.on("error",err=>{if(this.debug)console.log("Socket Error:",err);if(this.servers[address]?.onerror)this.servers[address].onerror(err,wss,this.servers[address]);else console.error(err)});let onUpgrade=(request2,socket,head)=>{if(request2.headers&&request2.url){if(this.debug)console.log("Upgrade request at: ",request2.url);let pass=false;if(path3&&request2.url===path3)pass=true;else{let addr=request2.headers.host.split(":")[0];if(port)addr+=":"+port;if(addr===address)pass=true;else{addr+=request2.url.split("?")[0];if(addr===address)pass=true}}if(pass&&this.servers[address]){this.servers[address].wss.handleUpgrade(request2,socket,head,ws=>{if(this.servers[address].onupgrade)this.servers[address].onupgrade(ws,this.servers[address],request2,socket,head);this.servers[address].wss.emit("connection",ws,request2)})}}};if(server)server.addListener("upgrade",onUpgrade);wss.addListener("close",()=>{if(server)server.removeListener("upgrade",onUpgrade);if(this.servers[address]?.onclose)this.servers[address].onclose(wss,this.servers[address]);else console.log(`wss closed: ${address}`);delete this.servers[address]});let send=(message,socketId)=>{if(typeof message==="object")message=JSON.stringify(message);if(!socketId){for(const key in this.servers[address].clients){this.sockets[key].send(message)}}else return this.sockets[socketId].send(message)};let request=(message,method,socketId)=>{if(!socketId){let promises=[];for(const key in this.servers[address].clients){promises.push(this.sockets[key].request(message,method))}return promises}else return this.sockets[socketId].request(message,method)};let post=(route,args,method,socketId)=>{if(!socketId){for(const key in this.servers[address].clients){this.sockets[key].post(route,args,method)}}else return this.sockets[socketId].post(route,args,method)};let run=(route,args,method,socketId)=>{if(!socketId){let promises=[];for(const key in this.servers[address].clients){promises.push(this.sockets[key].run(route,args,method))}return promises}else return this.sockets[socketId].run(route,args,method)};let subscribe=(route,callback,socketId,args,key,subInput)=>{if(!socketId){let promises=[];for(const k in this.servers[address].clients){promises.push(this.sockets[k].subscribe(route,callback,args,key,subInput))}return promises}else this.sockets[socketId].subscribe(route,callback,args,key,subInput)};let unsubscribe=(route,sub,socketId)=>{if(!socketId){let promises=[];for(const key in this.servers[address].clients){promises.push(this.sockets[key].unsubscribe(route,sub))}return promises}else this.sockets[socketId].unsubscribe(route,sub)};let terminate=socketId=>{if(socketId)return this.terminate(socketId);else return this.terminate(address)};this.servers[address].send=send;this.servers[address].request=request;this.servers[address].post=post;this.servers[address].run=run;this.servers[address].subscribe=subscribe;this.servers[address].unsubscribe=unsubscribe;this.servers[address].terminate=terminate;this.servers[address].graph=this;this.servers[address]._id=options._id?options._id:address;return this.servers[address]};openWS=options=>{if(!options.address){let protocol=options.protocol;if(!protocol)protocol="wss";options.address=`${protocol}://${options.host}`;if(options.port)options.address+=":"+options.port;if(!options.path||options.path?.startsWith("/"))options.address+="/";if(options.path)options.address+=options.path}const address=options.address;let socket;if(options.socket)socket=options.socket;else socket=new wrapper_default(address);if(!("keepState"in options))options.keepState=true;if(options.onmessage){socket.on("message",data=>{this.sockets[address].onmessage(data,socket,this.sockets[address])})}else if(options._id){socket.addListener("message",data=>{if(ArrayBuffer.isView(data))data=data.toString();if(options.debug){console.log("Message from ",options._id,": ",data)}this.receive(data,socket,this.sockets[address]);if(options.keepState){this.setState({[address]:data})}})}else{let socketonmessage=data=>{if(ArrayBuffer.isView(data))data=data.toString();if(data){if(options.debug){console.log("Message from ",address,": ",data)}if(typeof data==="string"){let substr=data.substring(0,8);if(substr.includes("{")||substr.includes("[")){if(substr.includes("\\"))data=data.replace(/\\/g,"");if(data[0]==='"'){data=data.substring(1,data.length-1)};data=JSON.parse(data);if(data.route==="setId"){this.sockets[address]._id=data.args;socket.removeEventListener("message",socketonmessage);socket.on("message",data2=>{if(ArrayBuffer.isView(data2))data2=data2.toString();if(options.debug){console.log("Message from ",this.sockets[address]._id,": ",data2)}this.receive(data2,socket,this.sockets[address]);if(options.keepState){this.setState({[address]:data2})}})}else{this.receive(data,socket,this.sockets[address]);this.setState({[address]:data})}}}}this.receive(data,socket,this.sockets[address]);if(options.keepState)this.setState({[address]:data})};socket.addListener("message",socketonmessage);options.onmessage=socketonmessage}socket.addListener("open",()=>{if(this.sockets[address].onopen)this.sockets[address].onopen(socket,this.sockets[address])});socket.addListener("close",(code,reason)=>{let obj=this.sockets[address];let onclose=obj.onclose;delete this.sockets[address];if(onclose)onclose(code,reason,socket,obj)});socket.on("error",er=>{if(this.sockets[address]?.onerror)this.sockets[address].onerror(er,socket,this.sockets[address])});let send=message=>{return this.transmit(message,socket)};let post=(route,args,method)=>{let message={route,args};if(method)message.method=method;return this.transmit(message,socket)};let run=(route,args,method)=>{return new Promise((res,rej)=>{let callbackId=Math.random();let req={route:"runRequest",args:[{route,args},this.sockets[address]._id,callbackId]};if(method)req.args[0].method=method;let onmessage=ev=>{let data=ev.data;if(typeof data==="string"&&data.indexOf("{")>-1)data=JSON.parse(data);if(typeof data==="object"){if(data.callbackId===callbackId){socket.removeEventListener("message",onmessage);res(data.args)}}};socket.addEventListener("message",onmessage);this.transmit(req,socket)})};let request=(message,method)=>{return this.request(message,socket,this.sockets[address]._id,method)};let subscribe=(route,callback)=>{return this.subscribeToSocket(route,this.sockets[address]._id,callback)};let unsubscribe=(route,sub)=>{return run("unsubscribe",[route,sub])};let terminate=()=>{this.terminate(this.sockets[address]._id)};this.sockets[address]={type:"socket",socket,send,post,request,run,subscribe,unsubscribe,terminate,graph:this,__node:{tag:address},...options};return this.sockets[address]};transmit=(message,ws)=>{if(typeof message==="object"&&(message?.route||message?.node||typeof message.arrayBuffer!=="function"&&typeof message.byteLength!=="number"&&typeof message[0]?.byteLength!=="number")||typeof message==="number")message=JSON.stringify(message);if(!ws){let served=this.servers[Object.keys(this.servers)[0]];if(served)ws=served.wss;else{let s=this.sockets[Object.keys(this.sockets)[0]];if(s)ws=s.socket};}if(ws instanceof import_websocket_server.default){ws.clients.forEach(c=>{c.send(message)})}else if(ws instanceof wrapper_default)ws.send(message)};closeWS=ws=>{if(!ws){let s=this.sockets[Object.keys(this.sockets)[0]];if(s)ws=s.socket}else if(typeof ws==="string"){for(const k in this.sockets){if(k.includes(ws)){ws=this.sockets[k].socket;delete this.sockets[k];break}}}if(ws instanceof wrapper_default){if(ws.readyState===ws.OPEN)ws.close()}return true};terminate=ws=>{let str;if(!ws){let served=Object.keys(this.servers);for(const key in served){this.terminate(key)}let sockets=Object.keys(this.sockets);for(const key in sockets){this.terminate(key)}}else if(typeof ws==="string"){str=ws;for(const k in this.servers){if(k.includes(ws)||this.servers[k]._id===ws){ws=this.servers[k].wss;for(const key in this.servers[k].clients){this.closeWS(this.servers[k].clients[key])}delete this.servers[k];break}}if(!ws){for(const k in this.sockets){if(k.includes(ws)||this.sockets[k]._id===ws){ws=this.sockets[k].socket;delete this.sockets[k];break}}}}if(ws instanceof import_websocket_server.default){ws.close(er=>{if(er)console.error(er)})}else if(ws instanceof wrapper_default){if(ws.readyState===ws.OPEN)ws.close();if(this.get(str?str:ws.url))this.remove(str?str:ws.url)}return true};request=(message,ws,_id,method)=>{let callbackId=`${Math.random()}`;let req={route:"runRequest",args:[message,_id,callbackId]};if(method)req.method=method;return new Promise((res,rej)=>{let onmessage=ev=>{let data=ev.data;if(typeof data==="string"){if(data.includes("callbackId"))data=JSON.parse(data)}if(typeof data==="object"){if(data.callbackId===callbackId){ws.removeEventListener("message",onmessage);res(data.args)}}};ws.addEventListener("message",onmessage);ws.send(JSON.stringify(req))})};runRequest=(message,ws,callbackId)=>{let res=this.receive(message);if(ws){if(typeof ws==="string"){for(const key in this.servers){for(const c in this.servers[key].clients){if(c===ws){ws=this.servers[key].clients[c];break}}}if(!(ws instanceof wrapper_default)){for(const s in this.sockets){if(s===ws){ws=this.sockets[s].socket;break}}}}if(res instanceof Promise){res.then(v=>{res={args:v,callbackId};if(ws instanceof wrapper_default)ws.send(JSON.stringify(res))})}else{res={args:res,callbackId};if(ws instanceof wrapper_default)ws.send(JSON.stringify(res))}}return res};subscribeSocket=(route,socket,args,key,subInput)=>{if(this.restrict?.[route])return void 0;if(typeof socket==="string"){if(this.sockets[socket])socket=this.sockets[socket].socket;else{for(const prop in this.servers){if(this.servers[prop].clients[socket])socket=this.servers[prop].clients[socket]}}}if(typeof socket==="object"){return this.subscribe(route,res=>{if(socket.readyState===socket.OPEN){if(res instanceof Promise){res.then(r=>{socket.send(JSON.stringify({args:r,callbackId:route}))})}else{socket.send(JSON.stringify({args:res,callbackId:route}))}}},args,key,subInput)}};subscribeToSocket=(route,socketId,callback,args,key,subInput)=>{if(typeof socketId==="string"&&this.sockets[socketId]){this.__node.state.subscribeEvent(socketId,res=>{if(res?.callbackId===route){if(!callback)this.setState({[socketId]:res.args});else if(typeof callback==="string"){this.setState({[callback]:res.args})}else callback(res.args)}});return this.sockets[socketId].request({route:"subscribeSocket",args:[route,socketId,args,key,subInput]})}}};function getHoursAndMinutes2(date){let hours=date.getHours();let minutes=date.getMinutes();hours=hours<10?"0"+hours:hours;minutes=minutes<10?"0"+minutes:minutes;return`${hours}:${minutes}`}var import_child_process=require("child_process");var import_path=__toESM(require("path"));var CMDService=class extends Service{processes;connections={processes:void 0};subprocessloader={"process":(node,parent,graph,roots,properties)=>{if(node.command){this.createProcess(node)}}};constructor(options){super(options);this.load(this);this.connections.processes=this.processes;if(process?.stdin){process.stdin.on("data",data=>{let str=data.toString();this.receive(str)})}}createProcess=properties=>{let newprocess=properties;if(!newprocess.command)newprocess.command="node";if(!newprocess.args)newprocess.args=[import_path.default.join(process.cwd(),"node_modules","graphscript-node","services","cmd","childprocess.js")];if(newprocess.command){let p;if(!newprocess.options){newprocess.options={shell:true,stdio:"inherit"}}newprocess.controller=new AbortController;newprocess.options=Object.assign({signal:newprocess.controller.signal,env:process.env,cwd:process.cwd()},newprocess.options);if(newprocess.tag)newprocess._id=newprocess.tag;else{newprocess._id=`process${Math.floor(Math.random()*1e15)}`;newprocess.tag=newprocess._id}if(typeof newprocess.command==="string"){if(newprocess.command.includes(".js")){p=(0,import_child_process.fork)(newprocess.command,newprocess.args,newprocess.options)}else p=(0,import_child_process.spawn)(newprocess.command,newprocess.args?newprocess.args:[],newprocess.options);if(p instanceof import_child_process.ChildProcess){if(p.stderr){if(newprocess.onerror){p.stderr.on("data",newprocess.onerror)}else p.stderr.on("data",console.error)}if(p.stdout){if(newprocess.stdout){p.stdout.on("data",newprocess.stdout)}else p.stdout.on("data",data=>{let str=data.toString();this.receive(str);this.setState({[newprocess._id]:str})})}if(newprocess.onclose){p.on("close",newprocess.onclose)}newprocess.process=p;newprocess.controller=new AbortController;newprocess.send=data=>{return p.send(data)};newprocess.request=(message,method)=>{return this.request(message,newprocess._id,method)};newprocess.post=(route,args,method)=>{let message={route,args};if(method)message.method=method;return p.send(JSON.stringify(message))};newprocess.run=(route,args,method)=>{let message={route,args};if(method)message.method=method;return this.request(message,newprocess._id)};newprocess.subscribe=(route,callback,args,key,subInput)=>{return this.subscribeToProcess(route,newprocess._id,callback,args,key,subInput)};newprocess.unsubscribe=(route,sub)=>{return newprocess.run("unsubscribe",[route,sub])};this.processes[newprocess._id]=newprocess}}}return newprocess};open=this.createProcess;abort=childprocess=>{if(childprocess.controller)childprocess.controller.abort();else childprocess.kill();return true};send=(childprocess,data)=>{return childprocess.send(data)};request=(message,processId,method)=>{let childprocess=this.processes[processId].process;return new Promise((res,rej)=>{let callbackId=Math.random();let req={route:"runRequest",args:[message,callbackId]};if(method)req.method=method;let ondata=data=>{let str=data.toString();if(str.includes("{")){let parsed=JSON.parse(str);if(parsed.callbackId===callbackId){childprocess.removeListener("data",ondata);res(parsed.args)}}};childprocess.addListener("data",ondata);childprocess.send(req)})};runRequest=(message,callbackId,childprocess)=>{let res=this.receive(message);if(typeof childprocess==="string")childprocess=this.processes[childprocess].process;if(res instanceof Promise){res.then(v=>{res={args:v,callbackId};if(childprocess instanceof import_child_process.ChildProcess)childprocess.send(JSON.stringify(res));else process.stdout.write(JSON.stringify(res))})}else{res={args:res,callbackId};if(childprocess instanceof import_child_process.ChildProcess)childprocess.send(JSON.stringify(res));else process.stdout.write(JSON.stringify(res))}return res};subscribeProcess(route,childprocess,args,key,subInput){if(this.restrict?.[route])return void 0;if(typeof childprocess==="string"&&this.processes[childprocess]){childprocess=this.processes[childprocess].process}return this.subscribe(route,res=>{if(res instanceof Promise){res.then(r=>{childprocess.send(JSON.stringify({args:r,callbackId:route}))})}else{childprocess.send(JSON.stringify({args:res,callbackId:route}))}},args,key,subInput)}subscribeToProcess(route,processId,callback,args,key,subInput){if(typeof processId==="string"&&this.processes[processId]){this.__node.state.subscribeEvent(processId,res=>{if(res?.callbackId===route){if(!callback)this.setState({[processId]:res.args});else if(typeof callback==="string"){this.run(callback,res.args)}else callback(res.args)}});return this.processes[processId].request(JSON.stringify({route:"subscribeSocket",args:[route,processId,args,key,subInput]}))}}};var DataStructures_exports={};__export(DataStructures_exports,{AuthorizationStruct:()=>AuthorizationStruct,ChatroomStruct:()=>ChatroomStruct,CoherenceMap:()=>CoherenceMap,CoherenceStruct:()=>CoherenceStruct,CommentStruct:()=>CommentStruct,Data:()=>Data,DataStruct:()=>DataStruct,DateStruct:()=>DateStruct,ECGStruct:()=>ECGStruct,EDAStruct:()=>EDAStruct,EEGCoordinates:()=>EEGCoordinates,EEGStruct:()=>EEGStruct,EMGStruct:()=>EMGStruct,EventStruct:()=>EventStruct,EyeTrackerStruct:()=>EyeTrackerStruct,FNIRSStruct:()=>FNIRSStruct,FrequencyBandsStruct:()=>FrequencyBandsStruct,GroupStruct:()=>GroupStruct,HRVStruct:()=>HRVStruct,IMUStruct:()=>IMUStruct,NotificationStruct:()=>NotificationStruct,PPGStruct:()=>PPGStruct,ProfileStruct:()=>ProfileStruct,ScheduleStruct:()=>ScheduleStruct,Struct:()=>Struct,eegCoordinates:()=>eegCoordinates,setCoordinate:()=>setCoordinate,structRegistry:()=>structRegistry});function Struct(structType="struct",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){function randomId3(tag=""){return`${tag+Math.floor(Math.random()+Math.random()*Math.random()*1e16)}`}let struct={_id:randomId3(structType+"defaultId"),structType,ownerId:parentUser?._id,timestamp:Date.now(),parent:{structType:parentStruct?.structType,_id:parentStruct?._id}};if(!struct.ownerId)delete struct.ownerId;if(!struct?.parent?._id)delete struct.parent;if(Object.keys(assignProps).length>0)Object.assign(struct,assignProps);return struct}var eegCoordinates={FP1:[-21.2,66.9,12.1],FPZ:[1.4,65.1,11.3],FP2:[24.3,66.3,12.5],AF7:[-41.7,52.8,11.3],AF3:[-32.7,48.4,32.8],AFZ:[1.8,54.8,37.9],AF4:[35.1,50.1,31.1],AF8:[43.9,52.7,9.3],F5:[-51.4,26.7,24.7],F3:[-39.7,25.3,44.7],F1:[-22.1,26.8,54.9],FZ:[0,26.8,60.6],F2:[23.6,28.2,55.6],F4:[41.9,27.5,43.9],F6:[52.9,28.7,25.2],F7:[-52.1,28.6,3.8],F8:[53.2,28.4,3.1],FC5:[-59.1,3,26.1],FC3:[-45.5,2.4,51.3],FC1:[-24.7,.3,66.4],FCZ:[1,1,72.8],FC2:[26.1,3.2,66],FC4:[47.5,4.6,49.7],FC6:[60.5,4.9,25.5],FT9:[-53.8,-2.1,-29.1],FT7:[-59.2,3.4,-2.1],FT8:[60.2,4.7,-2.8],FT10:[55,-3.6,-31],T7:[-65.8,-17.8,-2.9],T5:[-61.5,-65.3,1.1],T3:[-70.2,-21.3,-10.7],T4:[71.9,-25.2,-8.2],T6:[59.3,-67.6,3.8],T8:[67.4,-18.5,-3.4],C5:[-63.6,-18.9,25.8],C3:[-49.1,-20.7,53.2],C1:[-25.1,-22.5,70.1],CZ:[.8,-21.9,77.4],C2:[26.7,-20.9,69.5],C4:[50.3,-18.8,53],C6:[65.2,-18,26.4],CP5:[-61.8,-46.2,22.5],CP3:[-46.9,-47.7,49.7],CP1:[-24,-49.1,66.1],CPZ:[.7,-47.9,72.6],CP2:[25.8,-47.1,66],CP4:[49.5,-45.5,50.7],CP6:[62.9,-44.6,24.4],TP9:[-73.6,-46.7,-4],TP7:[-63.6,-44.7,-4],TP8:[64.6,-45.4,-3.7],TP10:[74.6,-47.4,-3.7],P9:[-50.8,-51.3,-37.7],P7:[-55.9,-64.8,0],P5:[-52.7,-67.1,19.9],P3:[-41.4,-67.8,42.4],P1:[-21.6,-71.3,52.6],PZ:[.7,-69.3,56.9],P2:[24.4,-69.9,53.5],P4:[44.2,-65.8,42.7],P6:[54.4,-65.3,20.2],P8:[56.4,-64.4,.1],P10:[51,-53.9,-36.5],PO7:[-44,-81.7,1.6],PO3:[-33.3,-84.3,26.5],POZ:[0,-87.9,33.5],PO4:[35.2,-82.6,26.1],PO8:[43.3,-82,.7],O1:[-25.8,-93.3,7.7],OZ:[.3,-97.1,8.7],O2:[25,-95.2,6.2]};function setCoordinate(channelDict,assignTo={}){if(!eegCoordinates[channelDict.tag]&&channelDict.position){eegCoordinates[channelDict.tag]=[channelDict.position.x,channelDict.position.y,channelDict.position.z]}if(eegCoordinates[channelDict.tag]){let props={channel:"",position:{x:eegCoordinates[channelDict.tag][0],y:eegCoordinates[channelDict.tag][1],z:eegCoordinates[channelDict.tag][2]}};return Object.assign(assignTo,props)}else return Object.assign(assignTo,channelDict)}function EEGCoordinates(channelDicts=[],genCoherenceMap=true){let structs=[];for(let channelDict of channelDicts){let struct=EEGStruct(channelDict);structs.push(struct)}if(genCoherenceMap){structs.push(...CoherenceMap({channelDicts}))}return structs}function FrequencyBandsStruct(additionalBands=[],assignTo={}){let bands={scp:[],delta:[],theta:[],alpha1:[],alpha2:[],beta:[],lowgamma:[],highgamma:[]};additionalBands.forEach(band=>bands[band]=[]);return Object.assign(assignTo,bands)}function EEGStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let bands=FrequencyBandsStruct();let props={tag,position:{x:0,y:0,z:0},count:0,times:[],raw:[],filtered:[],fftCount:0,fftTimes:[],ffts:[],slices:JSON.parse(JSON.stringify(bands)),means:JSON.parse(JSON.stringify(bands)),startTime:Date.now()};let struct=Struct("eeg",props,parentUser,parentStruct);if(tag)setCoordinate(props,struct);return Object.assign(struct,assignProps)}function CoherenceStruct(coords={0:EEGStruct("FP1"),1:EEGStruct("FP2")},assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let bands=FrequencyBandsStruct();let props={tag:coords[0]?.tag+"::"+coords[1]?.tag,x0:coords[0]?.position?.x,y0:coords[0]?.position?.y,z0:coords[0]?.position?.z,x1:coords[1]?.position?.x,y1:coords[1]?.position?.y,z1:coords[1]?.position?.z,fftCount:0,fftTimes:[],ffts:[],slices:JSON.parse(JSON.stringify(bands)),means:JSON.parse(JSON.stringify(bands)),startTime:Date.now()};let struct=Struct("coherence",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function CoherenceMap(opts={channelDicts:[{ch:0,tag:"FP1",analyze:false},{ch:1,tag:"FP2",analyze:false}],taggedOnly:true},_={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){var cmap=[];var l=1,k=0;for(var i=0;i<opts.channelDicts.length*(opts.channelDicts.length+1)/2-opts.channelDicts.length;i++){if(opts.taggedOnly===false||opts.taggedOnly===true&&(opts.channelDicts[k].tag!==null&&opts.channelDicts[k+l].tag!==null&&(opts.channelDicts[k].tag!=="other"&&opts.channelDicts[k+l].tag!=="other")&&(opts.channelDicts[k].analyze===true&&opts.channelDicts[k+l].analyze===true))){var coord0=EEGStruct(opts.channelDicts[k].tag);var coord1=EEGStruct(opts.channelDicts[k+l].tag);cmap.push(CoherenceStruct({0:coord0,1:coord1},{},parentUser,parentStruct))}l++;if(l+k===opts.channelDicts.length){k++;l=1}}return cmap}function FNIRSStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,position:{x:0,y:0,z:0},count:0,times:[],red:[],ir:[],ir2:[],ambient:[],ratio:[],temp:[],beat_detect:{beats:[],breaths:[],rir:[],rir2:[],drir_dt:[],localmins:[],localmaxs:[],val_dists:[],peak_dists:[],localmins2:[],localmaxs2:[],val_dists2:[],peak_dists2:[]},startTime:Date.now()};let struct=Struct("fnirs",props,parentUser,parentStruct);if(tag)setCoordinate(props,struct);return Object.assign(struct,assignProps)}function IMUStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,Ax:[],Ay:[],Az:[],Gx:[],Gy:[],Gz:[],startTime:Date.now()};let struct=Struct("imu",props,parentUser,parentStruct);if(tag)setCoordinate(props,struct);return Object.assign(struct,assignProps)}function EyeTrackerStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,count:0,times:[],x:[],y:[],smax:[],smay:[],startTime:Date.now()};let struct=Struct("eyetracker",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function ECGStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,count:0,times:[],raw:[],filtered:[],bpm:[],hrv:[],startTime:Date.now()};let struct=Struct("ecg",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function EDAStruct(_="",__={},___={_id:""},____={structType:"struct",_id:""}){}function PPGStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let struct=FNIRSStruct(tag,parentUser,parentStruct,assignProps);struct.structType="ppg";return struct}function HRVStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let struct=ECGStruct(tag,parentUser,parentStruct,assignProps);struct.structType="hrv";return struct}function EMGStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let struct=EEGStruct(tag,parentUser,parentStruct,assignProps);struct.structType="emg";return struct}function ProfileStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,name:"",username:"",firstName:"",lastName:"",email:"",phone:"",sex:"",birthday:"",type:"",pictureUrl:"",userRoles:{},socials:{},data:{},hidden:false,accessToken:"",refreshToken:""};let struct=Struct("profile",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function AuthorizationStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,authorizedId:"",authorizedName:"",authorizerId:"",authorizerName:"",authorizations:{},structs:{},excluded:{},groups:{},status:"PENDING",expires:false,associatedAuthId:""};let struct=Struct("authorization",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function GroupStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,name:"",details:"",admins:{},peers:{},clients:{},users:{}};let struct=Struct("group",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function Data(type,data){return{type,data,timestamp:Date.now()}}function DataStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,title:"",author:"",expires:false,type:"",data:new Array};let struct=Struct("data",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function EventStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,event:"",author:"",startTime:"",endTime:"",grade:void 0,value:void 0,units:void 0,location:void 0,notes:"",attachments:new Array,users:{}};let struct=Struct("event",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function ChatroomStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,message:"",topic:"",author:"",attachments:new Array,comments:new Array,replies:new Array,users:{},audioChatActive:false,videoChatActive:false};let struct=Struct("chatroom",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function CommentStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,author:"",replyTo:"",message:"",rating:0,replies:new Array,users:{},attachments:new Array};let struct=Struct("comment",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function NotificationStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,note:"",parentUserId:""};let struct=Struct("notification",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function ScheduleStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,title:"",author:"",attachments:new Array,dates:new Array};let struct=Struct("schedule",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}function DateStruct(tag="",assignProps={},parentUser={_id:""},parentStruct={structType:"struct",_id:""}){let props={tag,timeSet:"",notes:"",recurs:"NEVER",attachments:new Array};let struct=Struct("date",props,parentUser,parentStruct);return Object.assign(struct,assignProps)}var structRegistry={Struct,EEGStruct,FNIRSStruct,CoherenceStruct,CoherenceMap,FrequencyBandsStruct,IMUStruct,EyeTrackerStruct,ECGStruct,EDAStruct,PPGStruct,HRVStruct,EMGStruct,ProfileStruct,AuthorizationStruct,GroupStruct,DataStruct,EventStruct,ChatroomStruct,CommentStruct,NotificationStruct,ScheduleStruct,DateStruct};var DataTablet=class{id;threaded;workers;DS=DataStructures_exports;collections=new Map;data={byTime:{},notes:{},events:{},sleep:{},food:{},rx:{},hr:{},ppg:{},hrv:{},ecg:{},emg:{},eeg:{},fnirs:{}};rolloverLimit=5e4;dataSorts=new Map;watches={};constructor(props={}){Object.assign(this.data,props);this.dataSorts=new Map;this.watches={};this.setSort("event",dataObj=>{if(!this.data.events[dataObj.timestamp])this.data.events[dataObj.timestamp]=[dataObj];else this.data.events[dataObj.timestamp].push(dataObj);if(dataObj.event==="sleep"){if(!this.data.sleep[dataObj.timestamp])this.data.sleep[dataObj.timestamp]=[dataObj];else this.data.sleep[dataObj.timestamp].push(dataObj)}return dataObj});this.setSort(["notes","note","link"],dataObj=>{if(!this.data.notes[dataObj.timestamp])this.data.notes[dataObj.timestamp]=[dataObj];else this.data.notes[dataObj.timestamp].push(dataObj);if(!this.data.byTime[dataObj.timestamp])this.data.byTime[dataObj.timestamp]=[dataObj];else this.data.byTime[dataObj.timestamp].push(dataObj);return dataObj});this.id=this.randomId("dataTablet")}randomId(tag=""){return`${tag+Math.floor(Math.random()+Math.random()*Math.random()*1e16)}`}setLocalData(structs){let setInCollection=s=>{let type=s.structType;let collection=this.collections.get(type);if(!collection){collection=new Map;this.collections.set(type,collection)}collection.set(s._id,s);this.onCollectionSet(type,collection)};if(Array.isArray(structs)){structs.forEach(s=>{setInCollection(s)})}else setInCollection(structs)}getLocalData(collection,query){let ownerId="";let key="";let value="";if(typeof query==="object"){ownerId=query.ownerId;const keys=Object.keys(query).filter(k=>k!="ownerId");key=keys[0];value=query[key]}else value=query;if(!collection&&!ownerId&&!key&&!value)return[];let result=[];if(!collection&&(ownerId||key)){this.collections.forEach(c=>{if((key==="_id"||key==="id")&&value){let found=c.get(value);if(found)result.push(found)}else{c.forEach(struct=>{if(key&&value){if(struct[key]===value&&struct.ownerId===ownerId){result.push(struct)}}else if(struct.ownerId===ownerId){result.push(struct)}})}});return result}else{let c=this.collections.get(collection);if(!c)return result;if(!key&&!ownerId){c.forEach(struct=>{result.push(struct)});return result}if((key==="_id"||key==="id")&&value)return c.get(value);else{c.forEach((struct,_)=>{if(key&&value&&!ownerId){if(struct[key]===value)result.push(struct)}else if(ownerId&&!key){if(struct.ownerId===ownerId)result.push(struct)}else if(ownerId&&key&&value){if(struct.ownerId===ownerId&&struct[key]){if(struct[key]===value)result.push(struct)}}})}}return result}onCollectionSet=(type,collection)=>{};runSort(key,dataObj={},newdata=[],tablet=this){let result;let sort=this.getSort(key);if(sort)result=sort(dataObj,newdata,tablet);else return false;return result}setSort(key,response=(data,newdata=[],tablet=this)=>{}){if(Array.isArray(key))key.forEach(k=>{this.dataSorts.set(k,response)});else this.dataSorts.set(key,response)}getSort(key){return this.dataSorts.get(key)}checkWatches(sorted={}){for(const prop in this.watches){let triggered=this.watches[prop].ondata(sorted,this.watches[prop].accum,this.watches[prop].ownerId);if(triggered){this.watches[prop].ontrigger(this.watches[prop].accum);this.watches[prop].triggered=false}}}setWatch(name,ownerId,ondata=(sorted,accum,ownerId2)=>{if(sorted.ownerId===ownerId2)accum.data[sorted._id]=sorted;if(Object.keys(accum.data).length>10){return true}else return false},ontrigger=accum=>{console.log(accum);let alert=Struct("alert",{alert:true,data:accum},{_id:accum[Object.keys(accum)[0]].ownerId});accum={}}){this.watches[name]={accum:{},ownerId,ondata,ontrigger}}getWatch(name){return this.watches[name]}async sortStructsIntoTable(datastructs=[]){let ascending=function(a,b){if(a.timestamp&&b.timestamp)return a.timestamp-b.timestamp};datastructs.sort(ascending);let newdata=[];for(let i=0;i<datastructs.length;i++){let struct=datastructs[i];if(!struct.timestamp)continue;let timestamp=struct.timestamp;if(!this.data.byTime[timestamp])this.data.byTime[timestamp]=[struct];else this.data.byTime[timestamp].push(struct);if(struct.structType==="data"&&struct.data){struct.data.forEach(async dat=>{if(typeof dat==="object"&&!Array.isArray(dat)){let typ=dat.dataType;dat.ownerId=struct.ownerId;if(!dat.timestamp)dat.timestamp=timestamp;if(typ){let sorted=this.runSort(typ,dat,newdata,this);if(!sorted){if(!this.data[typ])this.data[typ]={};dat.timestamp=timestamp;if(!this.data[typ][timestamp])this.data[typ][timestamp]=[dat];else this.data[typ][timestamp].push(dat);if(!this.data.byTime[timestamp])this.data.byTime[timestamp]=[dat];else this.data.byTime[timestamp].push(dat);this.checkWatches(dat);this.onUpdate(timestamp,dat);newdata.push(dat)}else{if(sorted.constructor?.name!=="Promise"){this.checkWatches(sorted);this.onUpdate(timestamp,sorted);newdata.push(sorted)}}}}})}else{let sorted=this.runSort(struct.structType,struct,newdata,this);if(!sorted){let typ=struct.structType;if(!this.data[typ])this.data[typ]={};if(!this.data[typ][timestamp])this.data[typ][timestamp]=[struct];else this.data[typ][timestamp].push(struct);this.checkWatches(struct);this.onUpdate(timestamp,struct);newdata.push(struct)}else{this.checkWatches(sorted);this.onUpdate(timestamp,sorted);newdata.push(sorted)}}}for(const prop in this.data){this.data[prop]=this.sortObjectByPropName(this.data[prop])}this.onSorted(newdata)}onUpdate(_,__,___=this.data){}onSorted(_=[]){}getDataByTimestamp(timestamp,ownerId){let result=this.data.byTime[timestamp];if(ownerId&&result)result=result.filter(o=>{if(!ownerId)return true;else if(ownerId===o.ownerId)return true;else return false});return result}getDataByTimeRange(begin,end,type,ownerId){let result={};if(type){for(const key in this.data[type]){let t2=parseInt(key);if(t2>begin&&t2<end){result[key]=[...this.data[type][key]]}}if(type==="sleep"){result=this.filterSleepResults(result)}}else{for(const key in this.data.byTime){let t2=parseInt(key);if(t2>begin&&t2<end){result[key]=[...this.data.byTime[key]]}}}if(ownerId&&result){for(const key in result){let popidx=[];result[key]=result[key];result[key].forEach((o,i)=>{if(o.ownerId!==ownerId){popidx.push(i)}});popidx.reverse().forEach(idx=>{result[key].splice(idx,1)});if(result[key].length===0)delete result[key]}}return result}getDataByType(type,timestamp,ownerId){if(!this.data[type])return void 0;let result={...this.data[type]};if(timestamp)result=[...result[timestamp]];if(ownerId&&result){for(const key in result){let popidx=[];result[key]=[...result[key]];result[key].forEach((o,i)=>{if(o.ownerId!==ownerId){popidx.push(i)}});popidx.reverse().forEach(idx=>{result[key].splice(idx,1)});if(result[key].length===0)delete result[key]}}if(type==="sleep"){result=this.filterSleepResults(result)}return result}filterSleepResults(unfiltered={}){let events=[];for(const key in unfiltered){unfiltered[key]=[...unfiltered[key]];events.push(...unfiltered[key].filter(o=>{if(o.structType==="event")return true;else return false}))}events.forEach(ev=>{let foundidx;for(const key in unfiltered){unfiltered[key].forEach((o,i)=>{if(o.structType==="fitbitsleep"&&ev.startTime&&ev.endTime){if(Math.abs(o.startTime-ev.startTime)<1e3*12*3600&&Math.abs(o.endTime-ev.endTime)<1e3*12*3600&&ev.endTime-ev.startTime>1e3*2*3600){foundidx=i;return true}else return false}else return false});if(foundidx)unfiltered[key].splice(foundidx,1)}});let result=unfiltered;return result}sortObjectByPropName(object){const ordered=Object.keys(object).sort().reduce((obj,key)=>{obj[key]=object[key];return obj},{});return ordered}checkRollover(collection,limit=this.rolloverLimit){if(!collection)return false;let c=this.collections.get(collection);if(!c)return false;c.forEach(struct=>{for(const prop in struct){if(Array.isArray(struct[prop])){if(struct[prop].length>limit){struct[prop].slice(struct[prop].length-limit);if(prop==="ffts"){struct.fftCount=struct[prop].length}else if(prop==="times"){struct.count=struct[prop].length}}}else if(typeof struct[prop]==="object"){this.checkRollover(struct[prop])}}});return true}};var defaultSpecifiers=["now","minute","5 minutes","30 minutes","hour","6 hours","12 hours","day","3 days","week","2 weeks","month","6 months","year","5 years","decade"];function genTimeSpecifiers(specifiers=defaultSpecifiers){let result=["now"];specifiers.forEach(s=>{if(s!=="now")result.push(`last ${s}`);else result.push(s)});return result}function genTimestampFromString(specifier){const now=new Date;if(specifier==="now"){}else if(specifier==="last minute"){now.setMinutes(now.getMinutes()-1)}else if(specifier==="last hour"){now.setHours(now.getHours()-1)}else if(specifier==="last day"){now.setDate(now.getDate()-1)}else if(specifier==="last week"){now.setDate(now.getDate()-7)}else if(specifier==="last month"){now.setMonth(now.getMonth()-1)}else if(specifier==="last year"){now.setFullYear(now.getFullYear()-1)}else if(specifier==="last decade"){now.setFullYear(now.getFullYear()-1*10)}else if(specifier==="last century"){now.setFullYear(now.getFullYear()-1*100)}else if(specifier==="last millennium"){now.setFullYear(now.getFullYear()-1*1e3)}else if(specifier==="last microsecond"){now.setMilliseconds(now.getMilliseconds()-1)}else if(specifier==="last nanosecond"){now.setMilliseconds(now.getMilliseconds()-1*.001)}else if(specifier.startsWith("last")){const[,count,unit]=specifier.match(/last (\d+) (\w+)/)||[];if(count&&unit){const num=parseInt(count,10);if(unit.includes("minute")){now.setMinutes(now.getMinutes()-num)}else if(unit.includes("hour")){now.setHours(now.getHours()-num)}else if(unit.includes("day")){now.setDate(now.getDate()-num)}else if(unit.includes("week")){now.setDate(now.getDate()-num*7)}else if(unit.includes("month")){now.setMonth(now.getMonth()-num)}else if(unit.includes("year")){now.setFullYear(now.getFullYear()-num)}else if(unit.includes("decade")){now.setFullYear(now.getFullYear()-num*10)}else if(unit.includes("century")){now.setFullYear(now.getFullYear()-num*100)}else if(unit.includes("millennium")){now.setFullYear(now.getFullYear()-num*1e3)}else if(unit.includes("microsecond")){now.setMilliseconds(now.getMilliseconds()-num)}else if(unit.includes("nanosecond")){now.setMilliseconds(now.getMilliseconds()-num*.001)}}}return now.getTime()}var randomId=prefix=>(prefix?`${prefix}`:"")+Math.floor(1e15*Math.random());var pseudoObjectId=(m=Math,d=Date,h=16,s=s2=>m.floor(s2).toString(h))=>s(d.now()/1e3)+" ".repeat(h).replace(/./g,()=>s(m.random()*h));var StructFrontend=class extends Service{name="structs";currentUser;tablet=new DataTablet;collections=this.tablet.collections;id=randomId();useAccessTokens=false;useRefreshTokens=false;constructor(options,user){super(options);this.load(this);if(options.useAccessTokens)this.useAccessTokens=options.useAccessTokens;if(options.useRefreshTokens)this.useRefreshTokens=options.useRefreshTokens;if(user instanceof Object&&Object.keys(user).length>0)this.setupUser(user)}getToken(user){if(this.useRefreshTokens)return user.refreshToken;else return user.accessToken}setupUser=async(userinfo,callback=currentUser=>{})=>{if(!userinfo){console.error('must provide a minimum info object! e.g. {_id:"abc123"}');callback(void 0);return void 0}let changed=false;if(userinfo.id&&!userinfo._id)userinfo._id=userinfo.id;else if(userinfo._id)userinfo.id=userinfo._id;let res=await this.getUser(userinfo._id);let user=res?.user;let u2;let newu=false;if(!user||!user._id){u2=this.userStruct(userinfo,false);newu=true;let wasSet=await this.setUser(u2);let structs=this.getLocalData(void 0,{"ownerId":u2._id});if(structs?.length>0)this.updateServerData(structs);this.setAuthorizationsByGroup(u2)}else{u2=user;let toUpdate={_id:userinfo._id,ownerId:userinfo._id};let struct=this.userStruct(userinfo,false);for(const key in struct){if(userinfo[key]&&user[key]!==userinfo[key]){toUpdate[key]=userinfo[key];user[key]=userinfo[key]}else if(struct[key]&&!user[key]){toUpdate[key]=struct[key];user[key]=struct[key]}}if(Object.keys(toUpdate).length>2)await this.setUser(toUpdate);if(res?.authorizations){if(Array.isArray(res.authorizations)){this.setLocalData(res.authorizations)}}if(res?.groups){if(Array.isArray(res.groups)){this.setLocalData(res.groups)}}}if(newu){this.setLocalData(u2)}else{let data=await this.getAllUserData(u2._id,void 0,[genTimestampFromString("last day"),Date.now()]);if(!data||data.length===0){}else{this.setLocalData(data);let notes=data.filter(s=>{if(s.structType==="notification"){if(this.getLocalData("authorization",s.parent._id)){return true}if(s.parent.structType==="user"||s.parent.structType==="authorization"){return true}if(!this.getLocalData(s.parent.structType,s.parent._id))return true}});let comments=data.filter(s=>{if(s.structType==="comment"){return true}});let toDelete=[];comments.forEach(comment=>{if(!this.getLocalData("comment",{"_id":comment._id}))toDelete.push(comment._id)});if(toDelete.length>0)this.deleteData(toDelete);if(notes.length>0){this.resolveNotifications(notes,false,void 0);changed=true}let filtered=data.filter(o=>{if(o.structType!=="notification")return true});if(this.tablet)this.tablet.sortStructsIntoTable(filtered)}this.setLocalData(u2)}if(u2){if(this.currentUser)Object.assign(this.currentUser,u2);else this.currentUser=u2;callback(this.currentUser);return this.currentUser}else{callback(u2);return u2}};baseServerCallback=async data=>{let structs=data;if(typeof data==="object"&&data?.structType)structs=[data];if(Array.isArray(structs)){let filtered=structs.filter(o=>{if(o.structType!=="notification")return true});if(this.tablet)this.tablet.sortStructsIntoTable(filtered);for(let i=0;i<structs.length;i++){const struct=structs[i];if(typeof struct==="object"){if(!struct.structType||struct.structType==="USER"){if(struct.email)struct.structType="user";else struct.structType="uncategorized"}if(struct.structType==="user"||struct.structType==="authorization"||struct.structType==="group"){if(struct.structType==="user"){struct._id=struct.id}else if(struct.structType==="group"){if(this.currentUser){let uset=false;if(struct.admins[this.currentUser?._id]&&!this.currentUser.userRoles?.[struct.name+"_admin"]){this.currentUser.userRoles[struct.name+"_admin"]=true;uset=true}else if(!struct.admins[this.currentUser?._id]&&this.currentUser.userRoles?.[struct.name+"_admin"]){delete this.currentUser.userRoles[struct.name+"_admin"];uset=true}if(struct.admins[this.currentUser?._id]&&!this.currentUser.userRoles?.[struct.name+"_peer"]){this.currentUser.userRoles[struct.name+"_peer"]=true;uset=true}else if(!struct.admins[this.currentUser?._id]&&this.currentUser.userRoles?.[struct.name+"_peer"]){delete this.currentUser.userRoles[struct.name+"_peer"];uset=true}if(struct.admins[this.currentUser?._id]&&!this.currentUser.userRoles?.[struct.name+"_client"]){this.currentUser.userRoles[struct.name+"_client"]=true;uset=true}else if(!struct.admins[this.currentUser?._id]&&this.currentUser.userRoles?.[struct.name+"_client"]){delete this.currentUser.userRoles[struct.name+"_client"];uset=true}if(uset)await this.setUser(this.currentUser)}}this.setLocalData(struct)}else{if(struct.structType==="notification"){let found=this.getLocalData("notification",{"ownerId":struct.ownerId,"_id":struct.parent._id});if(found){this.setLocalData(struct)}else{if(this.getLocalData(struct.structType,{"_id":struct.parent._id})){}else{this.overwriteLocalData(struct)}}if(struct.ownerId===this.currentUser?._id&&(struct.parent.structType==="user"||struct.parent.structType==="dataInstance"||struct.parent.structType==="schedule"||struct.parent.structType==="authorization")){await this.resolveNotifications([struct],true)}this.onNotify(struct)}else{this.overwriteLocalData(struct)}}}}}this.onData(data)};structNotification=()=>{this.checkForNotifications()};structDeleted=struct=>{this.deleteLocalData([struct])};onData=data=>{};onNotify=notification=>{};randomId(tag=""){return`${tag+Math.floor(Math.random()+Math.random()*Math.random()*1e16)}`}addStruct=async(structType="struct",props={},parentUser,parentStruct,updateServer=true)=>{let newStruct=DataStructures_exports.Struct(structType,props,parentUser,parentStruct);if(updateServer)newStruct=await this.updateServerData([newStruct])[0];return newStruct};getUser=async(info="",basicInfo,callback=this.baseServerCallback)=>{if(this.currentUser?.request){let res=await this.currentUser.request({route:"getUser",args:[this.currentUser._id,info,basicInfo,this.getToken(this.currentUser)]});callback(res);return res}};queryUsers=async(info,skip,limit,callback=this.baseServerCallback)=>{if(this.currentUser?.request){let res=await this.currentUser.request({route:"queryUsers",args:[this.currentUser._id,info,skip,limit,void 0,this.getToken(this.currentUser)]});callback(res);return res}};getUsers=async(ids=[],basicInfo,callback=this.baseServerCallback)=>{if(this.currentUser?.request){let res=await this.currentUser.request({route:"getUsersByIds",args:[this.currentUser._id,ids,basicInfo]});callback(res);return res}};getUsersByRole=async(userRole,callback=this.baseServerCallback)=>{if(this.currentUser?.request){let res=await this.currentUser.request({route:"getUsersByRole",args:[this.currentUser._id,userRole]});callback(res);return res}};getAllUserData=async(ownerId,excluded=[],timeRange,callback=this.baseServerCallback)=>{if(timeRange){if(typeof timeRange[0]==="string")timeRange[0]=genTimestampFromString(timeRange[0]);if(typeof timeRange[1]==="string")timeRange[1]=genTimestampFromString(timeRange[1])}if(this.currentUser?.request){let res=await this.currentUser.request({route:"getAllData",args:[this.currentUser._id,ownerId,excluded,timeRange,this.getToken(this.currentUser)]});callback(res);return res}};query=async(collection,mongoQuery={},findOne=false,skip=0,callback=this.baseServerCallback)=>{if(this.currentUser?.request){if(!collection||!mongoQuery)return void 0;let res=await this.currentUser.request({route:"query",args:[this.currentUser._id,collection,mongoQuery,findOne,skip,this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};getDataByTimeRange(collection,timeRange,ownerId,limit=0,skip=0,key){let query={};if(timeRange){if(typeof timeRange[0]==="string")timeRange[0]=genTimestampFromString(timeRange[0]);if(typeof timeRange[1]==="string")timeRange[1]=genTimestampFromString(timeRange[1])}let range={$gt:timeRange[0],$lt:timeRange[1]};if(key)query[key]=range;else query.timestamp=range;return this.getData(collection,ownerId,query,limit,skip)}getData=async(collection,ownerId,searchDict,limit=0,skip=0,callback=this.baseServerCallback)=>{if(this.currentUser?.request){let res=await this.currentUser.request({route:"getData",args:[this.currentUser._id,collection,ownerId,searchDict,limit,skip,this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};getDataByIds=async(structIds=[],ownerId,collection,callback=this.baseServerCallback)=>{if(this.currentUser?.request){let res=await this.currentUser.request({route:"getDataByIds",args:[this.currentUser._id,structIds,ownerId,collection,this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};getStructParentData=async(struct,callback=this.baseServerCallback)=>{if(!struct?.parent)return;if(this.currentUser?.request){let args=[this.currentUser._id,struct.parent?.structType,"_id",struct.parent?._id,this.getToken(this.currentUser)];let res=(await this.currentUser.request({route:"getData",args}))?.[0];if(typeof callback==="function")callback(res);return res}};setUser=async(userStruct,callback=this.baseServerCallback)=>{console.log(this.currentUser);if(userStruct&&this.currentUser?.request){let res=await this.currentUser.request({route:"setUser",args:[this.currentUser._id,this.stripStruct(userStruct),this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};checkUserToken=async(usertoken,user=this.currentUser,callback=this.baseServerCallback)=>{if(!usertoken)return false;let changed=false;for(const prop in usertoken){let dummystruct=this.userStruct();if(user[prop]&&prop!=="_id"){if(Array.isArray(usertoken[prop])){for(let i=0;i<user[prop].length;i++){if(usertoken[prop].indexOf(user[prop][i])<0){user[prop]=usertoken[prop];changed=true;break}}if(!changed)for(let i=0;i<usertoken[prop].length;i++){if(user[prop].indexOf(usertoken[prop][i])<0){user[prop]=usertoken[prop];changed=true;break}}}else if(user[prop]!==usertoken[prop]){user[prop]=usertoken[prop];changed=true}}else if(!user[prop]&&dummystruct[prop]){user[prop]=usertoken[prop];changed=true}}if(changed)return await this.setUser(user,callback);return changed};setData=async(structs=[],notify=true,callback=this.baseServerCallback)=>{if(this.currentUser?.request){const copies=new Array;if(!Array.isArray(structs)&&typeof structs==="object")structs=[structs];structs.forEach(struct=>{copies.push(this.stripStruct(struct))});let res=await this.currentUser.request({route:"setData",args:[this.currentUser._id,copies,notify,this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};updateServerData=this.setData;deleteData=async(structs=[],callback=this.baseServerCallback)=>{if(this.currentUser?.request){let toDelete=[];structs.forEach(struct=>{if(typeof struct==="object"){if(struct?.structType&&struct?._id){toDelete.push({structType:struct.structType,_id:struct._id});this.deleteLocalData(struct)}}else if(typeof struct==="string"){let localstruct=this.getLocalData(void 0,{_id:struct});if(localstruct&&!Array.isArray(localstruct)){toDelete.push({structType:localstruct.structType,_id:localstruct._id})}else{toDelete.push({_id:struct})}}});let res=await this.currentUser.request({route:"deleteData",args:[this.currentUser._id,toDelete,this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};deleteUser=async(userId=this.currentUser._id,deleteData,callback=this.baseServerCallback)=>{if(this.currentUser?.request){if(!userId)return;let res=await this.currentUser.request({route:"deleteUser",args:[this.currentUser._id,userId,deleteData,this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};setGroup=async(groupStruct,callback=this.baseServerCallback)=>{if(groupStruct&&this.currentUser?.request){let res=await this.currentUser.request({route:"setGroup",args:[this.currentUser._id,this.stripStruct(groupStruct),this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};getUserGroups=async(userId=this.currentUser._id,groupId="",callback=this.baseServerCallback)=>{if(this.currentUser?.request){let res=await this.currentUser.request({route:"getUserGroups",args:[this.currentUser._id,userId,groupId,this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};deleteGroup=async(groupId,callback=this.baseServerCallback)=>{if(this.currentUser?.request){if(!groupId)return;this.deleteLocalData(groupId);let res=await this.currentUser.request({route:"deleteGroup",args:[this.currentUser._id,groupId,this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};setAuthorization=async(authorizationStruct,callback=this.baseServerCallback)=>{if(authorizationStruct&&this.currentUser?.request){let res=await this.currentUser.request({route:"setAuthorization",args:[this.currentUser._id,this.stripStruct(authorizationStruct),this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};getAuthorizations=async(userId=this.currentUser?._id,authorizationId="",callback=this.baseServerCallback)=>{if(this.currentUser?.request){if(userId===void 0)return;let res=await this.currentUser.request({route:"getAuthorizations",args:[this.currentUser._id,userId,authorizationId,this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};deleteAuthorization=async(authorizationId,callback=this.baseServerCallback)=>{if(this.currentUser?.request){if(!authorizationId)return;this.deleteLocalData(authorizationId);let res=await this.currentUser.request({route:"deleteAuthorization",args:[this.currentUser._id,authorizationId,this.getToken(this.currentUser)]});if(typeof callback==="function")callback(res);return res}};checkForNotifications=async(userId=this.currentUser?._id)=>{return await this.getData("notification",userId)};resolveNotifications=async(notifications=[],pull=true,user=this.currentUser)=>{if(!user||notifications.length===0)return;let structIds=[];let notificationIds=[];let nTypes=[];let unote=false;if(notifications.length===0)notifications=this.getLocalData("notification",{"ownerId":user._id});notifications.forEach(struct=>{if(struct.parent.structType==="user")unote=true;nTypes.push(struct.parent.structType);structIds.push(struct.parent._id);notificationIds.push(struct._id);this.deleteLocalData(struct)});this.deleteData(notifications);if(pull){nTypes.reverse().forEach((note,i)=>{if(note==="user"){this.getUser(structIds[i]);structIds.splice(structIds.length-i-1,1)}});if(structIds.length===1)return await this.getDataByIds(structIds,void 0,notifications[0].parent.structType);if(structIds.length>0)return await this.getDataByIds(structIds)}return true};setAuthorizationsByGroup=async(user=this.currentUser)=>{let auths=this.getLocalData("authorization",{"ownerId":user._id});let newauths=[];if(user.userRoles)await Promise.all(Object.keys(user.userRoles).map(async role=>{let split=role.split("_");let team=split[0];let otherrole;if(role.includes("client")){otherrole=team+"_peer"}else if(role.includes("peer")){otherrole=team+"_client"}else if(role.includes("admin")){otherrole=team+"_owner"}if(otherrole){let users=await this.getUsersByRole(otherrole);if(users)await Promise.all(users.map(async groupie=>{let theirname=groupie.username;if(!theirname)theirname=groupie.email;if(!theirname)theirname=groupie._id;let myname=user.username;if(!myname)myname=user.email;if(!myname)myname=user._id;if(theirname!==myname){if(role.includes("client")){let found=auths.find(a=>{if(a.authorizerId===groupie._id&&a.authorizedId===user._id)return true});if(!found){let auth=await this.authorizeUser(DataStructures_exports.ProfileStruct("user",user,user),groupie._id,theirname,user._id,myname,{"peer":true},void 0,{group:team});newauths.push(auth)}}else if(role.includes("peer")){let found=auths.find(a=>{if(a.authorizedId===groupie._id&&a.authorizerId===user._id)return true});if(!found){let auth=await this.authorizeUser(DataStructures_exports.ProfileStruct("user",user,user),user._id,myname,groupie._id,theirname,{"peer":true},void 0,{group:team});newauths.push(auth)}}}}))}}));if(newauths.length>0)return newauths;return void 0};deleteRoom=async roomStruct=>{if(!roomStruct)return false;let toDelete=[roomStruct];roomStruct.comments?.forEach(id=>{let struct=this.getLocalData("comment",{"_id":id});toDelete.push(struct)});if(roomStruct)return await this.deleteData(toDelete);else return false};deleteComment=async commentStruct=>{let allReplies=[commentStruct];let getRepliesRecursive=(head=commentStruct)=>{if(head?.replies){head.replies.forEach(replyId=>{let reply=this.getLocalData("comment",{"_id":replyId});if(reply){if(reply.replies.length>0){reply.replies.forEach(replyId2=>{getRepliesRecursive(replyId2)})}allReplies.push(reply)}})}};getRepliesRecursive(commentStruct);let parent=this.getLocalData(commentStruct.parent?.structType,{"_id":commentStruct.parent?._id});let toUpdate=[];if(parent){toUpdate=[parent];allReplies.forEach(r=>{let idx=parent.replies?.indexOf(r._id);if(idx>-1)parent.replies.splice(idx,1);let idx2=parent.comments?.indexOf(r._id);if(idx2>-1)parent.comments.splice(idx2,1)})}let replyTo=this.getLocalData("comment",{"_id":commentStruct.replyTo});if(replyTo?._id!==parent?._id){let idx=replyTo.replies?.indexOf(parent._id);if(idx>-1)replyTo.replies.splice(idx,1);toUpdate.push(replyTo)}if(toUpdate.length>0)await this.updateServerData(toUpdate);return await this.deleteData(allReplies)};getUserDataByAuthorization=async(authorizationStruct,collection,searchDict,limit=0,skip=0,callback=this.baseServerCallback)=>{let u2=authorizationStruct.authorizerId;if(u2){return new Promise(async resolve=>{this.getUser(u2,true,async data=>{let res;if(!collection)res=await this.getAllUserData(u2,["notification"],void 0,callback);else res=await this.getData(collection,u2,searchDict,limit,skip,callback);resolve(res);callback(res)})})}else return void 0};getUserDataByAuthorizationGroup=async(groupId="",collection,searchDict,limit=0,skip=0,callback=this.baseServerCallback)=>{let auths=this.getLocalData("authorization");let results=[];await Promise.all(auths.map(async o=>{if(o.groups?.includes(groupId)){let u2=o.authorizerId;if(u2){let data;let user=await this.getUser(u2,true,callback);if(user)results.push(user);if(!collection)data=await this.getAllUserData(u2,["notification"],void 0,callback);else data=await this.getData(collection,u2,searchDict,limit,skip,callback);if(data)results.push(data)}return true}}));return results};overwriteLocalData(structs){if(Array.isArray(structs)){structs.forEach(struct=>{let localdat=this.getLocalData(struct.structType,{"ownerId":struct.ownerId,"_id":struct._id});if(!localdat||localdat?.length===0){this.setLocalData(struct)}else Object.assign(localdat,struct)})}else{let localdat=this.getLocalData(structs.structType,{"ownerId":structs.ownerId,"_id":structs._id});if(!localdat||localdat?.length===0){this.setLocalData(structs)}else Object.assign(localdat,structs)}}setLocalData(structs){this.tablet.setLocalData(structs)}getLocalData(collection,query){return this.tablet.getLocalData(collection,query)}getLocalUserPeerIds=(user=this.currentUser)=>{if(!user)return{};let result={};let authorizations=this.getLocalData("authorization",user._id);authorizations.forEach(a=>{if(a.authorizations["peer"]&&a.authorizerId===user._id)result[a.authorizedId]=true});return result};getLocalReplies(struct){let replies=[];if(!struct.replies)return replies;else if(struct.replies.reduce((a,b)=>a*(typeof b==="object"?1:0),1))return struct.replies;replies=this.getLocalData("comment",{"replyTo":struct._id});return replies}hasLocalAuthorization(otherUserId,ownerId=this.currentUser._id){let auths=this.getLocalData("authorization",{ownerId});let found=auths.find(a=>{if(a.authorizedId===ownerId&&a.authorizerId===otherUserId)return true;if(a.authorizerId===ownerId&&a.authorizedId===otherUserId)return true});if(found){return found}else return false}deleteLocalData(structs){if(Array.isArray(structs))structs.forEach(s=>this.deleteStruct(s));else this.deleteStruct(structs);return true}deleteStruct(struct){if(typeof struct==="string")struct=this.getLocalData(void 0,{_id:struct});if(!struct)throw new Error("Struct not supplied");if(!struct.structType||!struct._id)return false;this.tablet.collections.get(struct.structType).delete(struct._id);return true}stripStruct(struct){const copy=Object.assign({},struct);for(const prop in copy){if(copy[prop]===void 0||copy[prop]===""||copy[prop].constructor.name==="Map"||copy[prop].constructor.name==="Set"||typeof copy[prop]==="function")delete copy[prop];else if(Array.isArray(copy[prop])&&copy[prop].length===0)delete copy[prop];else if(typeof copy[prop]==="object"&&Object.keys(copy[prop]).length===0)delete copy[prop]}return copy}createStruct(structType,props,parentUser=this.currentUser,parentStruct){let struct=DataStructures_exports.Struct(structType,props,parentUser,parentStruct);return struct}userStruct(props={},currentUser=false){let user=DataStructures_exports.ProfileStruct(void 0,props,props);if(!user.name&&user.firstName)user.name=user.firstName+" "+user.lastName;else if(user.name&&!user.firstName){let split=user.name.split(" ");user.firstName=split[0];user.lastName=split[split.length-1]}if(props._id)user.id=props._id;else if(props.id)user.id=props.id;else user.id="user"+Math.floor(Math.random()*1e15);user._id=user.id;user.ownerId=user.id;let dummy=DataStructures_exports.ProfileStruct();for(const prop in props){if(Object.keys(dummy).indexOf(prop)<0){delete user[prop]}}if(currentUser)this.currentUser=user;return user}authorizeUser=async(parentUser,authorizerUserId="",authorizerUserName="",authorizedUserId="",authorizedUserName="",authorizations={},structs={},excluded={},groups={},expires=false)=>{if(!parentUser)return void 0;let newAuthorization=this.createStruct("authorization",void 0,parentUser,void 0);newAuthorization.authorizedId=authorizedUserId;newAuthorization.authorizedName=authorizedUserName;newAuthorization.authorizerId=authorizerUserId;newAuthorization.authorizerName=authorizerUserName;newAuthorization.authorizations=authorizations;newAuthorization.structs=structs;newAuthorization.excluded=excluded;newAuthorization.groups=groups;newAuthorization.expires=expires;newAuthorization.status="PENDING";newAuthorization.associatedAuthId="";newAuthorization=await this.setAuthorization(newAuthorization);return newAuthorization};addGroup=async(parentUser,name="",details="",admins={},peers={},clients={},updateServer=true)=>{if(!parentUser)return void 0;let newGroup=this.createStruct("group",void 0,parentUser);newGroup.name=name;newGroup.details=details;newGroup.admins=admins;newGroup.peers=peers;newGroup.clients=clients;newGroup.users={};Object.assign(newGroup.users,newGroup.admins);Object.assign(newGroup.users,newGroup.peers);Object.assign(newGroup.users,newGroup.clients);if(updateServer){newGroup=await this.setGroup(newGroup)}return newGroup};dataObject(data=void 0,type="any",timestamp=Date.now()){return{type,data,timestamp}}addData=async(parentUser,author="",title="",type="",data=[],expires=false,updateServer=true)=>{if(!parentUser)return void 0;let newDataInstance=this.createStruct("dataInstance",void 0,parentUser);newDataInstance.author=author;newDataInstance.title=title;newDataInstance.type=type;newDataInstance.data=data;newDataInstance.expires=expires;if(updateServer)newDataInstance=await this.updateServerData([newDataInstance])[0];return newDataInstance};addEvent=async(parentUser,author="",event="",notes="",startTime,endTime,grade,value,units,location2,attachments,users,updateServer=true)=>{if(!parentUser)return void 0;if(users&&Object.keys(users).length===0)users=this.getLocalUserPeerIds(parentUser);let newEvent=this.createStruct("event",void 0,parentUser);newEvent.author=author;newEvent.event=event;newEvent.notes=notes;newEvent.startTime=startTime;newEvent.endTime=endTime;newEvent.grade=grade;newEvent.attachments=attachments;newEvent.value=value;newEvent.units=units;newEvent.users=users;newEvent.location=location2;if(updateServer)newEvent=await this.updateServerData([newEvent])[0];return newEvent};addChatroom=async(parentUser,authorId="",message="",attachments,users,updateServer=true)=>{if(!parentUser)return void 0;if(users&&Object.keys(users).length===0)users=this.getLocalUserPeerIds(parentUser);let newChatroom=this.createStruct("chatroom",void 0,parentUser);newChatroom.message=message;newChatroom.attachments=attachments;newChatroom.authorId=authorId;newChatroom.users=users;newChatroom.replies=[];newChatroom.comments=[];let update=[newChatroom];if(updateServer)newChatroom=await this.updateServerData(update)[0];return newChatroom};addComment=async(parentUser,roomStruct,replyTo,authorId="",message="",attachments,updateServer=true)=>{if(!roomStruct)return void 0;if(!replyTo)replyTo=roomStruct;if(!parentUser)return void 0;let newComment=this.createStruct("comment",void 0,parentUser,roomStruct);newComment.authorId=authorId;newComment.replyTo=replyTo?._id;newComment.message=message;newComment.attachments=attachments;newComment.users=roomStruct?.users;newComment.replies=[];if(!updateServer)replyTo?.replies.push(newComment._id);if(!updateServer)roomStruct?.comments.push(newComment._id);let update=[newComment,roomStruct];if(replyTo?._id!==roomStruct._id)update.push(replyTo);let res;if(updateServer)res=await this.updateServerData(update);let updatedComment;if(typeof res==="object"){updatedComment=res.find(s=>{if(newComment.ownerId===s.ownerId&&newComment.timestamp===s.timestamp&&newComment.message===s.message){return true}})}if(updatedComment)return updatedComment;return res}};var import_bson=__toESM(require_bson());var randomId2=prefix=>(prefix?`${prefix}_`:"")+Math.floor(1e15*Math.random());var toObjectId=str=>{return typeof str==="string"&&str.length===24?new import_bson.ObjectId(str):str};var getStringId=mongoid=>{if(typeof mongoid==="object")return mongoid.toString();else return mongoid};var defaultCollections=["profile","group","authorization","discussion","chatroom","comment","dataInstance","event","notification","schedule","date"];var StructBackend=class extends Service{name="structs";debug=false;db;users={};collections={};mode="local";useAuths=true;useAccessTokens=false;useRefreshTokens=false;accessTokens=new Map;refreshTokens=new Map;constructor(options,dboptions){super(options);this.load(this);if(dboptions){this.initDB(dboptions)}}initDB=dboptions=>{this.db=dboptions.db;if(dboptions?.users)this.users=dboptions.users;if(dboptions.mode)this.mode=dboptions.mode;if(dboptions?.collections)this.collections=dboptions.collections;if(dboptions.debug)this.debug=dboptions.debug;if(dboptions.useAccessTokens)this.useAccessTokens=dboptions.useAccessTokens;if(dboptions.useRefreshTokens)this.useRefreshTokens=dboptions.useRefreshTokens;if("useAuths"in dboptions)this.useAuths=dboptions.useAuths;defaultCollections.forEach(k=>{if(!this.collections[k]){this.collections[k]=this.db?{instance:this.db.collection(k)}:{};this.collections[k].reference={}}})};query=async(requestingUserId,collection,queryObj,findOne,skip,token)=>{let user=this.users[requestingUserId];if(!user)return false;if(this.mode.indexOf("mongo")>-1){return await this.queryMongo(user,collection,queryObj,findOne,skip,token)}else{let res=this.getLocalData(user,collection);if(res&&!Array.isArray(res)){let passed=!this.useAuths;if(!res?.ownerId)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,res,"READ",token);if(passed)return res}if(typeof skip==="number"&&Array.isArray(res)){if(res.length>skip)res.splice(0,skip)}let data=[];if(res)await Promise.all(res.map(async s=>{let struct=this.getLocalData(getStringId(s._id));let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"READ",token);if(passed)data.push(struct)}));return data}};getUser=async(requestingUserId,lookupId,basicInfo,token)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.indexOf("mongo")>-1){data=await this.getMongoUser(user,lookupId,void 0,basicInfo,token)}else{let struct=this.getLocalData("profile",{_id:lookupId});if(!struct)data={user:void 0};else{let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"READ",token);if(passed){let groups=this.getLocalData("group",{ownerId:lookupId});let auths=this.getLocalData("authorization",{ownerId:lookupId});data={user:struct,groups,authorizations:auths}}else data={user:{}}}}if(this.debug)console.log("getUser: user:",user,"input:",lookupId,"output",data);return data};setUser=async(requestingUserId,struct,token)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(struct.accessToken){this.accessTokens.set(requestingUserId,token)}else if(this.useAccessTokens)return false;if(struct.refreshToken){this.refreshTokens.set(requestingUserId,struct.refreshToken)}else if(this.useRefreshTokens)return false;delete struct.accessToken;delete struct.refreshToken;delete user.accessToken;delete user.refreshToken;if(this.mode.indexOf("mongo")>-1){data=await this.setMongoUser(user,struct,token)}else{let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE",token);if(passed)this.setLocalData(struct);return true}if(this.debug)console.log("setUser user:",user,"input:",struct,"output",data);return data};getUsersByIds=async(requestingUserId,userIds,basicInfo)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.getMongoUsersByIds(user,userIds,basicInfo)}else{data=[];if(Array.isArray(userIds)){let struct=this.getLocalData("profile",{_id:userIds});if(struct){if(basicInfo)data.push({_id:struct._id,username:struct.username,firstName:struct.firstName,lastName:struct.lastName,fullName:struct.fullName,pictureUrl:struct.pictureUrl});else data.push(struct)}}}if(this.debug)console.log("getUserByIds: user:",user,"input:",userIds,"output",data);return data};getUsersByRole=async(requestingUserId,role)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.getMongoUsersByRole(user,role)}else{let profiles=this.getLocalData("profile");data=[];profiles.forEach(struct=>{if(struct.userRoles[role]){data.push(struct)}})}if(this.debug)console.log("getUserByRoles: user:",user,"input:",role,"output",data);return data};deleteUser=async(requestingUserId,userId,deleteData,token)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.deleteMongoUser(user,userId,deleteData,token)}else{data=false;let struct=this.getLocalData(userId);if(struct){let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE",token);if(passed)data=this.deleteLocalData(struct)}}if(this.debug)console.log("deleteUser: user:",user,"input:",userId,"output",data);return data};setData=async(requestingUserId,structs,notify,token)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.setMongoData(user,structs,notify,token)}else{let non_notes=[];data=[];await Promise.all(structs.map(async structId=>{let struct=this.getLocalData(structId);let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE",token);if(passed){if(!this.collections[struct.structType]){this.collections[struct.structType]={};this.collections[struct.structType].reference={}}this.setLocalData(struct);data.push(struct);if(struct.structType!=="notification")non_notes.push(struct)}}));if(non_notes.length>0&&(notify===true||typeof notify==="undefined"))this.checkToNotify(user,non_notes,this.mode);if(this.debug)console.log("setData:",user,structs,data);return true}if(this.debug)console.log("setData: user:",user,"input:",structs,notify,"output",data);return data};getData=async(requestingUserId,collection,ownerId,dict,limit,skip,token)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.getMongoData(user,collection,ownerId,dict,limit,skip,token)}else{data=[];let structs;if(collection)structs=this.getLocalData(collection);if(structs&&ownerId)structs=structs.filter(o=>{if(o.ownerId===ownerId)return true});if(structs)await Promise.all(structs.map(async s=>{let struct=this.getLocalData(getStringId(s._id));let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"READ",token);if(passed)data.push(struct)}))}if(this.debug)console.log("getData: user:",user,"input:",collection,ownerId,dict,limit,skip,"output",data);return data};getDataByIds=async(requestingUserId,structIds,ownerId,collection,token)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.getMongoDataByIds(user,structIds,ownerId,collection,token)}else{data=[];let structs;if(collection)structs=this.getLocalData(collection);if(structs&&ownerId)structs=structs.filter(o=>{if(o.ownerId===ownerId)return true});if(structs)await Promise.all(structs.map(async s=>{let struct=this.getLocalData(getStringId(s._id));let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"READ",token);if(passed)data.push(struct)}))}if(this.debug)console.log("getDataByIds: user:",user,"input:",structIds,ownerId,collection,"output",data);return data};getAllData=async(requestingUserId,ownerId,excludedCollections,timeRange,token)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.getAllUserMongoData(user,ownerId,excludedCollections,timeRange,token)}else{let result=this.getLocalData(void 0,{ownerId});data=[];await Promise.all(result.map(async struct=>{if(excludedCollections){if(excludedCollections.indexOf(struct.structType)<0){let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"READ",token);if(passed)data.push(struct)}}else{let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"READ",token);if(passed)data.push(struct)}}))}if(this.debug)console.log("getAllData: user:",user,"input:",ownerId,excludedCollections,"output",data);return data};deleteData=async(requestingUserId,structIds,token)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.deleteMongoData(user,structIds,token)}else{data=false;await Promise.all(structIds.map(async structId=>{let struct=this.getLocalData(structId);let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE",token);if(passed)this.deleteLocalData(struct);data=true}))}if(this.debug)console.log("deleteData: user:",user,"input:",structIds,"output",data);return data};getUserGroups=async(requestingUserId,userId,groupId)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.getMongoGroups(user,userId,groupId)}else{if(typeof groupId==="string"){data=this.getLocalData("group",{_id:groupId})}else{data=[];let result=this.getLocalData("group");if(userId){result.forEach(struct=>{if(Object.keys(struct.users).includes(userId))data.push(struct)})}else{result.forEach(struct=>{if(Object.keys(struct.users).includes(getStringId(user._id)))data.push(struct)})}}}if(this.debug)console.log("getGroups: user:",user,"input:",userId,groupId,"output",data);return data};deleteGroup=async(requestingUserId,groupId,token)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.deleteMongoGroup(user,groupId,token)}else{let struct=this.getLocalData("group",groupId);let passed=!this.useAuths;if(struct){if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE",token)}if(passed){data=true}}if(this.debug)console.log("deleteGroup: user:",user,"input:",groupId,"output",data);return data};getAuthorizations=async(requestingUserId,ownerId,authId,token)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.getMongoAuthorizations(user,ownerId,authId,token)}else{if(authId){let result=this.getLocalData("authorization",{_id:authId});if(result)data=[result]}else{data=this.getLocalData("authorization",{ownerId})}}if(this.debug)console.log("getAuthorizations: user:",user,"input:",ownerId,authId,"output",data);return data};deleteAuthorization=async(requestingUserId,authId,token)=>{let user=this.users[requestingUserId];if(!user)return false;let data;if(this.mode.includes("mongo")){data=await this.deleteMongoAuthorization(user,authId,token)}else{data=true;let struct=this.getLocalData("authorization",{_id:authId});if(struct){let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE",token);if(passed)data=this.deleteLocalData(struct)}}if(this.debug)console.log("deleteAuthorization: user:",user,"input:",authId,"output",data);return data};getToken=user=>{return this.useAccessTokens?this.accessTokens.get(user._id):this.useRefreshTokens?this.refreshTokens.get(user._id):void 0};notificationStruct=(parentStruct={})=>{let structType="notification";let struct={structType,timestamp:Date.now(),_id:randomId2(structType),note:"",alert:false,ownerId:"",parentUserId:"",parent:{structType:parentStruct?.structType,_id:getStringId(parentStruct?._id)}};return struct};checkToNotify=async(user,structs=[],mode=this.mode)=>{if(structs.length===0)return false;if(typeof user==="string"){for(let key in this.users){const obj=this.users[key];if(getStringId(obj._id)===user)user=obj}}if(typeof user==="string"||user==null)return false;let usersToNotify={};let newNotifications=[];structs.forEach(async struct=>{if(struct?._id){if(struct.ownerId&&user?._id!==struct.ownerId){let newNotification=this.notificationStruct(struct);newNotification._id="notification_"+getStringId(struct._id)+"_"+struct.ownerId;newNotification.ownerId=struct.ownerId;newNotification.note=struct.structType;newNotification.parentUserId=struct.ownerId;if(struct.alert)newNotification.alert=struct.alert;newNotifications.push(newNotification);usersToNotify[struct.ownerId]=struct.ownerId}if(struct.users){Object.keys(struct.users).forEach(usr=>{if(usr!==user._id){let newNotification=this.notificationStruct(struct);newNotification._id="notification_"+getStringId(struct._id)+"_"+usr;newNotification.ownerId=usr;newNotification.note=struct.structType;if(struct.alert)newNotification.alert=struct.alert;newNotification.parentUserId=struct.ownerId;newNotifications.push(newNotification);usersToNotify[usr]=usr}})}else{let auths=[];if(mode.includes("mongo")){let s=this.collections.authorization.instance.find({$or:[{authorizedId:user._id},{authorizerId:user._id}]});let arr=await s.toArray();if(arr.length>0){arr.forEach(d=>auths.push(d))}}else{auths=this.getLocalData("authorization",{authorizedId:user._id});auths.push(...this.getLocalData("authorization",{authorizerId:user._id}))}if(auths.length>0){auths.forEach(auth=>{if(struct.authorizerId===struct.ownerId&&!usersToNotify[struct.authorizedId]){if(auth.status==="OKAY"&&auth.authorizations["peer"]){let newNotification=this.notificationStruct(struct);newNotification.ownerId=auth.authorizedId;newNotification._id="notification_"+getStringId(struct._id)+"_"+auth.authorizedId;newNotification.note=struct.structType;newNotification.parentUserId=struct.ownerId;if(struct.alert)newNotification.alert=struct.alert;newNotifications.push(newNotification);usersToNotify[newNotification.ownerId]=newNotification.ownerId}}})}}}});if(newNotifications.length>0){if(mode.includes("mongo")){await this.setMongoData(user,newNotifications,true,this.getToken(user))}else{this.setLocalData(newNotifications)}for(const uid in usersToNotify){this.users[uid]?.sendAll({route:"structNotification",args:true})}return true}else return false};queryMongo=async(user,collection,queryObj={},findOne=false,skip=0,token)=>{if(!collection&&!queryObj)return void 0;else if(findOne){let res=await this.db.collection(collection).findOne(queryObj);if(!res)return void 0;let passed=!this.useAuths;if(!res?.ownerId){passed=true}else if(getStringId(user._id)!==res.ownerId||getStringId(user._id)===res.ownerId&&user.userRoles?.admincontrol){if(this.useAuths)passed=await this.checkAuthorization(user,res,"READ",token)}if(passed)return res;else return void 0}else{let res=this.db.collection(collection).find(queryObj).sort({$natural:-1}).skip(skip);let structs=[];let arr=await res.toArray();if(arr.length>0){let passed=!this.useAuths;let checkedAuth="";for(const s of arr){if(!s?.ownerId){passed=true}else if((getStringId(user._id)!==s.ownerId||getStringId(user._id)===s.ownerId&&user.userRoles?.admincontrol)&&checkedAuth!==s.ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,s,"READ",token);checkedAuth=s.ownerId}if(passed)structs.push(s)}}return structs}};setMongoData=async(user,structs=[],notify=true,token)=>{let firstwrite=false;if(structs.length>0){let passed=!this.useAuths;let checkedAuth="";await Promise.all(structs.map(async struct=>{let secondary={};if(Array.isArray(struct)){secondary=struct[1];struct=struct[0]}if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if((getStringId(user._id)!==struct.ownerId||getStringId(user._id)===struct.ownerId&&user.userRoles?.admincontrol)&&checkedAuth!==struct.ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE",token);checkedAuth=struct.ownerId}if(passed){if(struct.structType){if(!this.collections[struct.structType]){this.collections[struct.structType]={};this.collections[struct.structType].reference={}}let copy=JSON.parse(JSON.stringify(struct));if(copy._id)delete copy._id;if(struct._id){if(getStringId(struct._id).includes("defaultId")){await this.db.collection(struct.structType?struct.structType:"data").insertOne(copy);firstwrite=true}else if(struct.structType==="notification")await this.db.collection(struct.structType?struct.structType:"data").updateOne({_id:struct._id},{$set:copy,...secondary},{upsert:true,unique:false});else await this.db.collection(struct.structType?struct.structType:"data").updateOne({_id:toObjectId(struct._id)},{$set:copy,...secondary},{upsert:true})}else if(struct.structType){this.db.collection(struct.structType?struct.structType:"data").insertOne(copy)}}}}));if(firstwrite===true){let toReturn=[];await Promise.all(structs.map(async(struct,j)=>{let copy=JSON.parse(JSON.stringify(struct));if(copy._id&&copy.structType!=="profile")delete copy._id;if(struct.structType!=="comment"){let pulled;if(struct.structType!=="notification")pulled=await this.db.collection(copy.structType).findOne(copy);if(pulled){pulled._id=getStringId(pulled._id);toReturn.push(pulled)}}else if(struct.structType==="comment"){let comment=struct;let copy2=JSON.parse(JSON.stringify(comment));if(copy2._id)delete copy2._id;let pulledComment=await this.db.collection("comment").findOne(copy2);let replyToId=pulledComment?.replyTo;let replyTo=structs.find(s=>{if(getStringId(s._id)===replyToId)return true});if(replyTo){let copy3=JSON.parse(JSON.stringify(replyTo));if(copy3._id)delete copy3._id;let pulledReply;await Promise.all(["discussion","chatroom","comment"].map(async name=>{let found=await this.db.collection(name).findOne({_id:toObjectId(replyToId)});if(found)pulledReply=found}));if(pulledReply){let roomId=getStringId(pulledComment.parent._id);let room,pulledRoom;if(roomId!==replyToId){room=structs.find(s=>{if(getStringId(s._id)===roomId)return true});if(room){delete room._id;await Promise.all(["discussion","chatroom"].map(async name=>{let found=await this.db.collection(name).findOne(room);if(found)pulledRoom=found}))}}else pulledRoom=pulledReply;let toUpdate=[pulledComment];if(pulledReply){let i=pulledReply.replies.indexOf(getStringId(pulledComment._id));if(i<0){pulledReply.replies.push(getStringId(pulledComment._id));pulledComment.replyTo=getStringId(pulledReply._id)}toUpdate.push(pulledReply)}if(pulledRoom){let i=pulledRoom.comments.indexOf(pulledComment._id);if(i<0){pulledRoom.comments.push(getStringId(pulledComment._id));pulledComment.parent._id=getStringId(pulledRoom._id)}}await Promise.all(toUpdate.map(async s=>{let copy4=JSON.parse(JSON.stringify(s));delete copy4._id;await this.db.collection(s.structType).updateOne({_id:toObjectId(s._id)},{$set:copy4},{upsert:false})}));[...toReturn].reverse().forEach((s,j2)=>{if(toUpdate.find(o=>{if(getStringId(s._id)===getStringId(o._id))return true})){toReturn.splice(toReturn.length-j2-1,1)}});toReturn.push(...toUpdate)}}else if(pulledComment){toReturn.push(pulledComment)}}}));if(notify)this.checkToNotify(user,toReturn);return toReturn}else{let non_notes=[];structs.forEach(s=>{if(s.structType!=="notification")non_notes.push(s)});if(notify)this.checkToNotify(user,non_notes);return true}}else return false};setMongoUser=async(user,struct,token)=>{if(struct._id){const _id=toObjectId(struct._id);let usersearch={_id};let userexists=await this.collections.profile.instance.findOne(usersearch);if(userexists){if(getStringId(user._id)!==struct.ownerId||getStringId(user._id)===struct.ownerId&&user.userRoles?.admincontrol){let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE",token);if(!passed)return false}}let copy=JSON.parse(JSON.stringify(struct));copy._id=_id;if(this.debug)console.log("RETURNS PROFILE",struct);await this.collections.profile.instance.updateOne(usersearch,{$set:copy},{upsert:true});user=await this.collections.profile.instance.findOne(usersearch);this.checkToNotify(user,[struct]);return user}else return false};setGroup=async(user,struct,mode=this.mode,token)=>{if(struct?._id){let uid=getStringId(user._id);let exists=void 0;if(mode.includes("mongo")){exists=await this.collections.group.instance.findOne({name:struct.name})}else{exists=this.getLocalData("group",{_id:getStringId(struct._id)})}if(exists&&(exists.ownerId!==struct.ownerId||struct.admins.indexOf(uid)<0))return false;if(uid!==struct.ownerId){let passed=!this.useAuths;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE",token);if(!passed)return false}let allusers=[];Object.keys(struct.users).forEach(u2=>{allusers.push({email:u2},{id:u2},{username:u2})});let users={};let ids={};if(mode.includes("mongo")){let cursor=this.collections.profile.instance.find({$or:allusers});let arr=cursor.toArray();if(arr.length>0){arr.forEach(user2=>{users[uid]=user2;ids[uid]=true})}}else{allusers.forEach(search=>{let result=this.getLocalData("profile",search);if(result.length>0){users[getStringId(result[0]._id)]=result[0];ids[getStringId(result[0]._id)]=true}})}struct.users=ids;let admins={};let peers={};let clients={};Object.keys(users).forEach(id=>{let u2=users[id];if(struct.admins[getStringId(u2._id)]||struct.admins[u2.email]||struct.admins[u2.username]||struct.admins[struct.ownerId]){if(!admins[getStringId(u2._id)])admins[getStringId(u2._id)]=true}if(struct.peers[getStringId(u2._id)]||struct.peers[u2.email]||struct.peers[u2.username]||struct.peers[struct.ownerId]){if(!peers[getStringId(u2._id)])peers[getStringId(u2._id)]=true}if(struct.clients[getStringId(u2._id)]||struct.clients[u2.email]||struct.clients[u2.username]||struct.clients[struct.ownerId]){if(!clients[getStringId(u2._id)])clients[getStringId(u2._id)]=true}});struct.admins=admins;struct.peers=peers;struct.clients=clients;let copy=JSON.parse(JSON.stringify(struct));if(copy._id)delete copy._id;if(mode.includes("mongo")){if(getStringId(struct._id).includes("defaultId")){await this.db.collection(struct.structType?struct.structType:"data").insertOne(copy);delete struct._id;struct=await this.db.collection(struct.structType?struct.structType:"data").findOne(struct);struct._id=getStringId(struct._id)}else await this.collections.group.instance.updateOne({_id:toObjectId(struct._id)},{$set:copy},{upsert:true})}else{this.setLocalData(struct)}this.checkToNotify(user,[struct],this.mode);if(this.debug)console.log("setGroup: user:",user,"output",struct);return struct}else return false};getMongoUser=(user,info="",requireAuth=true,basicInfo=false,token)=>{return new Promise(async resolve=>{const query=[{email:info},{id:info},{username:info}];try{query.push({_id:toObjectId(info)})}catch(e){console.log("error creating ObjectId with ",info)}let u2=await this.collections.profile.instance.findOne({$or:query});if(!u2||u2==null)resolve(void 0);else{u2._id=getStringId(u2._id);if(!u2.ownerId)u2.ownerId=u2._id;if(basicInfo){if(this.useAccessTokens||this.useRefreshTokens){if(this.getToken(user)!==token)resolve(void 0)}let stripped={username:u2.username,firstName:u2.firstName,lastName:u2.lastName,fullName:u2.fullName,pictureUrl:u2.pictureUrl,_id:u2._id};u2=stripped;resolve({user:u2})}else if(requireAuth){if(getStringId(user._id)!==u2._id||getStringId(user._id)===u2._id&&user.userRoles?.admincontrol){let passed=!this.useAuths;if(this.useAuths)passed=await this.checkAuthorization(user,u2,"READ",token);if(!passed)resolve(void 0)}let authorizations=[];let auths=this.collections.authorization.instance.find({ownerId:u2._id});let aarr=await auths.toArray();if(auths.toArray().length>0){aarr.forEach(d=>authorizations.push(d))}let gs=this.collections.group.instance.find({users:{$all:[u2._id]}});let arr=await gs.toArray();let groups=[];if(arr.length>0){arr.forEach(d=>groups.push(d))}resolve({user:u2,authorizations,groups})}else{if(this.useAccessTokens||this.useRefreshTokens){if(this.getToken(user)!==token)resolve(void 0)}resolve({user:u2})}}})};queryUsers=(user,info="",limit=0,skip=0,requireAuth=false,token)=>{if(typeof user==="string")user=this.users[user];if(!user)return Promise.resolve(void 0);return new Promise(async resolve=>{let q={$regex:`^${info}`,$options:"i"};const query=[{email:q},{username:q},{firstName:q},{lastName:q},{name:q}];let arr;if(this.mode.includes("mongo")){let users=this.collections.profile.instance.find({$or:query},{projection:shallowqueryDummy}).skip(skip);if(limit>0)users.limit(limit);await users;arr=await users.toArray();console.log(arr)}else{arr=[];for(let i=0;i<query.length;i++){let dat=this.getLocalData("profile",query[i]);if(Array.isArray(dat)){dat.forEach(u2=>{arr.push({firstName:u2.firstName,lastName:u2.lastName,fullName:u2.fullName,username:u2.username,pictureUrl:u2.pictureUrl})})}else if(dat)arr.push({firstName:dat.firstName,lastName:dat.lastName,fullName:dat.fullName,username:dat.username,pictureUrl:dat.pictureUrl})}}if(requireAuth){let result=[];let strid=getStringId(user._id);for(let i=0;i<arr.length;i++){let u2=arr[i];u2._id=getStringId(u2._id);if(strid!==u2._id||strid===u2._id&&user.userRoles?.admincontrol){let passed=!this.useAuths;if(this.useAuths)passed=await this.checkAuthorization(user,u2,"READ",token);if(passed)result.push(u2)}}arr=result}else if(this.useAccessTokens||this.useRefreshTokens){let tk=this.getToken(user);if(!tk||tk!==token){resolve(false);return}}resolve(arr)})};getMongoUsersByIds=async(user,userIds=[],basicInfo)=>{let usrs=[];userIds.forEach(u2=>{try{usrs.push({_id:toObjectId(u2)})}catch{}});let found=[];if(usrs.length>0){let users=this.collections.profile.instance.find({$or:usrs});let arr=await users.toArray();if(arr.length>0){arr.forEach(u2=>{if(basicInfo){found.push({username:u2.username,firstName:u2.firstName,lastName:u2.lastName,fullName:u2.fullName,pictureUrl:u2.pictureUrl,_id:u2._id})}else found.push(u2)})}}return found};getMongoUsersByRole=async(user,role)=>{let users=this.collections.profile.instance.find({userRoles:{$all:{[role]:true}}});let found=[];let arr=await users.toArray();if(arr.length>0){arr.forEach(u2=>{found.push(u2)})}return found};getMongoDataByIds=async(user,structIds,ownerId,collection,token)=>{let uid=getStringId(user._id);if(structIds.length>0){let query=[];structIds.forEach(_id=>{let q={_id:toObjectId(_id)};if(ownerId)q.ownerId=ownerId;query.push(q)});let found=[];if(!collection){await Promise.all(Object.keys(this.collections).map(async name=>{let cursor=await this.db.collection(name).find({$or:query});let arr=await cursor.toArray();if(arr.length>0){let passed=true;let checkedAuth="";for(let i=0;i<arr.length;i++){let s=arr[i];if(!s?.ownerId)passed=true;else if((uid!==s.ownerId||uid===s.ownerId&&user.userRoles?.admincontrol)&&checkedAuth!==s.ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,s,"READ",token);checkedAuth=s.ownerId}if(passed)found.push(s)}}}))}else{let cursor=await this.db.collection(collection).find({$or:query});let arr=await cursor.toArray();if(arr.length>0){let passed=true;let checkedAuth="";arr.forEach(async s=>{if(!s?.ownerId)passed=true;else if((uid!==s.ownerId||uid===s.ownerId&&user.userRoles?.admincontrol)&&checkedAuth!==s.ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,s,"READ",token);checkedAuth=s.ownerId}if(passed)found.push(s)})}}return found}};getMongoData=async(user,collection,ownerId,dict={},limit=0,skip=0,token)=>{if(!ownerId)ownerId=dict?.ownerId;if(!dict)dict={};if(dict._id)dict._id=toObjectId(dict._id);let uid=getStringId(user._id);let structs=[];let passed=true;let checkedAuth="";let cursor;if(!collection&&!ownerId&&!dict)return[];else if(!collection&&ownerId&&Object.keys(dict).length===0)return await this.getAllUserMongoData(user,ownerId);else if((!dict||Object.keys(dict).length===0)&&ownerId&&collection){cursor=this.db.collection(collection).find({ownerId}).sort({$natural:-1}).skip(skip)}else if(collection&&Object.keys(dict).length>0){if(ownerId)dict.ownerId=ownerId;cursor=await this.db.collection(collection).find(dict).sort({$natural:-1}).skip(skip)}if(cursor){if(limit>0)cursor.limit(limit);let arr=await cursor.toArray();if(arr.length>0){for(let i=0;i<arr.length;i++){let s=arr[i];if(!s?.ownerId)passed=true;else if((uid!==s.ownerId||uid===s.ownerId&&user.userRoles?.admincontrol)&&checkedAuth!==s.ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,s,"READ",token);checkedAuth=s.ownerId}if(passed===true)structs.push(s)}}}else if(!collection&&Object.keys(dict).length>0&&!ownerId){await Promise.all(Object.keys(this.collections).map(async name=>{cursor=await this.db.collection(name).find(dict).sort({$natural:-1}).skip(skip);;if(cursor){if(limit>0)cursor.limit(limit);let arr=await cursor.toArray();if(arr.length>0){for(let i=0;i<arr.length;i++){let s=arr[i];if(!s?.ownerId)passed=true;else if((uid!==s.ownerId||uid===s.ownerId&&user.userRoles?.admincontrol)&&checkedAuth!==s.ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,s,"READ",token);checkedAuth=s.ownerId}if(passed===true)structs.push(s)}}}}))}if(!passed)return[];return structs};getAllUserMongoData=async(user,ownerId,excluded=[],timeRange,token)=>{let structs=[];let passed=true;let checkedId="";await Promise.all(Object.keys(this.collections).map(async(name,j)=>{if(passed&&excluded.indexOf(name)<0){let query={ownerId};if(timeRange){if(typeof timeRange[0]==="string")timeRange[0]=genTimestampFromString(timeRange[0]);if(typeof timeRange[1]==="string")timeRange[1]=genTimestampFromString(timeRange[1]);query.timestamp={$gt:timeRange[0],$lt:timeRange[1]}}let cursor=this.db.collection(name).find(query);let arr=await cursor.toArray();let count=arr.length;for(let k=0;k<count;k++){let struct=arr[k];if(!ownerId)passed=true;else if((getStringId(user._id)!==ownerId||getStringId(user._id)===ownerId&&user.userRoles?.admincontrol)&&checkedId!==ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,struct,"READ",token);checkedId=ownerId}if(passed)structs.push(struct)}}}));if(!passed)return[];return structs};getMongoDataByRefs=async(user,structRefs=[],token)=>{let structs=[];if(structs.length>0){let checkedAuth="";structRefs.forEach(async ref=>{if(ref.structType&&getStringId(ref._id)){let struct=await this.db.collection(ref.structType).findOne({_id:toObjectId(ref._id)});if(struct){let passed=true;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if((getStringId(user._id)!==struct.ownerId||getStringId(user._id)===struct.ownerId&&user.userRoles?.admincontrol)&&checkedAuth!==struct.ownerId){if(this.useAuths)passed=await this.checkAuthorization(user,struct,"READ",token);checkedAuth=struct.ownerId}if(passed===true){structs.push(struct)}}}})}return structs};getMongoAuthorizations=async(user,ownerId=getStringId(user._id),authId="",token)=>{let auths=[];if(authId.length===0){let cursor=this.collections.authorization.instance.find({ownerId});let arr=await cursor.toArray();if(arr.length>0){arr.forEach(a=>{auths.push(a)})}}else auths.push(await this.collections.authorization.instance.findOne({_id:toObjectId(authId),ownerId}));if(!auths[0]?.ownerId)true;else if(getStringId(user._id)!==auths[0]?.ownerId){let passed=!this.useAuths;if(this.useAuths)passed=await this.checkAuthorization(user,auths[0],"READ",token);if(!passed)return void 0}return auths};getMongoGroups=async(user,userId=getStringId(user._id),groupId="")=>{let groups=[];if(groupId.length===0){let cursor=this.collections.group.instance.find({users:{$all:[userId]}});let arr=await cursor.toArray();if(arr.length>0){arr.forEach(a=>{groups.push(a)})}}else{try{groups.push(await this.collections.group.instance.findOne({_id:toObjectId(groupId),users:{$all:[userId]}}))}catch{}}return groups};deleteMongoData=async(user,structRefs=[],token)=>{let structs=[];await Promise.all(structRefs.map(async ref=>{try{let _id=toObjectId(ref._id);let struct=await this.db.collection(ref.structType).findOne({_id});if(struct){structs.push(struct);let notifications=await this.collections.notifications.instance.find({parent:{structType:ref.structType,_id:getStringId(ref._id)}});let count=notifications.toArray().length;for(let i=0;i<count;i++){let note=await notifications.next();if(note)structs.push(note)}}}catch{}}));let checkedOwner="";await Promise.all(structs.map(async(struct,i)=>{let passed=true;if(!struct?.ownerId||struct.ownerId===user._id)passed=true;else if((struct.ownerId!==getStringId(user._id)||getStringId(user._id)===struct.ownerId&&user.userRoles?.admincontrol)&&struct.ownerId!==checkedOwner){checkedOwner=struct.ownerId;if(this.useAuths)passed=await this.checkAuthorization(user,struct,"WRITE",token)}if(passed){await this.db.collection(struct.structType?struct.structType:"data").deleteOne({_id:toObjectId(struct._id)});if(struct.users){Object.keys(struct.users).forEach(uid=>{if(uid!==getStringId(user._id)&&uid!==struct.ownerId&&this.users[uid])this.users[uid]?.sendAll({route:"structDeleted",args:{_id:getStringId(struct._id),structType:struct.structType}})})}if(struct.ownerId!==user._id&&this.users[struct.ownerId]){this.users[struct.ownerId]?.sendAll({route:"structDeleted",args:{_id:getStringId(struct._id),structType:struct.structType}})}}}));return true};deleteMongoUser=async(user,userId,deleteData,token)=>{if(getStringId(user._id)!==userId||getStringId(user._id)===userId&&user.userRoles?.admincontrol){let u2=await this.collections.profile.instance.findOne({id:userId});let passed=!this.useAuths;if(!u2?.ownerId)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,u2,"WRITE",token);if(!passed)return false}await this.collections.profile.instance.deleteOne({id:userId});if(deleteData){for(const key in this.collections){this.collections[key].instance.deleteMany({ownerId:userId});this.collections[key].instance.updateMany({users:{[userId]:true}},{$unset:{[`users.${userId}`]:""}})}}if(getStringId(user._id)!==userId&&this.users[userId])this.users[userId]?.sendAll({route:"structDeleted",args:{_id:userId,structType:"profile"}});return true};deleteMongoGroup=async(user,groupId,token)=>{let s=await this.collections.group.instance.findOne({_id:toObjectId(groupId)});if(s){if(!s?.ownerId)true;else if(getStringId(user._id)!==s.ownerId||getStringId(user._id)===s.ownerId&&user.userRoles?.admincontrol){let passed=!this.useAuths;if(this.useAuths)passed=await this.checkAuthorization(user,s,"WRITE",token);if(!passed)return false}if(s.users){Object.keys(s.users).forEach(u2=>{this.users[u2]?.sendAll({route:"structDeleted",args:{_id:getStringId(s._id),structType:s.structType}})})}await this.collections.group.instance.deleteOne({_id:toObjectId(groupId)});return true}else return false};deleteMongoAuthorization=async(user,authId,token)=>{let s=await this.collections.authorization.instance.findOne({_id:toObjectId(authId)});let uid=getStringId(user._id);if(s){if(uid!==s.ownerId||uid===s.ownerId&&user.userRoles?.admincontrol){let passed=!this.useAuths;if(!s?.ownerId)passed=true;else if(this.useAuths)passed=await this.checkAuthorization(user,s,"WRITE",token);if(!passed)return false}if(s.associatedAuthId){if(this.debug)console.log(s);await this.collections.authorization.instance.deleteOne({_id:toObjectId(s.associatedAuthId)});if(s.authorizerId!==uid)this.users[s.authorizerId]?.sendAll({route:"structDeleted",args:{_id:getStringId(s.associatedAuthId),structType:s.structType}});else if(s.authorizedId!==uid)this.users[s.authorizedId]?.sendAll({route:"structDeleted",args:{_id:getStringId(s.associatedAuthId),structType:s.structType}})}await this.collections.authorization.instance.deleteOne({_id:toObjectId(authId)});if(s.authorizerId===uid)this.users[s.authorizerId]?.sendAll({route:"structDeleted",args:{_id:getStringId(s._id),structType:s.structType}});else if(s.authorizedId===uid)this.users[s.authorizedId]?.sendAll({route:"structDeleted",args:{_id:getStringId(s._id),structType:s.structType}});return true}else return false};setAuthorization=async(user,authStruct,token)=>{let u1,u2;let mmode=this.mode.includes("mongo");if(mmode){u1=(await this.getMongoUser(user,authStruct.authorizedId,false)).user;u2=(await this.getMongoUser(user,authStruct.authorizerId,false)).user}else{u1=this.getLocalData("profile",{"_id":authStruct.authorizedId})?.[0];u2=this.getLocalData("profile",{"_id":authStruct.authorizerId})?.[0]}if(!u1||!u2)return false;if(authStruct.authorizedId!==getStringId(u1._id))authStruct.authorizedId=getStringId(u1._id);if(authStruct.authorizerId!==getStringId(u2._id))authStruct.authorizerId=getStringId(u2._id);if(!authStruct.authorizedName){if(u1.name)authStruct.authorizedName=u1.name;else if(u1.username)authStruct.authorizedName=u1.username;else if(u1.email)authStruct.authorizedName=u1.email}if(!authStruct.authorizerName){if(u1.name)authStruct.authorizedName=u1.name;else if(u2.username)authStruct.authorizerName=u2.username;else if(u2.email)authStruct.authorizerName=u2.email}if(!authStruct?.ownerId)true;else if((getStringId(user._id)!==authStruct.ownerId||getStringId(user._id)===authStruct.ownerId&&user.userRoles?.admincontrol)&&(getStringId(user._id)!==authStruct.authorizedId&&getStringId(user._id)!==authStruct.authorizerId)){let passed=!this.useAuths;if(this.useAuths)passed=await this.checkAuthorization(user,authStruct,"WRITE",token);if(!passed)return false}let auths=[];if(mmode){let s=await this.collections.authorization.instance.find({$and:[{authorizedId:authStruct.authorizedId},{authorizerId:authStruct.authorizerId}]});let arr=await s.toArray();if(arr.length>0){arr.forEach(d=>auths.push(d))}}else{let s=this.getLocalData("authorization",{authorizedId:authStruct.authorizedId});if(Array.isArray(s)){s.forEach(d=>{if(d.authorizerId===authStruct.authorizerId)auths.push(d)})}}let otherAuthset;if(Array.isArray(auths)){for(let i=0;i<auths.length;i++){const auth=auths[i];if(auth.ownerId===getStringId(user._id)){}else{if(authStruct.authorizerId===getStringId(user._id)){auth.authorizations=authStruct.authorizations;auth.structs=authStruct.structs;auth.excluded=authStruct.excluded;auth.expires=authStruct.expires;auth.status="OKAY";authStruct.status="OKAY"}else{authStruct.authorizations=auth.authorizations;authStruct.structs=auth.structs;authStruct.excluded=auth.excluded;authStruct.expires=auth.expires;auth.status="OKAY";authStruct.status="OKAY"}authStruct.associatedAuthId=getStringId(auth._id);auth.associatedAuthId=getStringId(authStruct._id);otherAuthset=auth;let copy2=JSON.parse(JSON.stringify(auth));if(mmode){delete copy2._id;await this.collections.authorization.instance.updateOne({$and:[{authorizedId:authStruct.authorizedId},{authorizerId:authStruct.authorizerId},{ownerId:auth.ownerId}]},{$set:copy2},{upsert:true})}else{this.setLocalData(copy2)}}}}let copy=JSON.parse(JSON.stringify(authStruct));if(mmode){delete copy._id;await this.collections.authorization.instance.updateOne({$and:[{authorizedId:authStruct.authorizedId},{authorizerId:authStruct.authorizerId},{ownerId:authStruct.ownerId}]},{$set:copy},{upsert:true})}else{this.setLocalData(copy)}if(getStringId(authStruct._id).includes("defaultId")&&mmode){let replacedAuth=await this.collections.authorization.instance.findOne(copy);if(replacedAuth){authStruct._id=getStringId(replacedAuth._id);if(otherAuthset){let otherAuth=await this.collections.authorization.instance.findOne({$and:[{authorizedId:otherAuthset.authorizedId},{authorizerId:otherAuthset.authorizerId},{ownerId:otherAuthset.ownerId}]});if(otherAuth){otherAuth.associatedAuthId=getStringId(authStruct._id);let copy2=JSON.parse(JSON.stringify(otherAuth));delete copy2._id;await this.collections.authorization.instance.updateOne({$and:[{authorizedId:otherAuth.authorizedId},{authorizerId:otherAuth.authorizerId},{ownerId:otherAuth.ownerId}]},{$set:copy2},{upsert:true});this.checkToNotify(user,[otherAuth])}}}}return authStruct};checkAuthorization=async(user,struct,request="READ",token)=>{if(typeof user==="string"){if(this.users[user])user=this.users[user];else user={_id:user}}if(!user||!struct)return false;if(!struct.ownerId)return true;if(typeof user==="object"){if(struct.ownerId===getStringId(user._id)){if(user.userRoles?.["admincontrol"]){}return true}}if(this.useAccessTokens){if(!this.accessTokens.get(user._id)||this.accessTokens.get(user._id)!==token){return false}}else if(this.useRefreshTokens){if(!this.refreshTokens.get(user._id)||this.refreshTokens.get(user._id)!==token){return false}}let auth1,auth2;if(this.mode.includes("mongo")){auth1=await this.collections.authorization.instance.findOne({$or:[{authorizedId:getStringId(user._id),authorizerId:struct.ownerId,ownerId:getStringId(user._id)},{authorizedId:struct.ownerId,authorizerId:getStringId(user._id),ownerId:getStringId(user._id)}]});if(!auth1)return false;auth2=await this.collections.authorization.instance.findOne({$or:[{authorizedId:getStringId(user._id),authorizerId:struct.ownerId,ownerId:getStringId(struct.ownerId)},{authorizedId:struct.ownerId,authorizerId:getStringId(user._id),ownerId:getStringId(struct.ownerId)}]})}else{auth1=this.getLocalData("authorization",{ownerId:getStringId(user._id)}).find(o=>{if(o.authorizedId===getStringId(user._id)&&o.authorizerId===struct.ownerId)return true});auth2=this.getLocalData("authorization",{ownerId:struct.ownerId}).find(o=>{if(o.authorizedId===getStringId(user._id)&&o.authorizerId===struct.ownerId)return true})}if(!auth1||!auth2){return false}let passed=false;if(auth1.status==="OKAY"&&auth2.status==="OKAY"){if(struct.structType==="group"){if(auth1.authorizations[struct.name+"_admin"]&&auth2.authorizations[struct.name+"_admin"])passed=true}else if(auth1.authorizations["peer"]&&auth2.authorizations["peer"])passed=true;else if(auth1.authorizations["admincontrol"]&&auth2.authorizations["admincontrol"])passed=true;else if(auth1.structIds[getStringId(struct._id)]&&auth2.structIds[getStringId(struct._id)])passed=true;else if(auth1.excluded[struct.structType]&&struct.ownerId===getStringId(user._id)&&request==="WRITE")passed=false}return passed};wipeDB=async()=>{await Promise.all(Object.values(this.collections).map(c=>{try{c.instance.remove({})}catch(err){}}));return true};overwriteLocalData=structs=>{if(Array.isArray(structs)){structs.forEach(struct=>{let localdat=this.getLocalData(struct.structType,{"ownerId":struct.ownerId,"_id":getStringId(struct._id)});if(!localdat||localdat?.length===0){this.setLocalData(struct)}else Object.assign(localdat,struct)})}else{let localdat=this.getLocalData(structs.structType,{"ownerId":structs.ownerId,"_id":getStringId(structs._id)});if(!localdat||localdat?.length===0){this.setLocalData(structs)}else Object.assign(localdat,structs)}};setLocalData=structs=>{let setInCollection=s=>{let type=s.structType;let collection=this.collections[type]?.reference;if(!collection){collection={};if(!this.collections[type])this.collections[type]={};this.collections[type].reference=collection}collection[getStringId(s._id)]=s};if(Array.isArray(structs)){structs.forEach(s=>{setInCollection(s)})}else setInCollection(structs)};getLocalData=(collection,query)=>{let ownerId,key,value;if(typeof query==="object"){ownerId=query.ownerId;const keys=Object.keys(query).filter(k=>k!="ownerId");key=keys[0];value=query[key]}else value=query;if(!collection&&!ownerId&&!key&&!value)return[];let result=[];if(!collection&&(ownerId||key)){Object.values(this.collections).forEach(c=>{c=c.reference;if((key==="_id"||key==="id")&&value){let found=c[value];if(found)result.push(found)}else{Object.values(c).forEach(struct=>{if(key&&value){if(struct[key]===value&&struct.ownerId===ownerId){result.push(struct)}}else if(struct.ownerId===ownerId){result.push(struct)}})}});return result}else{let c=this.collections[collection]?.reference;if(!c)return result;if(!key&&!ownerId){Object.values(c).forEach(struct=>{result.push(struct)});return result}if((key==="_id"||key==="id")&&value)return getStringId(c[value]);else{Object.keys(c).forEach(k=>{const struct=c[k];if(key&&value&&!ownerId){if(struct[key]===value)result.push(struct)}else if(ownerId&&!key){if(struct.ownerId===ownerId)result.push(struct)}else if(ownerId&&key&&value){if(struct.ownerId===ownerId&&struct[key]){if(struct[key]===value)result.push(struct)}}})}}return result};deleteLocalData=struct=>{if(!struct)throw new Error("Struct not supplied");if(!struct.structType||!struct._id)return false;if(this.collections[struct.structType])delete this.collections[struct.structType].reference[struct._id];return true}};var shallowqueryDummy=DataStructures_exports.ProfileStruct();for(const key in shallowqueryDummy){if(key==="username"||key==="lastName"||key==="firstName"||key==="name"||key==="_id"||key==="pictureUrl")shallowqueryDummy[key]=1;else delete shallowqueryDummy[key]}0&&(module.exports={AuthorizationStruct,CMDService,Callable,ChatroomStruct,CoherenceMap,CoherenceStruct,CommentStruct,DS,Data,DataStruct,DataTablet,DateStruct,E2EEService,ECGStruct,EDAStruct,EEGCoordinates,EEGStruct,EMGStruct,EventHandler,EventStruct,EyeTrackerStruct,FNIRSStruct,FrequencyBandsStruct,Graph,GraphNode,GroupStruct,HRVStruct,HTTPbackend,IMUStruct,NotificationStruct,PPGStruct,ProfileStruct,Router,SSEbackend,ScheduleStruct,Service,SessionsService,Struct,StructBackend,StructFrontend,WSSbackend,animate,backprop,bindListener,branching,connectionHasId,defaultCollections,defaultManifest,defaultServiceWorker,defaultSpecifiers,eegCoordinates,genTimeSpecifiers,genTimestampFromString,getAllProperties,getCallbackFromString,getFnParamNames,getFunctionHead,getStringId,htmlBodyBoilerPlate,instanceObject,isFunction,isNativeClass,isTypedArray,loaders,loop,methodstrings,parseFunctionFromText,pseudoObjectId,randomId,reconstructObject,recursivelyAssign,recursivelyStringifyFunctions,scriptBoilerPlate,setCoordinate,spliceTypedArray,state,stringifyFast,stringifyWithCircularRefs,stringifyWithFunctionsAndCircularRefs,structRegistry,substitute__operator,toObjectId,transformListenerResult,triggerListenerOncreate,wrapArgs});
